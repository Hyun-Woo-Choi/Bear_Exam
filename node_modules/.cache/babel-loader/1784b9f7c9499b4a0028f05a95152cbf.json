{"ast":null,"code":"// src/format.ts\nvar POSITIONALS_EXP = /(%?)(%([sdijo]))/g;\n\nfunction serializePositional(positional, flag) {\n  switch (flag) {\n    case \"s\":\n      return positional;\n\n    case \"d\":\n    case \"i\":\n      return Number(positional);\n\n    case \"j\":\n      return JSON.stringify(positional);\n\n    case \"o\":\n      {\n        if (typeof positional === \"string\") {\n          return positional;\n        }\n\n        const json = JSON.stringify(positional);\n\n        if (json === \"{}\" || json === \"[]\" || /^\\[object .+?\\]$/.test(json)) {\n          return positional;\n        }\n\n        return json;\n      }\n  }\n}\n\nfunction format(message) {\n  for (var _len = arguments.length, positionals = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    positionals[_key - 1] = arguments[_key];\n  }\n\n  if (positionals.length === 0) {\n    return message;\n  }\n\n  let positionalIndex = 0;\n  let formattedMessage = message.replace(POSITIONALS_EXP, (match, isEscaped, _, flag) => {\n    const positional = positionals[positionalIndex];\n    const value = serializePositional(positional, flag);\n\n    if (!isEscaped) {\n      positionalIndex++;\n      return value;\n    }\n\n    return match;\n  });\n\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(\" \")}`;\n  }\n\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, \"%\");\n  return formattedMessage;\n} // src/invariant.ts\n\n\nvar STACK_FRAMES_TO_IGNORE = 2;\n\nfunction cleanErrorStack(error) {\n  if (!error.stack) {\n    return;\n  }\n\n  const nextStack = error.stack.split(\"\\n\");\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE);\n  error.stack = nextStack.join(\"\\n\");\n}\n\nvar InvariantError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = \"Invariant Violation\";\n\n    for (var _len2 = arguments.length, positionals = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      positionals[_key2 - 1] = arguments[_key2];\n    }\n\n    this.message = format(message, ...positionals);\n    cleanErrorStack(this);\n  }\n\n};\n\nvar invariant = function (predicate, message) {\n  if (!predicate) {\n    for (var _len3 = arguments.length, positionals = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      positionals[_key3 - 2] = arguments[_key3];\n    }\n\n    throw new InvariantError(message, ...positionals);\n  }\n};\n\ninvariant.as = function (ErrorConstructor, predicate, message) {\n  if (!predicate) {\n    for (var _len4 = arguments.length, positionals = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n      positionals[_key4 - 3] = arguments[_key4];\n    }\n\n    const formatMessage = positionals.length === 0 ? message : format(message, ...positionals);\n    let error;\n\n    try {\n      error = Reflect.construct(ErrorConstructor, [formatMessage]);\n    } catch (err) {\n      error = ErrorConstructor(formatMessage);\n    }\n\n    throw error;\n  }\n};\n\nexport { InvariantError, format, invariant };","map":{"version":3,"mappings":"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","names":["POSITIONALS_EXP","serializePositional","positional","flag","Number","JSON","stringify","json","test","format","message","positionals","length","positionalIndex","formattedMessage","replace","match","isEscaped","_","value","slice","join","STACK_FRAMES_TO_IGNORE","cleanErrorStack","error","stack","nextStack","split","splice","InvariantError","Error","constructor","invariant","predicate","as","ErrorConstructor","formatMessage","Reflect","construct","err"],"sources":["/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/outvariant/src/format.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/outvariant/src/invariant.ts"],"sourcesContent":["const POSITIONALS_EXP = /(%?)(%([sdijo]))/g\n\nfunction serializePositional(positional: any, flag: string): any {\n  switch (flag) {\n    // Strings.\n    case 's':\n      return positional\n\n    // Digits.\n    case 'd':\n    case 'i':\n      return Number(positional)\n\n    // JSON.\n    case 'j':\n      return JSON.stringify(positional)\n\n    // Objects.\n    case 'o': {\n      // Preserve stings to prevent extra quotes around them.\n      if (typeof positional === 'string') {\n        return positional\n      }\n\n      const json = JSON.stringify(positional)\n\n      // If the positional isn't serializable, return it as-is.\n      if (json === '{}' || json === '[]' || /^\\[object .+?\\]$/.test(json)) {\n        return positional\n      }\n\n      return json\n    }\n  }\n}\n\nexport function format(message: string, ...positionals: any[]): string {\n  if (positionals.length === 0) {\n    return message\n  }\n\n  let positionalIndex = 0\n  let formattedMessage = message.replace(\n    POSITIONALS_EXP,\n    (match, isEscaped, _, flag) => {\n      const positional = positionals[positionalIndex]\n      const value = serializePositional(positional, flag)\n\n      if (!isEscaped) {\n        positionalIndex++\n        return value\n      }\n\n      return match\n    }\n  )\n\n  // Append unresolved positionals to string as-is.\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(' ')}`\n  }\n\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, '%')\n\n  return formattedMessage\n}\n","import { format } from './format'\n\nconst STACK_FRAMES_TO_IGNORE = 2\n\n/**\n * Remove the \"outvariant\" package trace from the given error.\n * This scopes down the error stack to the relevant parts\n * when used in other applications.\n */\nfunction cleanErrorStack(error: Error): void {\n  if (!error.stack) {\n    return\n  }\n\n  const nextStack = error.stack.split('\\n')\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE)\n  error.stack = nextStack.join('\\n')\n}\n\nexport class InvariantError extends Error {\n  name = 'Invariant Violation'\n\n  constructor(public readonly message: string, ...positionals: any[]) {\n    super(message)\n    this.message = format(message, ...positionals)\n    cleanErrorStack(this)\n  }\n}\n\nexport interface CustomErrorConstructor {\n  new (message: string): Error\n}\n\nexport interface CustomErrorFactory {\n  (message: string): Error\n}\n\nexport type CustomError = CustomErrorConstructor | CustomErrorFactory\n\ntype Invariant = {\n  (\n    predicate: unknown,\n    message: string,\n    ...positionals: any[]\n  ): asserts predicate\n\n  as(\n    ErrorConstructor: CustomError,\n    predicate: unknown,\n    message: string,\n    ...positionals: unknown[]\n  ): asserts predicate\n}\n\nexport const invariant: Invariant = (\n  predicate,\n  message,\n  ...positionals\n): asserts predicate => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals)\n  }\n}\n\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage =\n      positionals.length === 0 ? message : format(message, ...positionals)\n    let error: Error\n\n    try {\n      error = Reflect.construct(ErrorConstructor as CustomErrorConstructor, [\n        formatMessage,\n      ])\n    } catch (err) {\n      error = (ErrorConstructor as CustomErrorFactory)(formatMessage)\n    }\n\n    throw error\n  }\n}\n"]},"metadata":{},"sourceType":"module"}