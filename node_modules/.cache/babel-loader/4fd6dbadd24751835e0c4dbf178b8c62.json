{"ast":null,"code":"import { decodeBuffer, encodeBuffer } from \"./chunk-6HYIRFX2.mjs\";\nimport { IS_PATCHED_MODULE, isResponseWithoutBody } from \"./chunk-OMISYKWR.mjs\";\nimport { INTERNAL_REQUEST_ID_HEADER_NAME, Interceptor, InterceptorReadyState, createRequestId, deleteGlobalSymbol, getGlobalSymbol } from \"./chunk-QED3Q6Z2.mjs\"; // src/BatchInterceptor.ts\n\nvar BatchInterceptor = class extends Interceptor {\n  constructor(options) {\n    BatchInterceptor.symbol = Symbol(options.name);\n    super(BatchInterceptor.symbol);\n    this.interceptors = options.interceptors;\n  }\n\n  setup() {\n    const logger = this.logger.extend(\"setup\");\n    logger.info(\"applying all %d interceptors...\", this.interceptors.length);\n\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name);\n      interceptor.apply();\n      logger.info(\"adding interceptor dispose subscription\");\n      this.subscriptions.push(() => interceptor.dispose());\n    }\n  }\n\n  on(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener);\n    }\n\n    return this;\n  }\n\n  once(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener);\n    }\n\n    return this;\n  }\n\n  off(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener);\n    }\n\n    return this;\n  }\n\n  removeAllListeners(event) {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event);\n    }\n\n    return this;\n  }\n\n}; // src/utils/getCleanUrl.ts\n\nfunction getCleanUrl(url) {\n  let isAbsolute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return [isAbsolute && url.origin, url.pathname].filter(Boolean).join(\"\");\n}\n\nexport { BatchInterceptor, INTERNAL_REQUEST_ID_HEADER_NAME, IS_PATCHED_MODULE, Interceptor, InterceptorReadyState, createRequestId, decodeBuffer, deleteGlobalSymbol, encodeBuffer, getCleanUrl, getGlobalSymbol, isResponseWithoutBody };","map":{"version":3,"mappings":";;;;AAsBO,IAAMA,mBAAN,cAGGC,WAHH,CAGuB;EAK5BC,YAAYC,OAAZ,EAA+D;IAC7DH,iBAAiBI,MAAjB,GAA0BC,OAAOF,QAAQG,IAAf,CAA1B;IACA,MAAMN,iBAAiBI,MAAvB;IACA,KAAKG,YAAL,GAAoBJ,QAAQI,YAA5B;EACF;;EAEUC,QAAQ;IAChB,MAAMC,SAAS,KAAKA,MAAL,CAAYC,MAAZ,CAAmB,OAAnB,CAAf;IAEAD,OAAOE,IAAP,CAAY,iCAAZ,EAA+C,KAAKJ,YAAL,CAAkBK,MAAjE;;IAEA,WAAWC,WAAX,IAA0B,KAAKN,YAA/B,EAA6C;MAC3CE,OAAOE,IAAP,CAAY,8BAAZ,EAA4CE,YAAYX,WAAZ,CAAwBI,IAApE;MACAO,YAAYC,KAAZ;MAEAL,OAAOE,IAAP,CAAY,yCAAZ;MACA,KAAKI,aAAL,CAAmBC,IAAnB,CAAwB,MAAMH,YAAYI,OAAZ,EAA9B;IACF;EACF;;EAEOC,GACLC,KADK,EAELC,QAFK,EAGC;IAGN,WAAWP,WAAX,IAA0B,KAAKN,YAA/B,EAA6C;MAC3CM,YAAYK,EAAZ,CAAeC,KAAf,EAAsBC,QAAtB;IACF;;IAEA,OAAO,IAAP;EACF;;EAEOC,KACLF,KADK,EAELC,QAFK,EAGC;IACN,WAAWP,WAAX,IAA0B,KAAKN,YAA/B,EAA6C;MAC3CM,YAAYQ,IAAZ,CAAiBF,KAAjB,EAAwBC,QAAxB;IACF;;IAEA,OAAO,IAAP;EACF;;EAEOE,IACLH,KADK,EAELC,QAFK,EAGC;IACN,WAAWP,WAAX,IAA0B,KAAKN,YAA/B,EAA6C;MAC3CM,YAAYS,GAAZ,CAAgBH,KAAhB,EAAuBC,QAAvB;IACF;;IAEA,OAAO,IAAP;EACF;;EAEOG,mBACLJ,KADK,EAEC;IACN,WAAWZ,YAAX,IAA2B,KAAKA,YAAhC,EAA8C;MAC5CA,aAAagB,kBAAb,CAAgCJ,KAAhC;IACF;;IAEA,OAAO,IAAP;EACF;;AApE4B,CAHvB,C;;ACnBA,SAASK,WAAT,CAAqBC,GAArB,EAAmE;EAAA,IAApCC,UAAoC,uEAAd,IAAc;EACxE,OAAO,CAACA,cAAcD,IAAIE,MAAnB,EAA2BF,IAAIG,QAA/B,EAAyCC,MAAzC,CAAgDC,OAAhD,EAAyDC,IAAzD,CAA8D,EAA9D,CAAP;AACF","names":["BatchInterceptor","Interceptor","constructor","options","symbol","Symbol","name","interceptors","setup","logger","extend","info","length","interceptor","apply","subscriptions","push","dispose","on","event","listener","once","off","removeAllListeners","getCleanUrl","url","isAbsolute","origin","pathname","filter","Boolean","join"],"sources":["/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/@mswjs/interceptors/src/BatchInterceptor.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/@mswjs/interceptors/src/utils/getCleanUrl.ts"],"sourcesContent":["import { EventMap, Listener } from 'strict-event-emitter'\nimport { Interceptor, ExtractEventNames } from './Interceptor'\n\nexport interface BatchInterceptorOptions<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> {\n  name: string\n  interceptors: InterceptorList\n}\n\nexport type ExtractEventMapType<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> = InterceptorList extends ReadonlyArray<infer InterceptorType>\n  ? InterceptorType extends Interceptor<infer EventMap>\n    ? EventMap\n    : never\n  : never\n\n/**\n * A batch interceptor that exposes a single interface\n * to apply and operate with multiple interceptors at once.\n */\nexport class BatchInterceptor<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>,\n  Events extends EventMap = ExtractEventMapType<InterceptorList>\n> extends Interceptor<Events> {\n  static symbol: symbol\n\n  private interceptors: InterceptorList\n\n  constructor(options: BatchInterceptorOptions<InterceptorList>) {\n    BatchInterceptor.symbol = Symbol(options.name)\n    super(BatchInterceptor.symbol)\n    this.interceptors = options.interceptors\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('applying all %d interceptors...', this.interceptors.length)\n\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name)\n      interceptor.apply()\n\n      logger.info('adding interceptor dispose subscription')\n      this.subscriptions.push(() => interceptor.dispose())\n    }\n  }\n\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    // Instead of adding a listener to the batch interceptor,\n    // propagate the listener to each of the individual interceptors.\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener)\n    }\n\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener)\n    }\n\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener)\n    }\n\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName | undefined\n  ): this {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event)\n    }\n\n    return this\n  }\n}\n","/**\n * Removes query parameters and hashes from a given URL.\n */\nexport function getCleanUrl(url: URL, isAbsolute: boolean = true): string {\n  return [isAbsolute && url.origin, url.pathname].filter(Boolean).join('')\n}\n"]},"metadata":{},"sourceType":"module"}