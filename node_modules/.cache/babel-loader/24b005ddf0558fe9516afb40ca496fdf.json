{"ast":null,"code":"// src/Interceptor.ts\nimport { Logger } from \"@open-draft/logger\";\nimport { Emitter } from \"strict-event-emitter\";\nvar INTERNAL_REQUEST_ID_HEADER_NAME = \"x-interceptors-internal-request-id\";\n\nfunction getGlobalSymbol(symbol) {\n  return (// @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || void 0\n  );\n}\n\nfunction setGlobalSymbol(symbol, value) {\n  globalThis[symbol] = value;\n}\n\nfunction deleteGlobalSymbol(symbol) {\n  delete globalThis[symbol];\n}\n\nvar InterceptorReadyState = /* @__PURE__ */(InterceptorReadyState2 => {\n  InterceptorReadyState2[\"INACTIVE\"] = \"INACTIVE\";\n  InterceptorReadyState2[\"APPLYING\"] = \"APPLYING\";\n  InterceptorReadyState2[\"APPLIED\"] = \"APPLIED\";\n  InterceptorReadyState2[\"DISPOSING\"] = \"DISPOSING\";\n  InterceptorReadyState2[\"DISPOSED\"] = \"DISPOSED\";\n  return InterceptorReadyState2;\n})(InterceptorReadyState || {});\n\nvar Interceptor = class {\n  constructor(symbol) {\n    this.symbol = symbol;\n    this.readyState = \"INACTIVE\"\n    /* INACTIVE */\n    ;\n    this.emitter = new Emitter();\n    this.subscriptions = [];\n    this.logger = new Logger(symbol.description);\n    this.emitter.setMaxListeners(0);\n    this.logger.info(\"constructing the interceptor...\");\n  }\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n\n\n  checkEnvironment() {\n    return true;\n  }\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n\n\n  apply() {\n    const logger = this.logger.extend(\"apply\");\n    logger.info(\"applying the interceptor...\");\n\n    if (this.readyState === \"APPLIED\"\n    /* APPLIED */\n    ) {\n      logger.info(\"intercepted already applied!\");\n      return;\n    }\n\n    const shouldApply = this.checkEnvironment();\n\n    if (!shouldApply) {\n      logger.info(\"the interceptor cannot be applied in this environment!\");\n      return;\n    }\n\n    this.readyState = \"APPLYING\"\n    /* APPLYING */\n    ;\n    const runningInstance = this.getInstance();\n\n    if (runningInstance) {\n      logger.info(\"found a running instance, reusing...\");\n\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event);\n        runningInstance.emitter.addListener(event, listener);\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener);\n          logger.info('removed proxied \"%s\" listener!', event);\n        });\n        return this;\n      };\n\n      this.readyState = \"APPLIED\"\n      /* APPLIED */\n      ;\n      return;\n    }\n\n    logger.info(\"no running instance found, setting up a new instance...\");\n    this.setup();\n    this.setInstance();\n    this.readyState = \"APPLIED\"\n    /* APPLIED */\n    ;\n  }\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n\n\n  setup() {}\n  /**\n   * Listen to the interceptor's public events.\n   */\n\n\n  on(event, listener) {\n    const logger = this.logger.extend(\"on\");\n\n    if (this.readyState === \"DISPOSING\"\n    /* DISPOSING */\n    || this.readyState === \"DISPOSED\"\n    /* DISPOSED */\n    ) {\n      logger.info(\"cannot listen to events, already disposed!\");\n      return this;\n    }\n\n    logger.info('adding \"%s\" event listener:', event, listener);\n    this.emitter.on(event, listener);\n    return this;\n  }\n\n  once(event, listener) {\n    this.emitter.once(event, listener);\n    return this;\n  }\n\n  off(event, listener) {\n    this.emitter.off(event, listener);\n    return this;\n  }\n\n  removeAllListeners(event) {\n    this.emitter.removeAllListeners(event);\n    return this;\n  }\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n\n\n  dispose() {\n    const logger = this.logger.extend(\"dispose\");\n\n    if (this.readyState === \"DISPOSED\"\n    /* DISPOSED */\n    ) {\n      logger.info(\"cannot dispose, already disposed!\");\n      return;\n    }\n\n    logger.info(\"disposing the interceptor...\");\n    this.readyState = \"DISPOSING\"\n    /* DISPOSING */\n    ;\n\n    if (!this.getInstance()) {\n      logger.info(\"no interceptors running, skipping dispose...\");\n      return;\n    }\n\n    this.clearInstance();\n    logger.info(\"global symbol deleted:\", getGlobalSymbol(this.symbol));\n\n    if (this.subscriptions.length > 0) {\n      logger.info(\"disposing of %d subscriptions...\", this.subscriptions.length);\n\n      for (const dispose of this.subscriptions) {\n        dispose();\n      }\n\n      this.subscriptions = [];\n      logger.info(\"disposed of all subscriptions!\", this.subscriptions.length);\n    }\n\n    this.emitter.removeAllListeners();\n    logger.info(\"destroyed the listener!\");\n    this.readyState = \"DISPOSED\"\n    /* DISPOSED */\n    ;\n  }\n\n  getInstance() {\n    var _a;\n\n    const instance = getGlobalSymbol(this.symbol);\n    this.logger.info(\"retrieved global instance:\", (_a = instance == null ? void 0 : instance.constructor) == null ? void 0 : _a.name);\n    return instance;\n  }\n\n  setInstance() {\n    setGlobalSymbol(this.symbol, this);\n    this.logger.info(\"set global instance!\", this.symbol.description);\n  }\n\n  clearInstance() {\n    deleteGlobalSymbol(this.symbol);\n    this.logger.info(\"cleared global instance!\", this.symbol.description);\n  }\n\n}; // src/createRequestId.ts\n\nfunction createRequestId() {\n  return Math.random().toString(16).slice(2);\n}\n\nexport { INTERNAL_REQUEST_ID_HEADER_NAME, getGlobalSymbol, deleteGlobalSymbol, InterceptorReadyState, Interceptor, createRequestId };","map":{"version":3,"mappings":"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","names":["Logger","Emitter","INTERNAL_REQUEST_ID_HEADER_NAME","getGlobalSymbol","symbol","globalThis","setGlobalSymbol","value","deleteGlobalSymbol","InterceptorReadyState","Interceptor","constructor","readyState","emitter","subscriptions","logger","description","setMaxListeners","info","checkEnvironment","apply","extend","shouldApply","runningInstance","getInstance","on","event","listener","addListener","push","removeListener","setup","setInstance","once","off","removeAllListeners","dispose","clearInstance","length","instance","_a","name","createRequestId","Math","random","toString","slice"],"sources":["/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/@mswjs/interceptors/src/Interceptor.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/@mswjs/interceptors/src/createRequestId.ts"],"sourcesContent":["import { Logger } from '@open-draft/logger'\nimport { Emitter, Listener } from 'strict-event-emitter'\n\nexport type InterceptorEventMap = Record<string, any>\nexport type InterceptorSubscription = () => void\n\n/**\n * Request header name to detect when a single request\n * is being handled by nested interceptors (XHR -> ClientRequest).\n * Obscure by design to prevent collisions with user-defined headers.\n * Ideally, come up with the Interceptor-level mechanism for this.\n * @see https://github.com/mswjs/interceptors/issues/378\n */\nexport const INTERNAL_REQUEST_ID_HEADER_NAME =\n  'x-interceptors-internal-request-id'\n\nexport function getGlobalSymbol<V>(symbol: Symbol): V | undefined {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  )\n}\n\nfunction setGlobalSymbol(symbol: Symbol, value: any): void {\n  // @ts-ignore\n  globalThis[symbol] = value\n}\n\nexport function deleteGlobalSymbol(symbol: Symbol): void {\n  // @ts-ignore\n  delete globalThis[symbol]\n}\n\nexport enum InterceptorReadyState {\n  INACTIVE = 'INACTIVE',\n  APPLYING = 'APPLYING',\n  APPLIED = 'APPLIED',\n  DISPOSING = 'DISPOSING',\n  DISPOSED = 'DISPOSED',\n}\n\nexport type ExtractEventNames<Events extends Record<string, any>> =\n  Events extends Record<infer EventName, any> ? EventName : never\n\nexport class Interceptor<Events extends InterceptorEventMap> {\n  protected emitter: Emitter<Events>\n  protected subscriptions: Array<InterceptorSubscription>\n  protected logger: Logger\n\n  public readyState: InterceptorReadyState\n\n  constructor(private readonly symbol: symbol) {\n    this.readyState = InterceptorReadyState.INACTIVE\n\n    this.emitter = new Emitter()\n    this.subscriptions = []\n    this.logger = new Logger(symbol.description!)\n\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0)\n\n    this.logger.info('constructing the interceptor...')\n  }\n\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  protected checkEnvironment(): boolean {\n    return true\n  }\n\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  public apply(): void {\n    const logger = this.logger.extend('apply')\n    logger.info('applying the interceptor...')\n\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      logger.info('intercepted already applied!')\n      return\n    }\n\n    const shouldApply = this.checkEnvironment()\n\n    if (!shouldApply) {\n      logger.info('the interceptor cannot be applied in this environment!')\n      return\n    }\n\n    this.readyState = InterceptorReadyState.APPLYING\n\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    const runningInstance = this.getInstance()\n\n    if (runningInstance) {\n      logger.info('found a running instance, reusing...')\n\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event)\n\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener)\n\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener)\n          logger.info('removed proxied \"%s\" listener!', event)\n        })\n\n        return this\n      }\n\n      this.readyState = InterceptorReadyState.APPLIED\n\n      return\n    }\n\n    logger.info('no running instance found, setting up a new instance...')\n\n    // Setup the interceptor.\n    this.setup()\n\n    // Store the newly applied interceptor instance globally.\n    this.setInstance()\n\n    this.readyState = InterceptorReadyState.APPLIED\n  }\n\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  protected setup(): void {}\n\n  /**\n   * Listen to the interceptor's public events.\n   */\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    const logger = this.logger.extend('on')\n\n    if (\n      this.readyState === InterceptorReadyState.DISPOSING ||\n      this.readyState === InterceptorReadyState.DISPOSED\n    ) {\n      logger.info('cannot listen to events, already disposed!')\n      return this\n    }\n\n    logger.info('adding \"%s\" event listener:', event, listener)\n\n    this.emitter.on(event, listener)\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.once(event, listener)\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.off(event, listener)\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName\n  ): this {\n    this.emitter.removeAllListeners(event)\n    return this\n  }\n\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  public dispose(): void {\n    const logger = this.logger.extend('dispose')\n\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      logger.info('cannot dispose, already disposed!')\n      return\n    }\n\n    logger.info('disposing the interceptor...')\n    this.readyState = InterceptorReadyState.DISPOSING\n\n    if (!this.getInstance()) {\n      logger.info('no interceptors running, skipping dispose...')\n      return\n    }\n\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance()\n\n    logger.info('global symbol deleted:', getGlobalSymbol(this.symbol))\n\n    if (this.subscriptions.length > 0) {\n      logger.info('disposing of %d subscriptions...', this.subscriptions.length)\n\n      for (const dispose of this.subscriptions) {\n        dispose()\n      }\n\n      this.subscriptions = []\n\n      logger.info('disposed of all subscriptions!', this.subscriptions.length)\n    }\n\n    this.emitter.removeAllListeners()\n    logger.info('destroyed the listener!')\n\n    this.readyState = InterceptorReadyState.DISPOSED\n  }\n\n  private getInstance(): this | undefined {\n    const instance = getGlobalSymbol<this>(this.symbol)\n    this.logger.info('retrieved global instance:', instance?.constructor?.name)\n    return instance\n  }\n\n  private setInstance(): void {\n    setGlobalSymbol(this.symbol, this)\n    this.logger.info('set global instance!', this.symbol.description)\n  }\n\n  private clearInstance(): void {\n    deleteGlobalSymbol(this.symbol)\n    this.logger.info('cleared global instance!', this.symbol.description)\n  }\n}\n","/**\n * Generate a random ID string to represent a request.\n * @example\n * createRequestId()\n * // \"f774b6c9c600f\"\n */\nexport function createRequestId(): string {\n  return Math.random().toString(16).slice(2)\n}\n"]},"metadata":{},"sourceType":"module"}