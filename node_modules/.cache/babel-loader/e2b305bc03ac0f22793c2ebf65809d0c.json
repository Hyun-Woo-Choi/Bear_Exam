{"ast":null,"code":"import { toPublicUrl } from './toPublicUrl.mjs';\nimport { InternalError, devUtils } from '../internal/devUtils.mjs';\n\nasync function onUnhandledRequest(request) {\n  let strategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"warn\";\n  const url = new URL(request.url);\n  const publicUrl = toPublicUrl(url) + url.search;\n  const unhandledRequestMessage = `intercepted a request without a matching request handler:\n\n  \\u2022 ${request.method} ${publicUrl}\n\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`;\n\n  function applyStrategy(strategy2) {\n    switch (strategy2) {\n      case \"error\":\n        {\n          devUtils.error(\"Error: %s\", unhandledRequestMessage);\n          throw new InternalError(devUtils.formatMessage('Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'));\n        }\n\n      case \"warn\":\n        {\n          devUtils.warn(\"Warning: %s\", unhandledRequestMessage);\n          break;\n        }\n\n      case \"bypass\":\n        break;\n\n      default:\n        throw new InternalError(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.', strategy2));\n    }\n  }\n\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n\n  if (url.protocol === \"file:\") {\n    return;\n  }\n\n  applyStrategy(strategy);\n}\n\nexport { onUnhandledRequest };","map":{"version":3,"mappings":"AAAA,SAASA,WAAT,QAA4B,mBAA5B;AACA,SAASC,aAAT,EAAwBC,QAAxB,QAAwC,0BAAxC;;AAkBA,eAAsBC,kBAAtB,CACEC,OADF,EAGiB;EAAA,IADfC,QACe,uEADsB,MACtB;EACf,MAAMC,MAAM,IAAIC,GAAJ,CAAQH,QAAQE,GAAhB,CAAZ;EACA,MAAME,YAAYR,YAAYM,GAAZ,IAAmBA,IAAIG,MAAzC;EAEA,MAAMC,0BAA0B;AAAA;AAAA,WAAyEN,QAAQO,MAAM,IAAIH,SAAS;AAAA;AAAA;AAAA,uDAApI;;EAEA,SAASI,aAAT,CAAuBP,SAAvB,EAA2D;IACzD,QAAQA,SAAR;MACE,KAAK,OAAL;QAAc;UAEZH,SAASW,KAAT,CAAe,WAAf,EAA4BH,uBAA5B;UAGA,MAAM,IAAIT,aAAJ,CACJC,SAASY,aAAT,CACE,8FADF,CADI,CAAN;QAKF;;MAEA,KAAK,MAAL;QAAa;UACXZ,SAASa,IAAT,CAAc,aAAd,EAA6BL,uBAA7B;UACA;QACF;;MAEA,KAAK,QAAL;QACE;;MAEF;QACE,MAAM,IAAIT,aAAJ,CACJC,SAASY,aAAT,CACE,2NADF,EAEET,SAFF,CADI,CAAN;IAtBJ;EA6BF;;EAEA,IAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;IAClCA,SAASD,OAAT,EAAkB;MAChBY,SAASJ,cAAcK,IAAd,CAAmB,IAAnB,EAAyB,MAAzB,CADO;MAEhBJ,OAAOD,cAAcK,IAAd,CAAmB,IAAnB,EAAyB,OAAzB;IAFS,CAAlB;IAIA;EACF;;EAQA,IAAIX,IAAIY,QAAJ,KAAiB,OAArB,EAA8B;IAC5B;EACF;;EAEAN,cAAcP,QAAd;AACF","names":["toPublicUrl","InternalError","devUtils","onUnhandledRequest","request","strategy","url","URL","publicUrl","search","unhandledRequestMessage","method","applyStrategy","error","formatMessage","warn","warning","bind","protocol"],"sources":["/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/core/utils/request/onUnhandledRequest.ts"],"sourcesContent":["import { toPublicUrl } from './toPublicUrl'\nimport { InternalError, devUtils } from '../internal/devUtils'\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: Request,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\nexport async function onUnhandledRequest(\n  request: Request,\n  strategy: UnhandledRequestStrategy = 'warn',\n): Promise<void> {\n  const url = new URL(request.url)\n  const publicUrl = toPublicUrl(url) + url.search\n\n  const unhandledRequestMessage = `intercepted a request without a matching request handler:\\n\\n  \\u2022 ${request.method} ${publicUrl}\\n\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\\nRead more: https://mswjs.io/docs/getting-started/mocks`\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', unhandledRequestMessage)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new InternalError(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', unhandledRequestMessage)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new InternalError(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  /**\n   * @note Ignore \"file://\" requests.\n   * Those often are an implementation detail of modern tooling\n   * that fetches modules via HTTP. Developers don't issue those\n   * requests and so they mustn't be warned about them.\n   */\n  if (url.protocol === 'file:') {\n    return\n  }\n\n  applyStrategy(strategy)\n}\n"]},"metadata":{},"sourceType":"module"}