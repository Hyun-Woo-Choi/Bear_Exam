{"ast":null,"code":"import { stringToHeaders } from \"headers-polyfill\";\n\nfunction parseContentHeaders(headersString) {\n  const headers = stringToHeaders(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest] = chunk.trim().split(\"=\");\n    acc[name2] = rest.join(\"=\");\n    return acc;\n  }, {});\n  const name = directives.name?.slice(1, -1);\n  const filename = directives.filename?.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\n\nfunction parseMultipartData(data, headers) {\n  const contentType = headers?.get(\"content-type\");\n\n  if (!contentType) {\n    return void 0;\n  }\n\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter(d => d.startsWith(\"boundary=\")).map(s => s.replace(/^boundary=/, \"\"))[0];\n\n  if (!boundary) {\n    return void 0;\n  }\n\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data.split(boundaryRegExp).filter(chunk => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map(chunk => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n\n  if (!fields.length) {\n    return void 0;\n  }\n\n  const parsedBody = {};\n\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest.join(\"\\r\\n\\r\\n\");\n      const {\n        contentType: contentType2,\n        filename,\n        name\n      } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, {\n        type: contentType2\n      });\n      const parsedValue = parsedBody[name];\n\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n\n    return parsedBody;\n  } catch (error) {\n    return void 0;\n  }\n}\n\nexport { parseMultipartData };","map":{"version":3,"mappings":"AAAA,SAASA,eAAT,QAAgC,kBAAhC;;AAgBA,SAASC,mBAAT,CAA6BC,aAA7B,EAA0E;EACxE,MAAMC,UAAUH,gBAAgBE,aAAhB,CAAhB;EACA,MAAME,cAAcD,QAAQE,GAAR,CAAY,cAAZ,KAA+B,YAAnD;EACA,MAAMC,cAAcH,QAAQE,GAAR,CAAY,qBAAZ,CAApB;;EAEA,IAAI,CAACC,WAAL,EAAkB;IAChB,MAAM,IAAIC,KAAJ,CAAU,2CAAV,CAAN;EACF;;EAEA,MAAMC,aAAaF,YAAYG,KAAZ,CAAkB,GAAlB,EAAuBC,MAAvB,CAA8B,CAACC,GAAD,EAAMC,KAAN,KAAgB;IAC/D,MAAM,CAACC,KAAD,EAAO,GAAGC,IAAV,IAAkBF,MAAMG,IAAN,GAAaN,KAAb,CAAmB,GAAnB,CAAxB;IACAE,IAAIE,KAAJ,IAAYC,KAAKE,IAAL,CAAU,GAAV,CAAZ;IACA,OAAOL,GAAP;EACF,CAJmB,EAIhB,EAJgB,CAAnB;EAMA,MAAME,OAAOL,WAAWK,IAAX,EAAiBI,KAAjB,CAAuB,CAAvB,EAA0B,EAA1B,CAAb;EACA,MAAMC,WAAWV,WAAWU,QAAX,EAAqBD,KAArB,CAA2B,CAA3B,EAA8B,EAA9B,CAAjB;EAEA,OAAO;IACLJ,IADK;IAELK,QAFK;IAGLd;EAHK,CAAP;AAKF;;AAMO,SAASe,kBAAT,CACLC,IADK,EAELjB,OAFK,EAGU;EACf,MAAMC,cAAcD,SAASE,GAAT,CAAa,cAAb,CAApB;;EAEA,IAAI,CAACD,WAAL,EAAkB;IAChB,OAAO,MAAP;EACF;;EAEA,MAAM,GAAG,GAAGI,UAAN,IAAoBJ,YAAYK,KAAZ,CAAkB,KAAlB,CAA1B;EACA,MAAMY,WAAWb,WACdc,MADc,CACNC,CAAD,IAAOA,EAAEC,UAAF,CAAa,WAAb,CADA,EAEdC,GAFc,CAETC,CAAD,IAAOA,EAAEC,OAAF,CAAU,YAAV,EAAwB,EAAxB,CAFG,EAE0B,CAF1B,CAAjB;;EAIA,IAAI,CAACN,QAAL,EAAe;IACb,OAAO,MAAP;EACF;;EAEA,MAAMO,iBAAiB,IAAIC,MAAJ,CAAW,MAAMR,QAAQ,EAAzB,CAAvB;EACA,MAAMS,SAASV,KACZX,KADY,CACNmB,cADM,EAEZN,MAFY,CAEJV,KAAD,IAAWA,MAAMY,UAAN,CAAiB,MAAjB,KAA4BZ,MAAMmB,QAAN,CAAe,MAAf,CAFlC,EAGZN,GAHY,CAGPb,KAAD,IAAWA,MAAMoB,SAAN,GAAkBL,OAAlB,CAA0B,OAA1B,EAAmC,EAAnC,CAHH,CAAf;;EAKA,IAAI,CAACG,OAAOG,MAAZ,EAAoB;IAClB,OAAO,MAAP;EACF;;EAEA,MAAMC,aAA0C,EAAhD;;EAEA,IAAI;IACF,WAAWC,KAAX,IAAoBL,MAApB,EAA4B;MAC1B,MAAM,CAACM,cAAD,EAAiB,GAAGtB,IAApB,IAA4BqB,MAAM1B,KAAN,CAAY,UAAZ,CAAlC;MACA,MAAM4B,cAAcvB,KAAKE,IAAL,CAAU,UAAV,CAApB;MACA,MAAM;QAAEZ,yBAAF;QAAec,QAAf;QAAyBL;MAAzB,IACJZ,oBAAoBmC,cAApB,CADF;MAGA,MAAME,QACJpB,aAAa,MAAb,GACImB,WADJ,GAEI,IAAIE,IAAJ,CAAS,CAACF,WAAD,CAAT,EAAwBnB,QAAxB,EAAkC;QAAEsB,MAAMpC;MAAR,CAAlC,CAHN;MAKA,MAAMqC,cAAcP,WAAWrB,IAAX,CAApB;;MAEA,IAAI4B,gBAAgB,MAApB,EAA+B;QAC7BP,WAAWrB,IAAX,IAAmByB,KAAnB;MACF,CAFA,MAEA,IAAWI,MAAMC,OAAN,CAAcF,WAAd,CAAX,EAAuC;QACrCP,WAAWrB,IAAX,IAAmB,CAAC,GAAG4B,WAAJ,EAAiBH,KAAjB,CAAnB;MACF,CAFA,MAEO;QACLJ,WAAWrB,IAAX,IAAmB,CAAC4B,WAAD,EAAcH,KAAd,CAAnB;MACF;IACF;;IAEA,OAAOJ,UAAP;EACF,CAxBA,CAwBA,OAASU,KAAT,EAAgB;IACd,OAAO,MAAP;EACF;AACF","names":["stringToHeaders","parseContentHeaders","headersString","headers","contentType","get","disposition","Error","directives","split","reduce","acc","chunk","name","rest","trim","join","slice","filename","parseMultipartData","data","boundary","filter","d","startsWith","map","s","replace","boundaryRegExp","RegExp","fields","endsWith","trimStart","length","parsedBody","field","contentHeaders","contentBody","value","File","type","parsedValue","Array","isArray","error"],"sources":["/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/core/utils/internal/parseMultipartData.ts"],"sourcesContent":["import { stringToHeaders } from 'headers-polyfill'\nimport { DefaultRequestMultipartBody } from '../../handlers/RequestHandler'\n\ninterface ParsedContentHeaders {\n  name: string\n  filename?: string\n  contentType: string\n}\n\ninterface ContentDispositionDirective {\n  [key: string]: string | undefined\n  name: string\n  filename?: string\n  'form-data': string\n}\n\nfunction parseContentHeaders(headersString: string): ParsedContentHeaders {\n  const headers = stringToHeaders(headersString)\n  const contentType = headers.get('content-type') || 'text/plain'\n  const disposition = headers.get('content-disposition')\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.')\n  }\n\n  const directives = disposition.split(';').reduce((acc, chunk) => {\n    const [name, ...rest] = chunk.trim().split('=')\n    acc[name] = rest.join('=')\n    return acc\n  }, {} as ContentDispositionDirective)\n\n  const name = directives.name?.slice(1, -1)\n  const filename = directives.filename?.slice(1, -1)\n\n  return {\n    name,\n    filename,\n    contentType,\n  }\n}\n\n/**\n * Parses a given string as a multipart/form-data.\n * Does not throw an exception on an invalid multipart string.\n */\nexport function parseMultipartData<T extends DefaultRequestMultipartBody>(\n  data: string,\n  headers?: Headers,\n): T | undefined {\n  const contentType = headers?.get('content-type')\n\n  if (!contentType) {\n    return undefined\n  }\n\n  const [, ...directives] = contentType.split(/; */)\n  const boundary = directives\n    .filter((d) => d.startsWith('boundary='))\n    .map((s) => s.replace(/^boundary=/, ''))[0]\n\n  if (!boundary) {\n    return undefined\n  }\n\n  const boundaryRegExp = new RegExp(`--+${boundary}`)\n  const fields = data\n    .split(boundaryRegExp)\n    .filter((chunk) => chunk.startsWith('\\r\\n') && chunk.endsWith('\\r\\n'))\n    .map((chunk) => chunk.trimStart().replace(/\\r\\n$/, ''))\n\n  if (!fields.length) {\n    return undefined\n  }\n\n  const parsedBody: DefaultRequestMultipartBody = {}\n\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split('\\r\\n\\r\\n')\n      const contentBody = rest.join('\\r\\n\\r\\n')\n      const { contentType, filename, name } =\n        parseContentHeaders(contentHeaders)\n\n      const value =\n        filename === undefined\n          ? contentBody\n          : new File([contentBody], filename, { type: contentType })\n\n      const parsedValue = parsedBody[name]\n\n      if (parsedValue === undefined) {\n        parsedBody[name] = value\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value]\n      } else {\n        parsedBody[name] = [parsedValue, value]\n      }\n    }\n\n    return parsedBody as T\n  } catch (error) {\n    return undefined\n  }\n}\n"]},"metadata":{},"sourceType":"module"}