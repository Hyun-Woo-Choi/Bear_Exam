{"ast":null,"code":"import { until } from \"@open-draft/until\";\nimport { executeHandlers } from './executeHandlers.mjs';\nimport { onUnhandledRequest } from './request/onUnhandledRequest.mjs';\nimport { storeResponseCookies } from './request/storeResponseCookies.mjs';\n\nasync function handleRequest(request, requestId, handlers, options, emitter, handleRequestOptions) {\n  emitter.emit(\"request:start\", {\n    request,\n    requestId\n  });\n\n  if (request.headers.get(\"x-msw-intention\") === \"bypass\") {\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n\n  const lookupResult = await until(() => {\n    return executeHandlers({\n      request,\n      requestId,\n      handlers,\n      resolutionContext: handleRequestOptions?.resolutionContext\n    });\n  });\n\n  if (lookupResult.error) {\n    emitter.emit(\"unhandledException\", {\n      error: lookupResult.error,\n      request,\n      requestId\n    });\n    throw lookupResult.error;\n  }\n\n  if (!lookupResult.data) {\n    await onUnhandledRequest(request, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", {\n      request,\n      requestId\n    });\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n\n  const {\n    response\n  } = lookupResult.data;\n\n  if (!response) {\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n\n  if (response.status === 302 && response.headers.get(\"x-msw-intention\") === \"passthrough\") {\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n\n  storeResponseCookies(request, response);\n  emitter.emit(\"request:match\", {\n    request,\n    requestId\n  });\n  const requiredLookupResult = lookupResult.data;\n  const transformedResponse = handleRequestOptions?.transformResponse?.(response) || response;\n  handleRequestOptions?.onMockedResponse?.(transformedResponse, requiredLookupResult);\n  emitter.emit(\"request:end\", {\n    request,\n    requestId\n  });\n  return transformedResponse;\n}\n\nexport { handleRequest };","map":{"version":3,"mappings":"AAAA,SAASA,KAAT,QAAsB,mBAAtB;AAKA,SAAkCC,eAAlC,QAAyD,uBAAzD;AACA,SAASC,kBAAT,QAAmC,kCAAnC;AACA,SAASC,oBAAT,QAAqC,oCAArC;;AAqCA,eAAsBC,aAAtB,CACEC,OADF,EAEEC,SAFF,EAGEC,QAHF,EAIEC,OAJF,EAKEC,OALF,EAMEC,oBANF,EAOiC;EAC/BD,QAAQE,IAAR,CAAa,eAAb,EAA8B;IAAEN,OAAF;IAAWC;EAAX,CAA9B;;EAGA,IAAID,QAAQO,OAAR,CAAgBC,GAAhB,CAAoB,iBAApB,MAA2C,QAA/C,EAAyD;IACvDJ,QAAQE,IAAR,CAAa,aAAb,EAA4B;MAAEN,OAAF;MAAWC;IAAX,CAA5B;IACAI,sBAAsBI,qBAAtB,GAA8CT,OAA9C;IACA;EACF;;EAGA,MAAMU,eAAe,MAAMf,MAAM,MAAM;IACrC,OAAOC,gBAAgB;MACrBI,OADqB;MAErBC,SAFqB;MAGrBC,QAHqB;MAIrBS,mBAAmBN,sBAAsBM;IAJpB,CAAhB,CAAP;EAMD,CAP0B,CAA3B;;EASA,IAAID,aAAaE,KAAjB,EAAwB;IAEtBR,QAAQE,IAAR,CAAa,oBAAb,EAAmC;MACjCM,OAAOF,aAAaE,KADa;MAEjCZ,OAFiC;MAGjCC;IAHiC,CAAnC;IAKA,MAAMS,aAAaE,KAAnB;EACF;;EAIA,IAAI,CAACF,aAAaG,IAAlB,EAAwB;IACtB,MAAMhB,mBAAmBG,OAAnB,EAA4BG,QAAQN,kBAApC,CAAN;IACAO,QAAQE,IAAR,CAAa,mBAAb,EAAkC;MAAEN,OAAF;MAAWC;IAAX,CAAlC;IACAG,QAAQE,IAAR,CAAa,aAAb,EAA4B;MAAEN,OAAF;MAAWC;IAAX,CAA5B;IACAI,sBAAsBI,qBAAtB,GAA8CT,OAA9C;IACA;EACF;;EAEA,MAAM;IAAEc;EAAF,IAAeJ,aAAaG,IAAlC;;EAIA,IAAI,CAACC,QAAL,EAAe;IACbV,QAAQE,IAAR,CAAa,aAAb,EAA4B;MAAEN,OAAF;MAAWC;IAAX,CAA5B;IACAI,sBAAsBI,qBAAtB,GAA8CT,OAA9C;IACA;EACF;;EAIA,IACEc,SAASC,MAAT,KAAoB,GAApB,IACAD,SAASP,OAAT,CAAiBC,GAAjB,CAAqB,iBAArB,MAA4C,aAF9C,EAGE;IACAJ,QAAQE,IAAR,CAAa,aAAb,EAA4B;MAAEN,OAAF;MAAWC;IAAX,CAA5B;IACAI,sBAAsBI,qBAAtB,GAA8CT,OAA9C;IACA;EACF;;EAGAF,qBAAqBE,OAArB,EAA8Bc,QAA9B;EAEAV,QAAQE,IAAR,CAAa,eAAb,EAA8B;IAAEN,OAAF;IAAWC;EAAX,CAA9B;EAEA,MAAMe,uBACJN,aAAaG,IADf;EAGA,MAAMI,sBACJZ,sBAAsBa,iBAAtB,GAA0CJ,QAA1C,KACCA,QAFH;EAIAT,sBAAsBc,gBAAtB,GACEF,mBADF,EAEED,oBAFF;EAKAZ,QAAQE,IAAR,CAAa,aAAb,EAA4B;IAAEN,OAAF;IAAWC;EAAX,CAA5B;EAEA,OAAOgB,mBAAP;AACF","names":["until","executeHandlers","onUnhandledRequest","storeResponseCookies","handleRequest","request","requestId","handlers","options","emitter","handleRequestOptions","emit","headers","get","onPassthroughResponse","lookupResult","resolutionContext","error","data","response","status","requiredLookupResult","transformedResponse","transformResponse","onMockedResponse"],"sources":["/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/core/utils/handleRequest.ts"],"sourcesContent":["import { until } from '@open-draft/until'\nimport { Emitter } from 'strict-event-emitter'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { LifeCycleEventsMap, SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { HandlersExecutionResult, executeHandlers } from './executeHandlers'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { storeResponseCookies } from './request/storeResponseCookies'\n\nexport interface HandleRequestOptions {\n  /**\n   * `resolutionContext` is not part of the general public api\n   * but is exposed to aid in creating extensions like\n   * `@mswjs/http-middleware`.\n   */\n  resolutionContext?: {\n    /**\n     * A base url to use when resolving relative urls.\n     * @note This is primarily used by the `@mswjs/http-middleware`\n     * to resolve relative urls in the context of the running server\n     */\n    baseUrl?: string\n  }\n\n  /**\n   * Transforms a `MockedResponse` instance returned from a handler\n   * to a response instance supported by the lower tooling (i.e. interceptors).\n   */\n  transformResponse?(response: Response): Response\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: Request): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: Response,\n    handler: RequiredDeep<HandlersExecutionResult>,\n  ): void\n}\n\nexport async function handleRequest(\n  request: Request,\n  requestId: string,\n  handlers: Array<RequestHandler>,\n  options: RequiredDeep<SharedOptions>,\n  emitter: Emitter<LifeCycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions,\n): Promise<Response | undefined> {\n  emitter.emit('request:start', { request, requestId })\n\n  // Perform bypassed requests (i.e. wrapped in \"bypass()\") as-is.\n  if (request.headers.get('x-msw-intention') === 'bypass') {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const lookupResult = await until(() => {\n    return executeHandlers({\n      request,\n      requestId,\n      handlers,\n      resolutionContext: handleRequestOptions?.resolutionContext,\n    })\n  })\n\n  if (lookupResult.error) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', {\n      error: lookupResult.error,\n      request,\n      requestId,\n    })\n    throw lookupResult.error\n  }\n\n  // If the handler lookup returned nothing, no request handler was found\n  // matching this request. Report the request as unhandled.\n  if (!lookupResult.data) {\n    await onUnhandledRequest(request, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', { request, requestId })\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  const { response } = lookupResult.data\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Perform the request as-is when the developer explicitly returned \"req.passthrough()\".\n  // This produces no warning as the request was handled.\n  if (\n    response.status === 302 &&\n    response.headers.get('x-msw-intention') === 'passthrough'\n  ) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the cookie jar.\n  storeResponseCookies(request, response)\n\n  emitter.emit('request:match', { request, requestId })\n\n  const requiredLookupResult =\n    lookupResult.data as RequiredDeep<HandlersExecutionResult>\n\n  const transformedResponse =\n    handleRequestOptions?.transformResponse?.(response) ||\n    (response as any as Response)\n\n  handleRequestOptions?.onMockedResponse?.(\n    transformedResponse,\n    requiredLookupResult,\n  )\n\n  emitter.emit('request:end', { request, requestId })\n\n  return transformedResponse\n}\n"]},"metadata":{},"sourceType":"module"}