{"ast":null,"code":"import { RequestHandler } from './RequestHandler.mjs';\nimport { getTimestamp } from '../utils/logging/getTimestamp.mjs';\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor.mjs';\nimport { serializeRequest } from '../utils/logging/serializeRequest.mjs';\nimport { serializeResponse } from '../utils/logging/serializeResponse.mjs';\nimport { matchRequestUrl } from '../utils/matching/matchRequestUrl.mjs';\nimport { parseGraphQLRequest, parseDocumentNode } from '../utils/internal/parseGraphQLRequest.mjs';\nimport { toPublicUrl } from '../utils/request/toPublicUrl.mjs';\nimport { devUtils } from '../utils/internal/devUtils.mjs';\nimport { getAllRequestCookies } from '../utils/request/getRequestCookies.mjs';\n\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\n\nclass GraphQLHandler extends RequestHandler {\n  endpoint;\n  static parsedRequestCache = /* @__PURE__ */new WeakMap();\n\n  constructor(operationType, operationName, endpoint, resolver, options) {\n    let resolvedOperationName = operationName;\n\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`);\n      }\n\n      if (!parsedNode.operationName) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`);\n      }\n\n      resolvedOperationName = parsedNode.operationName;\n    }\n\n    const header = operationType === \"all\" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      resolver,\n      options\n    });\n    this.endpoint = endpoint;\n  }\n  /**\n   * Parses the request body, once per request, cached across all\n   * GraphQL handlers. This is done to avoid multiple parsing of the\n   * request body, which each requires a clone of the request.\n   */\n\n\n  async parseGraphQLRequestOrGetFromCache(request) {\n    if (!GraphQLHandler.parsedRequestCache.has(request)) {\n      GraphQLHandler.parsedRequestCache.set(request, await parseGraphQLRequest(request).catch(error => {\n        console.error(error);\n        return void 0;\n      }));\n    }\n\n    return GraphQLHandler.parsedRequestCache.get(request);\n  }\n\n  async parse(args) {\n    const match = matchRequestUrl(new URL(args.request.url), this.endpoint);\n    const cookies = getAllRequestCookies(args.request);\n\n    if (!match.matches) {\n      return {\n        match,\n        cookies\n      };\n    }\n\n    const parsedResult = await this.parseGraphQLRequestOrGetFromCache(args.request);\n\n    if (typeof parsedResult === \"undefined\") {\n      return {\n        match,\n        cookies\n      };\n    }\n\n    return {\n      match,\n      cookies,\n      query: parsedResult.query,\n      operationType: parsedResult.operationType,\n      operationName: parsedResult.operationName,\n      variables: parsedResult.variables\n    };\n  }\n\n  predicate(args) {\n    if (args.parsedResult.operationType === void 0) {\n      return false;\n    }\n\n    if (!args.parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = toPublicUrl(args.request.url);\n      devUtils.warn(`Failed to intercept a GraphQL request at \"${args.request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation()\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/#graphqloperationresolver`);\n      return false;\n    }\n\n    const hasMatchingOperationType = this.info.operationType === \"all\" || args.parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(args.parsedResult.operationName || \"\") : args.parsedResult.operationName === this.info.operationName;\n    return args.parsedResult.match.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n\n  extendResolverArgs(args) {\n    return {\n      query: args.parsedResult.query || \"\",\n      operationName: args.parsedResult.operationName || \"\",\n      variables: args.parsedResult.variables || {},\n      cookies: args.parsedResult.cookies\n    };\n  }\n\n  async log(args) {\n    const loggedRequest = await serializeRequest(args.request);\n    const loggedResponse = await serializeResponse(args.response);\n    const statusColor = getStatusCodeColor(loggedResponse.status);\n    const requestInfo = args.parsedResult.operationName ? `${args.parsedResult.operationType} ${args.parsedResult.operationName}` : `anonymous ${args.parsedResult.operationType}`;\n    console.groupCollapsed(devUtils.formatMessage(`${getTimestamp()} ${requestInfo} (%c${loggedResponse.status} ${loggedResponse.statusText}%c)`), `color:${statusColor}`, \"color:inherit\");\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n\n}\n\nexport { GraphQLHandler, isDocumentNode };","map":{"version":3,"mappings":"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","names":["RequestHandler","getTimestamp","getStatusCodeColor","serializeRequest","serializeResponse","matchRequestUrl","parseGraphQLRequest","parseDocumentNode","toPublicUrl","devUtils","getAllRequestCookies","isDocumentNode","value","GraphQLHandler","endpoint","WeakMap","constructor","operationType","operationName","resolver","options","resolvedOperationName","parsedNode","Error","header","toString","info","request","parsedRequestCache","has","set","catch","error","console","get","args","match","URL","url","cookies","matches","parsedResult","parseGraphQLRequestOrGetFromCache","query","variables","predicate","publicUrl","warn","method","hasMatchingOperationType","hasMatchingOperationName","RegExp","test","extendResolverArgs","loggedRequest","loggedResponse","response","statusColor","status","requestInfo","groupCollapsed","formatMessage","statusText","log","groupEnd"],"sources":["/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/core/handlers/GraphQLHandler.ts"],"sourcesContent":["import type { DocumentNode, GraphQLError, OperationTypeNode } from 'graphql'\nimport {\n  DefaultBodyType,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  RequestHandlerOptions,\n  ResponseResolver,\n} from './RequestHandler'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { serializeRequest } from '../utils/logging/serializeRequest'\nimport { serializeResponse } from '../utils/logging/serializeResponse'\nimport { Match, matchRequestUrl, Path } from '../utils/matching/matchRequestUrl'\nimport {\n  ParsedGraphQLRequest,\n  GraphQLMultipartRequestBody,\n  parseGraphQLRequest,\n  parseDocumentNode,\n} from '../utils/internal/parseGraphQLRequest'\nimport { toPublicUrl } from '../utils/request/toPublicUrl'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { getAllRequestCookies } from '../utils/request/getRequestCookies'\n\nexport type ExpectedOperationTypeNode = OperationTypeNode | 'all'\nexport type GraphQLHandlerNameSelector = DocumentNode | RegExp | string\n\nexport type GraphQLQuery = Record<string, any>\nexport type GraphQLVariables = Record<string, any>\n\nexport interface GraphQLHandlerInfo extends RequestHandlerDefaultInfo {\n  operationType: ExpectedOperationTypeNode\n  operationName: GraphQLHandlerNameSelector\n}\n\nexport type GraphQLRequestParsedResult = {\n  match: Match\n  cookies: Record<string, string>\n} & (\n  | ParsedGraphQLRequest<GraphQLVariables>\n  /**\n   * An empty version of the ParsedGraphQLRequest\n   * which simplifies the return type of the resolver\n   * when the request is to a non-matching endpoint\n   */\n  | {\n      operationType?: undefined\n      operationName?: undefined\n      query?: undefined\n      variables?: undefined\n    }\n)\n\nexport type GraphQLResolverExtras<Variables extends GraphQLVariables> = {\n  query: string\n  operationName: string\n  variables: Variables\n  cookies: Record<string, string>\n}\n\nexport type GraphQLRequestBody<VariablesType extends GraphQLVariables> =\n  | GraphQLJsonRequestBody<VariablesType>\n  | GraphQLMultipartRequestBody\n  | Record<string, any>\n  | undefined\n\nexport interface GraphQLJsonRequestBody<Variables extends GraphQLVariables> {\n  query: string\n  variables?: Variables\n}\n\nexport type GraphQLResponseBody<BodyType extends DefaultBodyType> =\n  | {\n      data?: BodyType | null\n      errors?: readonly Partial<GraphQLError>[] | null\n    }\n  | null\n  | undefined\n\nexport function isDocumentNode(\n  value: DocumentNode | any,\n): value is DocumentNode {\n  if (value == null) {\n    return false\n  }\n\n  return typeof value === 'object' && 'kind' in value && 'definitions' in value\n}\n\nexport class GraphQLHandler extends RequestHandler<\n  GraphQLHandlerInfo,\n  GraphQLRequestParsedResult,\n  GraphQLResolverExtras<any>\n> {\n  private endpoint: Path\n\n  static parsedRequestCache = new WeakMap<\n    Request,\n    ParsedGraphQLRequest<GraphQLVariables>\n  >()\n\n  constructor(\n    operationType: ExpectedOperationTypeNode,\n    operationName: GraphQLHandlerNameSelector,\n    endpoint: Path,\n    resolver: ResponseResolver<GraphQLResolverExtras<any>, any, any>,\n    options?: RequestHandlerOptions,\n  ) {\n    let resolvedOperationName = operationName\n\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName)\n\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`,\n        )\n      }\n\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`,\n        )\n      }\n\n      resolvedOperationName = parsedNode.operationName\n    }\n\n    const header =\n      operationType === 'all'\n        ? `${operationType} (origin: ${endpoint.toString()})`\n        : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`\n\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName,\n      },\n      resolver,\n      options,\n    })\n\n    this.endpoint = endpoint\n  }\n\n  /**\n   * Parses the request body, once per request, cached across all\n   * GraphQL handlers. This is done to avoid multiple parsing of the\n   * request body, which each requires a clone of the request.\n   */\n  async parseGraphQLRequestOrGetFromCache(\n    request: Request,\n  ): Promise<ParsedGraphQLRequest<GraphQLVariables>> {\n    if (!GraphQLHandler.parsedRequestCache.has(request)) {\n      GraphQLHandler.parsedRequestCache.set(\n        request,\n        await parseGraphQLRequest(request).catch((error) => {\n          console.error(error)\n          return undefined\n        }),\n      )\n    }\n\n    return GraphQLHandler.parsedRequestCache.get(request)\n  }\n\n  async parse(args: { request: Request }): Promise<GraphQLRequestParsedResult> {\n    /**\n     * If the request doesn't match a specified endpoint, there's no\n     * need to parse it since there's no case where we would handle this\n     */\n    const match = matchRequestUrl(new URL(args.request.url), this.endpoint)\n    const cookies = getAllRequestCookies(args.request)\n\n    if (!match.matches) {\n      return { match, cookies }\n    }\n\n    const parsedResult = await this.parseGraphQLRequestOrGetFromCache(\n      args.request,\n    )\n\n    if (typeof parsedResult === 'undefined') {\n      return { match, cookies }\n    }\n\n    return {\n      match,\n      cookies,\n      query: parsedResult.query,\n      operationType: parsedResult.operationType,\n      operationName: parsedResult.operationName,\n      variables: parsedResult.variables,\n    }\n  }\n\n  predicate(args: {\n    request: Request\n    parsedResult: GraphQLRequestParsedResult\n  }) {\n    if (args.parsedResult.operationType === undefined) {\n      return false\n    }\n\n    if (!args.parsedResult.operationName && this.info.operationType !== 'all') {\n      const publicUrl = toPublicUrl(args.request.url)\n\n      devUtils.warn(`\\\nFailed to intercept a GraphQL request at \"${args.request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation()\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/#graphqloperationresolver`)\n      return false\n    }\n\n    const hasMatchingOperationType =\n      this.info.operationType === 'all' ||\n      args.parsedResult.operationType === this.info.operationType\n\n    const hasMatchingOperationName =\n      this.info.operationName instanceof RegExp\n        ? this.info.operationName.test(args.parsedResult.operationName || '')\n        : args.parsedResult.operationName === this.info.operationName\n\n    return (\n      args.parsedResult.match.matches &&\n      hasMatchingOperationType &&\n      hasMatchingOperationName\n    )\n  }\n\n  protected extendResolverArgs(args: {\n    request: Request\n    parsedResult: GraphQLRequestParsedResult\n  }) {\n    return {\n      query: args.parsedResult.query || '',\n      operationName: args.parsedResult.operationName || '',\n      variables: args.parsedResult.variables || {},\n      cookies: args.parsedResult.cookies,\n    }\n  }\n\n  async log(args: {\n    request: Request\n    response: Response\n    parsedResult: GraphQLRequestParsedResult\n  }) {\n    const loggedRequest = await serializeRequest(args.request)\n    const loggedResponse = await serializeResponse(args.response)\n    const statusColor = getStatusCodeColor(loggedResponse.status)\n    const requestInfo = args.parsedResult.operationName\n      ? `${args.parsedResult.operationType} ${args.parsedResult.operationName}`\n      : `anonymous ${args.parsedResult.operationType}`\n\n    console.groupCollapsed(\n      devUtils.formatMessage(\n        `${getTimestamp()} ${requestInfo} (%c${loggedResponse.status} ${\n          loggedResponse.statusText\n        }%c)`,\n      ),\n      `color:${statusColor}`,\n      'color:inherit',\n    )\n    console.log('Request:', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response:', loggedResponse)\n    console.groupEnd()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}