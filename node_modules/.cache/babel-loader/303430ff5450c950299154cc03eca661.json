{"ast":null,"code":"import { parse } from \"graphql\";\nimport { toPublicUrl } from '../request/toPublicUrl.mjs';\nimport { devUtils } from './devUtils.mjs';\nimport { jsonParse } from './jsonParse.mjs';\nimport { parseMultipartData } from './parseMultipartData.mjs';\n\nfunction parseDocumentNode(node) {\n  const operationDef = node.definitions.find(definition => {\n    return definition.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef?.operation,\n    operationName: operationDef?.name?.value\n  };\n}\n\nfunction parseQuery(query) {\n  try {\n    const ast = parse(query);\n    return parseDocumentNode(ast);\n  } catch (error) {\n    return error;\n  }\n}\n\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = {\n    variables\n  };\n\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`);\n    }\n\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`);\n        }\n\n        target = target[path];\n      }\n\n      target[lastPath] = files[key];\n    }\n  }\n\n  return operations.variables;\n}\n\nasync function getGraphQLInput(request) {\n  switch (request.method) {\n    case \"GET\":\n      {\n        const url = new URL(request.url);\n        const query = url.searchParams.get(\"query\");\n        const variables = url.searchParams.get(\"variables\") || \"\";\n        return {\n          query,\n          variables: jsonParse(variables)\n        };\n      }\n\n    case \"POST\":\n      {\n        const requestClone = request.clone();\n\n        if (request.headers.get(\"content-type\")?.includes(\"multipart/form-data\")) {\n          const responseJson = parseMultipartData(await requestClone.text(), request.headers);\n\n          if (!responseJson) {\n            return null;\n          }\n\n          const {\n            operations,\n            map,\n            ...files\n          } = responseJson;\n          const parsedOperations = jsonParse(operations) || {};\n\n          if (!parsedOperations.query) {\n            return null;\n          }\n\n          const parsedMap = jsonParse(map || \"\") || {};\n          const variables = parsedOperations.variables ? extractMultipartVariables(parsedOperations.variables, parsedMap, files) : {};\n          return {\n            query: parsedOperations.query,\n            variables\n          };\n        }\n\n        const requestJson = await requestClone.json().catch(() => null);\n\n        if (requestJson?.query) {\n          const {\n            query,\n            variables\n          } = requestJson;\n          return {\n            query,\n            variables\n          };\n        }\n      }\n\n    default:\n      return null;\n  }\n}\n\nasync function parseGraphQLRequest(request) {\n  const input = await getGraphQLInput(request);\n\n  if (!input || !input.query) {\n    return;\n  }\n\n  const {\n    query,\n    variables\n  } = input;\n  const parsedResult = parseQuery(query);\n\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = toPublicUrl(request.url);\n    throw new Error(devUtils.formatMessage('Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s', request.method, requestPublicUrl, parsedResult.message));\n  }\n\n  return {\n    query: input.query,\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n}\n\nexport { parseDocumentNode, parseGraphQLRequest };","map":{"version":3,"mappings":"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","names":["parse","toPublicUrl","devUtils","jsonParse","parseMultipartData","parseDocumentNode","node","operationDef","definitions","find","definition","kind","operationType","operation","operationName","name","value","parseQuery","query","ast","error","extractMultipartVariables","variables","map","files","operations","key","pathArray","Object","entries","Error","dotPath","lastPath","reversedPaths","split","reverse","paths","target","path","getGraphQLInput","request","method","url","URL","searchParams","get","requestClone","clone","headers","includes","responseJson","text","parsedOperations","parsedMap","requestJson","json","catch","parseGraphQLRequest","input","parsedResult","requestPublicUrl","formatMessage","message"],"sources":["/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/core/utils/internal/parseGraphQLRequest.ts"],"sourcesContent":["import type {\n  DocumentNode,\n  OperationDefinitionNode,\n  OperationTypeNode,\n} from 'graphql'\nimport { parse } from 'graphql'\nimport type { GraphQLVariables } from '../../handlers/GraphQLHandler'\nimport { toPublicUrl } from '../request/toPublicUrl'\nimport { devUtils } from './devUtils'\nimport { jsonParse } from './jsonParse'\nimport { parseMultipartData } from './parseMultipartData'\n\ninterface GraphQLInput {\n  query: string | null\n  variables?: GraphQLVariables\n}\n\nexport interface ParsedGraphQLQuery {\n  operationType: OperationTypeNode\n  operationName?: string\n}\n\nexport type ParsedGraphQLRequest<\n  VariablesType extends GraphQLVariables = GraphQLVariables,\n> =\n  | (ParsedGraphQLQuery & {\n      query: string\n      variables?: VariablesType\n    })\n  | undefined\n\nexport function parseDocumentNode(node: DocumentNode): ParsedGraphQLQuery {\n  const operationDef = node.definitions.find((definition) => {\n    return definition.kind === 'OperationDefinition'\n  }) as OperationDefinitionNode\n\n  return {\n    operationType: operationDef?.operation,\n    operationName: operationDef?.name?.value,\n  }\n}\n\nfunction parseQuery(query: string): ParsedGraphQLQuery | Error {\n  try {\n    const ast = parse(query)\n    return parseDocumentNode(ast)\n  } catch (error) {\n    return error as Error\n  }\n}\n\nexport type GraphQLParsedOperationsMap = Record<string, string[]>\nexport type GraphQLMultipartRequestBody = {\n  operations: string\n  map?: string\n} & {\n  [fileName: string]: File\n}\n\nfunction extractMultipartVariables<VariablesType extends GraphQLVariables>(\n  variables: VariablesType,\n  map: GraphQLParsedOperationsMap,\n  files: Record<string, File>,\n) {\n  const operations = { variables }\n\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`)\n    }\n\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split('.').reverse()\n      const paths = reversedPaths.reverse()\n      let target: Record<string, any> = operations\n\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`)\n        }\n\n        target = target[path]\n      }\n\n      target[lastPath] = files[key]\n    }\n  }\n\n  return operations.variables\n}\n\nasync function getGraphQLInput(request: Request): Promise<GraphQLInput | null> {\n  switch (request.method) {\n    case 'GET': {\n      const url = new URL(request.url)\n      const query = url.searchParams.get('query')\n      const variables = url.searchParams.get('variables') || ''\n\n      return {\n        query,\n        variables: jsonParse(variables),\n      }\n    }\n\n    case 'POST': {\n      // Clone the request so we could read its body without locking\n      // the body stream to the downward consumers.\n      const requestClone = request.clone()\n\n      // Handle multipart body GraphQL operations.\n      if (\n        request.headers.get('content-type')?.includes('multipart/form-data')\n      ) {\n        const responseJson = parseMultipartData<GraphQLMultipartRequestBody>(\n          await requestClone.text(),\n          request.headers,\n        )\n\n        if (!responseJson) {\n          return null\n        }\n\n        const { operations, map, ...files } = responseJson\n        const parsedOperations =\n          jsonParse<{ query?: string; variables?: GraphQLVariables }>(\n            operations,\n          ) || {}\n\n        if (!parsedOperations.query) {\n          return null\n        }\n\n        const parsedMap = jsonParse<GraphQLParsedOperationsMap>(map || '') || {}\n        const variables = parsedOperations.variables\n          ? extractMultipartVariables(\n              parsedOperations.variables,\n              parsedMap,\n              files,\n            )\n          : {}\n\n        return {\n          query: parsedOperations.query,\n          variables,\n        }\n      }\n\n      // Handle plain POST GraphQL operations.\n      const requestJson: {\n        query: string\n        variables?: GraphQLVariables\n        operations?: any /** @todo Annotate this */\n      } = await requestClone.json().catch(() => null)\n\n      if (requestJson?.query) {\n        const { query, variables } = requestJson\n\n        return {\n          query,\n          variables,\n        }\n      }\n    }\n\n    default:\n      return null\n  }\n}\n\n/**\n * Determines if a given request can be considered a GraphQL request.\n * Does not parse the query and does not guarantee its validity.\n */\nexport async function parseGraphQLRequest(\n  request: Request,\n): Promise<ParsedGraphQLRequest> {\n  const input = await getGraphQLInput(request)\n\n  if (!input || !input.query) {\n    return\n  }\n\n  const { query, variables } = input\n  const parsedResult = parseQuery(query)\n\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = toPublicUrl(request.url)\n\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message,\n      ),\n    )\n  }\n\n  return {\n    query: input.query,\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}