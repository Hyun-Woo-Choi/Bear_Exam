{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n    exports: {}\n  }).exports, mod), mod.exports;\n};\n\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n\n  return to;\n};\n\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps( // If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod)); // node_modules/set-cookie-parser/lib/set-cookie.js\n\n\nvar require_set_cookie = __commonJS({\n  \"node_modules/set-cookie-parser/lib/set-cookie.js\"(exports, module) {\n    \"use strict\";\n\n    var defaultParseOptions = {\n      decodeValues: true,\n      map: false,\n      silent: false\n    };\n\n    function isNonEmptyString(str) {\n      return typeof str === \"string\" && !!str.trim();\n    }\n\n    function parseString(setCookieValue, options) {\n      var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n      var nameValuePairStr = parts.shift();\n      var parsed = parseNameValuePair(nameValuePairStr);\n      var name = parsed.name;\n      var value = parsed.value;\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n\n      try {\n        value = options.decodeValues ? decodeURIComponent(value) : value;\n      } catch (e) {\n        console.error(\"set-cookie-parser encountered an error while decoding a cookie with value '\" + value + \"'. Set options.decodeValues to false to disable this feature.\", e);\n      }\n\n      var cookie = {\n        name,\n        value\n      };\n      parts.forEach(function (part) {\n        var sides = part.split(\"=\");\n        var key = sides.shift().trimLeft().toLowerCase();\n        var value2 = sides.join(\"=\");\n\n        if (key === \"expires\") {\n          cookie.expires = new Date(value2);\n        } else if (key === \"max-age\") {\n          cookie.maxAge = parseInt(value2, 10);\n        } else if (key === \"secure\") {\n          cookie.secure = true;\n        } else if (key === \"httponly\") {\n          cookie.httpOnly = true;\n        } else if (key === \"samesite\") {\n          cookie.sameSite = value2;\n        } else {\n          cookie[key] = value2;\n        }\n      });\n      return cookie;\n    }\n\n    function parseNameValuePair(nameValuePairStr) {\n      var name = \"\";\n      var value = \"\";\n      var nameValueArr = nameValuePairStr.split(\"=\");\n\n      if (nameValueArr.length > 1) {\n        name = nameValueArr.shift();\n        value = nameValueArr.join(\"=\");\n      } else {\n        value = nameValuePairStr;\n      }\n\n      return {\n        name,\n        value\n      };\n    }\n\n    function parse(input, options) {\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n\n      if (!input) {\n        if (!options.map) {\n          return [];\n        } else {\n          return {};\n        }\n      }\n\n      if (input.headers) {\n        if (typeof input.headers.getSetCookie === \"function\") {\n          input = input.headers.getSetCookie();\n        } else if (input.headers[\"set-cookie\"]) {\n          input = input.headers[\"set-cookie\"];\n        } else {\n          var sch = input.headers[Object.keys(input.headers).find(function (key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })];\n\n          if (!sch && input.headers.cookie && !options.silent) {\n            console.warn(\"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\");\n          }\n\n          input = sch;\n        }\n      }\n\n      if (!Array.isArray(input)) {\n        input = [input];\n      }\n\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n\n      if (!options.map) {\n        return input.filter(isNonEmptyString).map(function (str) {\n          return parseString(str, options);\n        });\n      } else {\n        var cookies = {};\n        return input.filter(isNonEmptyString).reduce(function (cookies2, str) {\n          var cookie = parseString(str, options);\n          cookies2[cookie.name] = cookie;\n          return cookies2;\n        }, cookies);\n      }\n    }\n\n    function splitCookiesString2(cookiesString) {\n      if (Array.isArray(cookiesString)) {\n        return cookiesString;\n      }\n\n      if (typeof cookiesString !== \"string\") {\n        return [];\n      }\n\n      var cookiesStrings = [];\n      var pos = 0;\n      var start;\n      var ch;\n      var lastComma;\n      var nextStart;\n      var cookiesSeparatorFound;\n\n      function skipWhitespace() {\n        while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n          pos += 1;\n        }\n\n        return pos < cookiesString.length;\n      }\n\n      function notSpecialChar() {\n        ch = cookiesString.charAt(pos);\n        return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n      }\n\n      while (pos < cookiesString.length) {\n        start = pos;\n        cookiesSeparatorFound = false;\n\n        while (skipWhitespace()) {\n          ch = cookiesString.charAt(pos);\n\n          if (ch === \",\") {\n            lastComma = pos;\n            pos += 1;\n            skipWhitespace();\n            nextStart = pos;\n\n            while (pos < cookiesString.length && notSpecialChar()) {\n              pos += 1;\n            }\n\n            if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n              cookiesSeparatorFound = true;\n              pos = nextStart;\n              cookiesStrings.push(cookiesString.substring(start, lastComma));\n              start = pos;\n            } else {\n              pos = lastComma + 1;\n            }\n          } else {\n            pos += 1;\n          }\n        }\n\n        if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n        }\n      }\n\n      return cookiesStrings;\n    }\n\n    module.exports = parse;\n    module.exports.parse = parse;\n    module.exports.parseString = parseString;\n    module.exports.splitCookiesString = splitCookiesString2;\n  }\n\n}); // src/Headers.ts\n\n\nvar import_set_cookie_parser = __toESM(require_set_cookie()); // src/utils/normalizeHeaderName.ts\n\n\nvar HEADERS_INVALID_CHARACTERS = /[^a-z0-9\\-#$%&'*+.^_`|~]/i;\n\nfunction normalizeHeaderName(name) {\n  if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === \"\") {\n    throw new TypeError(\"Invalid character in header field name\");\n  }\n\n  return name.trim().toLowerCase();\n} // src/utils/normalizeHeaderValue.ts\n\n\nvar charCodesToRemove = [String.fromCharCode(10), String.fromCharCode(13), String.fromCharCode(9), String.fromCharCode(32)];\nvar HEADER_VALUE_REMOVE_REGEXP = new RegExp(`(^[${charCodesToRemove.join(\"\")}]|$[${charCodesToRemove.join(\"\")}])`, \"g\");\n\nfunction normalizeHeaderValue(value) {\n  const nextValue = value.replace(HEADER_VALUE_REMOVE_REGEXP, \"\");\n  return nextValue;\n} // src/utils/isValidHeaderName.ts\n\n\nfunction isValidHeaderName(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n\n  if (value.length === 0) {\n    return false;\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    const character = value.charCodeAt(i);\n\n    if (character > 127 || !isToken(character)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isToken(value) {\n  return ![127, 32, \"(\", \")\", \"<\", \">\", \"@\", \",\", \";\", \":\", \"\\\\\", '\"', \"/\", \"[\", \"]\", \"?\", \"=\", \"{\", \"}\"].includes(value);\n} // src/utils/isValidHeaderValue.ts\n\n\nfunction isValidHeaderValue(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n\n  if (value.trim() !== value) {\n    return false;\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    const character = value.charCodeAt(i);\n\n    if ( // NUL.\n    character === 0 || // HTTP newline bytes.\n    character === 10 || character === 13) {\n      return false;\n    }\n  }\n\n  return true;\n} // src/Headers.ts\n\n\nvar NORMALIZED_HEADERS = Symbol(\"normalizedHeaders\");\nvar RAW_HEADER_NAMES = Symbol(\"rawHeaderNames\");\nvar HEADER_VALUE_DELIMITER = \", \";\n\nvar _a, _b, _c;\n\nvar Headers = class _Headers {\n  constructor(init) {\n    // Normalized header {\"name\":\"a, b\"} storage.\n    this[_a] = {}; // Keeps the mapping between the raw header name\n    // and the normalized header name to ease the lookup.\n\n    this[_b] = /* @__PURE__ */new Map();\n    this[_c] = \"Headers\";\n\n    if ([\"Headers\", \"HeadersPolyfill\"].includes(init?.constructor.name) || init instanceof _Headers || typeof globalThis.Headers !== \"undefined\" && init instanceof globalThis.Headers) {\n      const initialHeaders = init;\n      initialHeaders.forEach((value, name) => {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(init)) {\n      init.forEach(_ref => {\n        let [name, value] = _ref;\n        this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);\n      });\n    } else if (init) {\n      Object.getOwnPropertyNames(init).forEach(name => {\n        const value = init[name];\n        this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);\n      });\n    }\n  }\n\n  [(_a = NORMALIZED_HEADERS, _b = RAW_HEADER_NAMES, _c = Symbol.toStringTag, Symbol.iterator)]() {\n    return this.entries();\n  }\n\n  *keys() {\n    for (const [name] of this.entries()) {\n      yield name;\n    }\n  }\n\n  *values() {\n    for (const [, value] of this.entries()) {\n      yield value;\n    }\n  }\n\n  *entries() {\n    let sortedKeys = Object.keys(this[NORMALIZED_HEADERS]).sort((a, b) => a.localeCompare(b));\n\n    for (const name of sortedKeys) {\n      if (name === \"set-cookie\") {\n        for (const value of this.getSetCookie()) {\n          yield [name, value];\n        }\n      } else {\n        yield [name, this.get(name)];\n      }\n    }\n  }\n  /**\n   * Returns a boolean stating whether a `Headers` object contains a certain header.\n   */\n\n\n  has(name) {\n    if (!isValidHeaderName(name)) {\n      throw new TypeError(`Invalid header name \"${name}\"`);\n    }\n\n    return this[NORMALIZED_HEADERS].hasOwnProperty(normalizeHeaderName(name));\n  }\n  /**\n   * Returns a `ByteString` sequence of all the values of a header with a given name.\n   */\n\n\n  get(name) {\n    if (!isValidHeaderName(name)) {\n      throw TypeError(`Invalid header name \"${name}\"`);\n    }\n\n    return this[NORMALIZED_HEADERS][normalizeHeaderName(name)] ?? null;\n  }\n  /**\n   * Sets a new value for an existing header inside a `Headers` object, or adds the header if it does not already exist.\n   */\n\n\n  set(name, value) {\n    if (!isValidHeaderName(name) || !isValidHeaderValue(value)) {\n      return;\n    }\n\n    const normalizedName = normalizeHeaderName(name);\n    const normalizedValue = normalizeHeaderValue(value);\n    this[NORMALIZED_HEADERS][normalizedName] = normalizeHeaderValue(normalizedValue);\n    this[RAW_HEADER_NAMES].set(normalizedName, name);\n  }\n  /**\n   * Appends a new value onto an existing header inside a `Headers` object, or adds the header if it does not already exist.\n   */\n\n\n  append(name, value) {\n    if (!isValidHeaderName(name) || !isValidHeaderValue(value)) {\n      return;\n    }\n\n    const normalizedName = normalizeHeaderName(name);\n    const normalizedValue = normalizeHeaderValue(value);\n    let resolvedValue = this.has(normalizedName) ? `${this.get(normalizedName)}, ${normalizedValue}` : normalizedValue;\n    this.set(name, resolvedValue);\n  }\n  /**\n   * Deletes a header from the `Headers` object.\n   */\n\n\n  delete(name) {\n    if (!isValidHeaderName(name)) {\n      return;\n    }\n\n    if (!this.has(name)) {\n      return;\n    }\n\n    const normalizedName = normalizeHeaderName(name);\n    delete this[NORMALIZED_HEADERS][normalizedName];\n    this[RAW_HEADER_NAMES].delete(normalizedName);\n  }\n  /**\n   * Traverses the `Headers` object,\n   * calling the given callback for each header.\n   */\n\n\n  forEach(callback, thisArg) {\n    for (const [name, value] of this.entries()) {\n      callback.call(thisArg, value, name, this);\n    }\n  }\n  /**\n   * Returns an array containing the values\n   * of all Set-Cookie headers associated\n   * with a response\n   */\n\n\n  getSetCookie() {\n    const setCookieHeader = this.get(\"set-cookie\");\n\n    if (setCookieHeader === null) {\n      return [];\n    }\n\n    if (setCookieHeader === \"\") {\n      return [\"\"];\n    }\n\n    return (0, import_set_cookie_parser.splitCookiesString)(setCookieHeader);\n  }\n\n}; // src/getRawHeaders.ts\n\nfunction getRawHeaders(headers) {\n  const rawHeaders = {};\n\n  for (const [name, value] of headers.entries()) {\n    rawHeaders[headers[RAW_HEADER_NAMES].get(name)] = value;\n  }\n\n  return rawHeaders;\n} // src/transformers/headersToList.ts\n\n\nfunction headersToList(headers) {\n  const headersList = [];\n  headers.forEach((value, name) => {\n    const resolvedValue = value.includes(\",\") ? value.split(\",\").map(value2 => value2.trim()) : value;\n    headersList.push([name, resolvedValue]);\n  });\n  return headersList;\n} // src/transformers/headersToString.ts\n\n\nfunction headersToString(headers) {\n  const list = headersToList(headers);\n  const lines = list.map(_ref2 => {\n    let [name, value] = _ref2;\n    const values = [].concat(value);\n    return `${name}: ${values.join(\", \")}`;\n  });\n  return lines.join(\"\\r\\n\");\n} // src/transformers/headersToObject.ts\n\n\nvar singleValueHeaders = [\"user-agent\"];\n\nfunction headersToObject(headers) {\n  const headersObject = {};\n  headers.forEach((value, name) => {\n    const isMultiValue = !singleValueHeaders.includes(name.toLowerCase()) && value.includes(\",\");\n    headersObject[name] = isMultiValue ? value.split(\",\").map(s => s.trim()) : value;\n  });\n  return headersObject;\n} // src/transformers/stringToHeaders.ts\n\n\nfunction stringToHeaders(str) {\n  const lines = str.trim().split(/[\\r\\n]+/);\n  return lines.reduce((headers, line) => {\n    if (line.trim() === \"\") {\n      return headers;\n    }\n\n    const parts = line.split(\": \");\n    const name = parts.shift();\n    const value = parts.join(\": \");\n    headers.append(name, value);\n    return headers;\n  }, new Headers());\n} // src/transformers/listToHeaders.ts\n\n\nfunction listToHeaders(list) {\n  const headers = new Headers();\n  list.forEach(_ref3 => {\n    let [name, value] = _ref3;\n    const values = [].concat(value);\n    values.forEach(value2 => {\n      headers.append(name, value2);\n    });\n  });\n  return headers;\n} // src/transformers/reduceHeadersObject.ts\n\n\nfunction reduceHeadersObject(headers, reducer, initialState) {\n  return Object.keys(headers).reduce((nextHeaders, name) => {\n    return reducer(nextHeaders, name, headers[name]);\n  }, initialState);\n} // src/transformers/objectToHeaders.ts\n\n\nfunction objectToHeaders(headersObject) {\n  return reduceHeadersObject(headersObject, (headers, name, value) => {\n    const values = [].concat(value).filter(Boolean);\n    values.forEach(value2 => {\n      headers.append(name, value2);\n    });\n    return headers;\n  }, new Headers());\n} // src/transformers/flattenHeadersList.ts\n\n\nfunction flattenHeadersList(list) {\n  return list.map(_ref4 => {\n    let [name, values] = _ref4;\n    return [name, [].concat(values).join(\", \")];\n  });\n} // src/transformers/flattenHeadersObject.ts\n\n\nfunction flattenHeadersObject(headersObject) {\n  return reduceHeadersObject(headersObject, (headers, name, value) => {\n    headers[name] = [].concat(value).join(\", \");\n    return headers;\n  }, {});\n}\n\nexport { Headers, flattenHeadersList, flattenHeadersObject, getRawHeaders, headersToList, headersToObject, headersToString, listToHeaders, objectToHeaders, reduceHeadersObject, stringToHeaders };","map":{"version":3,"mappings":"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","names":["defaultParseOptions","decodeValues","map","silent","isNonEmptyString","str","trim","parseString","setCookieValue","options","parts","split","filter","nameValuePairStr","shift","parsed","parseNameValuePair","name","value","Object","assign","decodeURIComponent","e","console","error","cookie","forEach","part","sides","key","trimLeft","toLowerCase","join","expires","Date","maxAge","parseInt","secure","httpOnly","sameSite","nameValueArr","length","parse","input","headers","getSetCookie","sch","keys","find","warn","Array","isArray","cookies","reduce","splitCookiesString","cookiesString","cookiesStrings","pos","start","ch","lastComma","nextStart","cookiesSeparatorFound","skipWhitespace","test","charAt","notSpecialChar","push","substring","module","exports","__toESM","HEADERS_INVALID_CHARACTERS","normalizeHeaderName","TypeError","charCodesToRemove","String","fromCharCode","HEADER_VALUE_REMOVE_REGEXP","RegExp","normalizeHeaderValue","nextValue","replace","isValidHeaderName","i","character","charCodeAt","isToken","includes","isValidHeaderValue","NORMALIZED_HEADERS","Symbol","RAW_HEADER_NAMES","HEADER_VALUE_DELIMITER","Headers","_Headers","constructor","init","_a","_b","Map","_c","globalThis","initialHeaders","append","getOwnPropertyNames","toStringTag","iterator","entries","sortedKeys","sort","a","b","localeCompare","get","has","hasOwnProperty","set","normalizedName","normalizedValue","resolvedValue","delete","callback","thisArg","call","setCookieHeader","import_set_cookie_parser","getRawHeaders","rawHeaders","headersToList","headersList","headersToString","list","lines","values","concat","singleValueHeaders","headersToObject","headersObject","isMultiValue","s","stringToHeaders","line","listToHeaders","reduceHeadersObject","reducer","initialState","nextHeaders","objectToHeaders","Boolean","flattenHeadersList","flattenHeadersObject"],"sources":["/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/node_modules/set-cookie-parser/lib/set-cookie.js","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/Headers.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/utils/normalizeHeaderName.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/utils/normalizeHeaderValue.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/utils/isValidHeaderName.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/utils/isValidHeaderValue.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/getRawHeaders.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/transformers/headersToList.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/transformers/headersToString.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/transformers/headersToObject.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/transformers/stringToHeaders.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/transformers/listToHeaders.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/transformers/reduceHeadersObject.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/transformers/objectToHeaders.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/transformers/flattenHeadersList.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/headers-polyfill/src/transformers/flattenHeadersObject.ts"],"sourcesContent":["\"use strict\";\n\nvar defaultParseOptions = {\n  decodeValues: true,\n  map: false,\n  silent: false,\n};\n\nfunction isNonEmptyString(str) {\n  return typeof str === \"string\" && !!str.trim();\n}\n\nfunction parseString(setCookieValue, options) {\n  var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n\n  var nameValuePairStr = parts.shift();\n  var parsed = parseNameValuePair(nameValuePairStr);\n  var name = parsed.name;\n  var value = parsed.value;\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  try {\n    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value\n  } catch (e) {\n    console.error(\n      \"set-cookie-parser encountered an error while decoding a cookie with value '\" +\n        value +\n        \"'. Set options.decodeValues to false to disable this feature.\",\n      e\n    );\n  }\n\n  var cookie = {\n    name: name,\n    value: value,\n  };\n\n  parts.forEach(function (part) {\n    var sides = part.split(\"=\");\n    var key = sides.shift().trimLeft().toLowerCase();\n    var value = sides.join(\"=\");\n    if (key === \"expires\") {\n      cookie.expires = new Date(value);\n    } else if (key === \"max-age\") {\n      cookie.maxAge = parseInt(value, 10);\n    } else if (key === \"secure\") {\n      cookie.secure = true;\n    } else if (key === \"httponly\") {\n      cookie.httpOnly = true;\n    } else if (key === \"samesite\") {\n      cookie.sameSite = value;\n    } else {\n      cookie[key] = value;\n    }\n  });\n\n  return cookie;\n}\n\nfunction parseNameValuePair(nameValuePairStr) {\n  // Parses name-value-pair according to rfc6265bis draft\n\n  var name = \"\";\n  var value = \"\";\n  var nameValueArr = nameValuePairStr.split(\"=\");\n  if (nameValueArr.length > 1) {\n    name = nameValueArr.shift();\n    value = nameValueArr.join(\"=\"); // everything after the first =, joined by a \"=\" if there was more than one part\n  } else {\n    value = nameValuePairStr;\n  }\n\n  return { name: name, value: value };\n}\n\nfunction parse(input, options) {\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!input) {\n    if (!options.map) {\n      return [];\n    } else {\n      return {};\n    }\n  }\n\n  if (input.headers) {\n    if (typeof input.headers.getSetCookie === \"function\") {\n      // for fetch responses - they combine headers of the same type in the headers array,\n      // but getSetCookie returns an uncombined array\n      input = input.headers.getSetCookie();\n    } else if (input.headers[\"set-cookie\"]) {\n      // fast-path for node.js (which automatically normalizes header names to lower-case\n      input = input.headers[\"set-cookie\"];\n    } else {\n      // slow-path for other environments - see #25\n      var sch =\n        input.headers[\n          Object.keys(input.headers).find(function (key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })\n        ];\n      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36\n      if (!sch && input.headers.cookie && !options.silent) {\n        console.warn(\n          \"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\"\n        );\n      }\n      input = sch;\n    }\n  }\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!options.map) {\n    return input.filter(isNonEmptyString).map(function (str) {\n      return parseString(str, options);\n    });\n  } else {\n    var cookies = {};\n    return input.filter(isNonEmptyString).reduce(function (cookies, str) {\n      var cookie = parseString(str, options);\n      cookies[cookie.name] = cookie;\n      return cookies;\n    }, cookies);\n  }\n}\n\n/*\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\n  that are within a single set-cookie field-value, such as in the Expires portion.\n\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\n  React Native's fetch does this for *every* header, including set-cookie.\n\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\n*/\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString;\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        // ',' is a cookie separator if we have later first '=', not ';' or ','\n        lastComma = pos;\n        pos += 1;\n\n        skipWhitespace();\n        nextStart = pos;\n\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n\n        // currently special character\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          // we found cookies separator\n          cookiesSeparatorFound = true;\n          // pos is inside the next cookie, so back up and return it.\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          // in param ',' or param separator ';',\n          // we continue from that comma\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n\n  return cookiesStrings;\n}\n\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.parseString = parseString;\nmodule.exports.splitCookiesString = splitCookiesString;\n","import { splitCookiesString } from 'set-cookie-parser'\nimport { HeadersList, HeadersObject } from './glossary'\nimport { normalizeHeaderName } from './utils/normalizeHeaderName'\nimport { normalizeHeaderValue } from './utils/normalizeHeaderValue'\nimport { isValidHeaderName } from './utils/isValidHeaderName'\nimport { isValidHeaderValue } from './utils/isValidHeaderValue'\n\nexport const NORMALIZED_HEADERS: unique symbol = Symbol('normalizedHeaders')\n\nexport const RAW_HEADER_NAMES: unique symbol = Symbol('rawHeaderNames')\n\nconst HEADER_VALUE_DELIMITER = ', ' as const\n\nexport class Headers {\n  // Normalized header {\"name\":\"a, b\"} storage.\n  private [NORMALIZED_HEADERS]: Record<string, string> = {}\n\n  // Keeps the mapping between the raw header name\n  // and the normalized header name to ease the lookup.\n  private [RAW_HEADER_NAMES]: Map<string, string> = new Map()\n\n  constructor(init?: HeadersInit | HeadersObject | HeadersList) {\n    /**\n     * @note Cannot necessarily check if the `init` is an instance of the\n     * `Headers` because that class may not be defined in Node or jsdom.\n     */\n    if (\n      ['Headers', 'HeadersPolyfill'].includes(init?.constructor.name) ||\n      init instanceof Headers ||\n      (typeof globalThis.Headers !== 'undefined' &&\n        init instanceof globalThis.Headers)\n    ) {\n      const initialHeaders = init as Headers\n      initialHeaders.forEach((value, name) => {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(init)) {\n      init.forEach(([name, value]) => {\n        this.append(\n          name,\n          Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value\n        )\n      })\n    } else if (init) {\n      Object.getOwnPropertyNames(init).forEach((name) => {\n        const value = init[name]\n        this.append(\n          name,\n          Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value\n        )\n      })\n    }\n  }\n\n  [Symbol.toStringTag] = 'Headers';\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  *keys(): IterableIterator<string> {\n    for (const [name] of this.entries()) {\n      yield name\n    }\n  }\n\n  *values(): IterableIterator<string> {\n    for (const [, value] of this.entries()) {\n      yield value\n    }\n  }\n\n  *entries(): IterableIterator<[string, string]> {\n    // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n    let sortedKeys = Object.keys(this[NORMALIZED_HEADERS]).sort((a, b) =>\n      a.localeCompare(b)\n    )\n    for (const name of sortedKeys) {\n      if (name === 'set-cookie') {\n        for (const value of this.getSetCookie()) {\n          yield [name, value]\n        }\n      } else {\n        yield [name, this.get(name)]\n      }\n    }\n  }\n\n  /**\n   * Returns a boolean stating whether a `Headers` object contains a certain header.\n   */\n  has(name: string): boolean {\n    if (!isValidHeaderName(name)) {\n      throw new TypeError(`Invalid header name \"${name}\"`)\n    }\n\n    return this[NORMALIZED_HEADERS].hasOwnProperty(normalizeHeaderName(name))\n  }\n\n  /**\n   * Returns a `ByteString` sequence of all the values of a header with a given name.\n   */\n  get(name: string): string | null {\n    if (!isValidHeaderName(name)) {\n      throw TypeError(`Invalid header name \"${name}\"`)\n    }\n\n    return this[NORMALIZED_HEADERS][normalizeHeaderName(name)] ?? null\n  }\n\n  /**\n   * Sets a new value for an existing header inside a `Headers` object, or adds the header if it does not already exist.\n   */\n  set(name: string, value: string): void {\n    if (!isValidHeaderName(name) || !isValidHeaderValue(value)) {\n      return\n    }\n\n    const normalizedName = normalizeHeaderName(name)\n    const normalizedValue = normalizeHeaderValue(value)\n\n    this[NORMALIZED_HEADERS][normalizedName] =\n      normalizeHeaderValue(normalizedValue)\n    this[RAW_HEADER_NAMES].set(normalizedName, name)\n  }\n\n  /**\n   * Appends a new value onto an existing header inside a `Headers` object, or adds the header if it does not already exist.\n   */\n  append(name: string, value: string): void {\n    if (!isValidHeaderName(name) || !isValidHeaderValue(value)) {\n      return\n    }\n\n    const normalizedName = normalizeHeaderName(name)\n    const normalizedValue = normalizeHeaderValue(value)\n\n    let resolvedValue = this.has(normalizedName)\n      ? `${this.get(normalizedName)}, ${normalizedValue}`\n      : normalizedValue\n\n    this.set(name, resolvedValue)\n  }\n\n  /**\n   * Deletes a header from the `Headers` object.\n   */\n  delete(name: string): void {\n    if (!isValidHeaderName(name)) {\n      return\n    }\n\n    if (!this.has(name)) {\n      return\n    }\n\n    const normalizedName = normalizeHeaderName(name)\n    delete this[NORMALIZED_HEADERS][normalizedName]\n    this[RAW_HEADER_NAMES].delete(normalizedName)\n  }\n\n  /**\n   * Traverses the `Headers` object,\n   * calling the given callback for each header.\n   */\n  forEach<ThisArg = this>(\n    callback: (\n      this: ThisArg,\n      value: string,\n      name: string,\n      parent: this\n    ) => void,\n    thisArg?: ThisArg\n  ) {\n    for (const [name, value] of this.entries()) {\n      callback.call(thisArg, value, name, this)\n    }\n  }\n\n  /**\n   * Returns an array containing the values\n   * of all Set-Cookie headers associated\n   * with a response\n   */\n  getSetCookie(): string[] {\n    const setCookieHeader = this.get('set-cookie')\n\n    if (setCookieHeader === null) {\n      return []\n    }\n\n    if (setCookieHeader === '') {\n      return ['']\n    }\n\n    return splitCookiesString(setCookieHeader)\n  }\n}\n","const HEADERS_INVALID_CHARACTERS = /[^a-z0-9\\-#$%&'*+.^_`|~]/i\n\nexport function normalizeHeaderName(name: string): string {\n  if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === '') {\n    throw new TypeError('Invalid character in header field name')\n  }\n\n  return name.trim().toLowerCase()\n}\n","const charCodesToRemove = [\n  String.fromCharCode(0x0a),\n  String.fromCharCode(0x0d),\n  String.fromCharCode(0x09),\n  String.fromCharCode(0x20),\n]\n\nconst HEADER_VALUE_REMOVE_REGEXP = new RegExp(\n  `(^[${charCodesToRemove.join('')}]|$[${charCodesToRemove.join('')}])`,\n  'g'\n)\n\n/**\n * Normalize the given header value.\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n */\nexport function normalizeHeaderValue(value: string): string {\n  const nextValue = value.replace(HEADER_VALUE_REMOVE_REGEXP, '')\n  return nextValue\n}\n","/**\n * Validate the given header name.\n * @see https://fetch.spec.whatwg.org/#header-name\n */\nexport function isValidHeaderName(value: unknown) {\n  if (typeof value !== 'string') {\n    return false\n  }\n\n  if (value.length === 0) {\n    return false\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    const character = value.charCodeAt(i)\n\n    if (character > 0x7f || !isToken(character)) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction isToken(value: string | number): boolean {\n  return ![\n    0x7f,\n    0x20,\n    '(',\n    ')',\n    '<',\n    '>',\n    '@',\n    ',',\n    ';',\n    ':',\n    '\\\\',\n    '\"',\n    '/',\n    '[',\n    ']',\n    '?',\n    '=',\n    '{',\n    '}',\n  ].includes(value)\n}\n","/**\n * Validate the given header value.\n * @see https://fetch.spec.whatwg.org/#header-value\n */\nexport function isValidHeaderValue(value: unknown): boolean {\n  if (typeof value !== 'string') {\n    return false\n  }\n\n  if (value.trim() !== value) {\n    return false\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    const character = value.charCodeAt(i)\n\n    if (\n      // NUL.\n      character === 0x00 ||\n      // HTTP newline bytes.\n      character === 0x0a ||\n      character === 0x0d\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n","import { RAW_HEADER_NAMES } from './Headers'\n\n/**\n * Returns the object of all raw headers.\n */\nexport function getRawHeaders(headers: Headers) {\n  const rawHeaders: Record<string, string> = {}\n\n  for (const [name, value] of headers.entries()) {\n    rawHeaders[headers[RAW_HEADER_NAMES].get(name)] = value\n  }\n\n  return rawHeaders\n}\n","import { HeadersList } from '../glossary'\n\nexport function headersToList(headers: Headers): HeadersList {\n  const headersList: HeadersList = []\n\n  headers.forEach((value, name) => {\n    const resolvedValue = value.includes(',')\n      ? value.split(',').map((value) => value.trim())\n      : value\n\n    headersList.push([name, resolvedValue])\n  })\n\n  return headersList\n}\n","import { headersToList } from './headersToList'\n\n/**\n * Converts a given `Headers` instance to its string representation.\n */\nexport function headersToString(headers: Headers): string {\n  const list = headersToList(headers)\n  const lines = list.map(([name, value]) => {\n    const values = ([] as string[]).concat(value)\n    return `${name}: ${values.join(', ')}`\n  })\n\n  return lines.join('\\r\\n')\n}\n","import { HeadersObject } from '../glossary'\n\n// List of headers that cannot have multiple values,\n// while potentially having a comma in their single value.\nconst singleValueHeaders = ['user-agent']\n\n/**\n * Converts a given `Headers` instance into a plain object.\n * Respects headers with multiple values.\n */\nexport function headersToObject(headers: Headers): HeadersObject {\n  const headersObject: HeadersObject = {}\n\n  headers.forEach((value, name) => {\n    const isMultiValue =\n      !singleValueHeaders.includes(name.toLowerCase()) && value.includes(',')\n    headersObject[name] = isMultiValue\n      ? value.split(',').map((s) => s.trim())\n      : value\n  })\n\n  return headersObject\n}\n","import { Headers } from '../Headers'\n\n/**\n * Converts a string representation of headers (i.e. from XMLHttpRequest)\n * to a new `Headers` instance.\n */\nexport function stringToHeaders(str: string): Headers {\n  const lines = str.trim().split(/[\\r\\n]+/)\n\n  return lines.reduce((headers, line) => {\n    if (line.trim() === '') {\n      return headers\n    }\n\n    const parts = line.split(': ')\n    const name = parts.shift()\n    const value = parts.join(': ')\n    headers.append(name, value)\n\n    return headers\n  }, new Headers())\n}\n","import { Headers } from '../Headers'\nimport { HeadersList } from '../glossary'\n\nexport function listToHeaders(list: HeadersList): Headers {\n  const headers = new Headers()\n\n  list.forEach(([name, value]) => {\n    const values = ([] as string[]).concat(value)\n\n    values.forEach((value) => {\n      headers.append(name, value)\n    })\n  })\n\n  return headers\n}\n","import { HeadersObject } from '../glossary'\n\n/**\n * Reduces given headers object instnace.\n */\nexport function reduceHeadersObject<R>(\n  headers: HeadersObject,\n  reducer: (headers: R, name: string, value: string | string[]) => R,\n  initialState: R\n): R {\n  return Object.keys(headers).reduce<R>((nextHeaders, name) => {\n    return reducer(nextHeaders, name, headers[name])\n  }, initialState)\n}\n","import { Headers } from '../Headers'\nimport { reduceHeadersObject } from './reduceHeadersObject'\n\n/**\n * Converts a given headers object to a new `Headers` instance.\n */\nexport function objectToHeaders(\n  headersObject: Record<string, string | string[] | undefined>\n): Headers {\n  return reduceHeadersObject(\n    headersObject,\n    (headers, name, value) => {\n      const values = ([] as string[]).concat(value).filter(Boolean)\n\n      values.forEach((value) => {\n        headers.append(name, value)\n      })\n\n      return headers\n    },\n    new Headers()\n  )\n}\n","import { HeadersList, FlatHeadersList } from '../glossary'\n\nexport function flattenHeadersList(list: HeadersList): FlatHeadersList {\n  return list.map(([name, values]) => {\n    return [name, ([] as string[]).concat(values).join(', ')]\n  })\n}\n","import { HeadersObject, FlatHeadersObject } from '../glossary'\nimport { reduceHeadersObject } from './reduceHeadersObject'\n\nexport function flattenHeadersObject(\n  headersObject: HeadersObject\n): FlatHeadersObject {\n  return reduceHeadersObject<FlatHeadersObject>(\n    headersObject,\n    (headers, name, value) => {\n      headers[name] = ([] as string[]).concat(value).join(', ')\n      return headers\n    },\n    {}\n  )\n}\n"]},"metadata":{},"sourceType":"module"}