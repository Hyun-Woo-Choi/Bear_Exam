{"ast":null,"code":"import { match } from \"path-to-regexp\";\nimport { getCleanUrl } from \"@mswjs/interceptors\";\nimport { normalizePath } from './normalizePath.mjs';\n\nfunction coercePath(path) {\n  return path.replace(/([:a-zA-Z_-]*)(\\*{1,2})+/g, (_, parameterName, wildcard) => {\n    const expression = \"(.*)\";\n\n    if (!parameterName) {\n      return expression;\n    }\n\n    return parameterName.startsWith(\":\") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n  }).replace(/([^\\/])(:)(?=\\d+)/, \"$1\\\\$2\").replace(/^([^\\/]+)(:)(?=\\/\\/)/, \"$1\\\\$2\");\n}\n\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === \"string\" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl = getCleanUrl(url);\n  const result = match(cleanPath, {\n    decode: decodeURIComponent\n  })(cleanUrl);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n}\n\nexport { coercePath, matchRequestUrl };","map":{"version":3,"mappings":"AAAA,SAASA,KAAT,QAAsB,gBAAtB;AACA,SAASC,WAAT,QAA4B,qBAA5B;AACA,SAASC,aAAT,QAA8B,qBAA9B;;AAgBO,SAASC,UAAT,CAAoBC,IAApB,EAA0C;EAC/C,OACEA,KAMGC,OANH,CAOI,2BAPJ,EAQI,CAACC,CAAD,EAAIC,aAAJ,EAAuCC,QAAvC,KAA4D;IAC1D,MAAMC,aAAa,MAAnB;;IAEA,IAAI,CAACF,aAAL,EAAoB;MAClB,OAAOE,UAAP;IACF;;IAEA,OAAOF,cAAcG,UAAd,CAAyB,GAAzB,IACH,GAAGH,aAAa,GAAGC,QAAQ,EADxB,GAEH,GAAGD,aAAa,GAAGE,UAAU,EAFjC;EAGF,CAlBJ,EAwBGJ,OAxBH,CAwBW,mBAxBX,EAwBgC,QAxBhC,EA8BGA,OA9BH,CA8BW,sBA9BX,EA8BmC,QA9BnC,CADF;AAiCF;;AAKO,SAASM,eAAT,CAAyBC,GAAzB,EAAmCR,IAAnC,EAA+CS,OAA/C,EAAwE;EAC7E,MAAMC,iBAAiBZ,cAAcE,IAAd,EAAoBS,OAApB,CAAvB;EACA,MAAME,YACJ,OAAOD,cAAP,KAA0B,QAA1B,GACIX,WAAWW,cAAX,CADJ,GAEIA,cAHN;EAKA,MAAME,WAAWf,YAAYW,GAAZ,CAAjB;EACA,MAAMK,SAASjB,MAAMe,SAAN,EAAiB;IAAEG,QAAQC;EAAV,CAAjB,EAAiDH,QAAjD,CAAf;EACA,MAAMI,SAAUH,UAAWA,OAAOG,MAAlB,IAA4C,EAA5D;EAEA,OAAO;IACLC,SAASJ,WAAW,KADf;IAELG;EAFK,CAAP;AAIF","names":["match","getCleanUrl","normalizePath","coercePath","path","replace","_","parameterName","wildcard","expression","startsWith","matchRequestUrl","url","baseUrl","normalizedPath","cleanPath","cleanUrl","result","decode","decodeURIComponent","params","matches"],"sources":["/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/core/utils/matching/matchRequestUrl.ts"],"sourcesContent":["import { match } from 'path-to-regexp'\nimport { getCleanUrl } from '@mswjs/interceptors'\nimport { normalizePath } from './normalizePath'\n\nexport type Path = string | RegExp\nexport type PathParams<KeyType extends keyof any = string> = {\n  [ParamName in KeyType]: string | ReadonlyArray<string>\n}\n\nexport interface Match {\n  matches: boolean\n  params?: PathParams\n}\n\n/**\n * Coerce a path supported by MSW into a path\n * supported by \"path-to-regexp\".\n */\nexport function coercePath(path: string): string {\n  return (\n    path\n      /**\n       * Replace wildcards (\"*\") with unnamed capturing groups\n       * because \"path-to-regexp\" doesn't support wildcards.\n       * Ignore path parameter' modifiers (i.e. \":name*\").\n       */\n      .replace(\n        /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n        (_, parameterName: string | undefined, wildcard: string) => {\n          const expression = '(.*)'\n\n          if (!parameterName) {\n            return expression\n          }\n\n          return parameterName.startsWith(':')\n            ? `${parameterName}${wildcard}`\n            : `${parameterName}${expression}`\n        },\n      )\n      /**\n       * Escape the port so that \"path-to-regexp\" can match\n       * absolute URLs including port numbers.\n       */\n      .replace(/([^\\/])(:)(?=\\d+)/, '$1\\\\$2')\n      /**\n       * Escape the protocol so that \"path-to-regexp\" could match\n       * absolute URL.\n       * @see https://github.com/pillarjs/path-to-regexp/issues/259\n       */\n      .replace(/^([^\\/]+)(:)(?=\\/\\/)/, '$1\\\\$2')\n  )\n}\n\n/**\n * Returns the result of matching given request URL against a mask.\n */\nexport function matchRequestUrl(url: URL, path: Path, baseUrl?: string): Match {\n  const normalizedPath = normalizePath(path, baseUrl)\n  const cleanPath =\n    typeof normalizedPath === 'string'\n      ? coercePath(normalizedPath)\n      : normalizedPath\n\n  const cleanUrl = getCleanUrl(url)\n  const result = match(cleanPath, { decode: decodeURIComponent })(cleanUrl)\n  const params = (result && (result.params as PathParams)) || {}\n\n  return {\n    matches: result !== false,\n    params,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}