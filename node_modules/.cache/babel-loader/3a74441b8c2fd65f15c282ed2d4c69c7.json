{"ast":null,"code":"// src/MemoryLeakError.ts\nvar MemoryLeakError = class extends Error {\n  constructor(emitter, type, count) {\n    super(`Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`);\n    this.emitter = emitter;\n    this.type = type;\n    this.count = count;\n    this.name = \"MaxListenersExceededWarning\";\n  }\n\n}; // src/Emitter.ts\n\nvar _Emitter = class {\n  static listenerCount(emitter, eventName) {\n    return emitter.listenerCount(eventName);\n  }\n\n  constructor() {\n    this.events = /* @__PURE__ */new Map();\n    this.maxListeners = _Emitter.defaultMaxListeners;\n    this.hasWarnedAboutPotentialMemoryLeak = false;\n  }\n\n  _emitInternalEvent(internalEventName, eventName, listener) {\n    this.emit(internalEventName, ...[eventName, listener]);\n  }\n\n  _getListeners(eventName) {\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || [];\n  }\n\n  _removeListener(listeners, listener) {\n    const index = listeners.indexOf(listener);\n\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n\n    return [];\n  }\n\n  _wrapOnceListener(eventName, listener) {\n    var _this = this;\n\n    const onceListener = function () {\n      _this.removeListener(eventName, onceListener);\n\n      for (var _len = arguments.length, data = new Array(_len), _key = 0; _key < _len; _key++) {\n        data[_key] = arguments[_key];\n      }\n\n      return listener.apply(_this, data);\n    };\n\n    Object.defineProperty(onceListener, \"name\", {\n      value: listener.name\n    });\n    return onceListener;\n  }\n\n  setMaxListeners(maxListeners) {\n    this.maxListeners = maxListeners;\n    return this;\n  }\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n\n\n  getMaxListeners() {\n    return this.maxListeners;\n  }\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n\n\n  eventNames() {\n    return Array.from(this.events.keys());\n  }\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n\n\n  emit(eventName) {\n    for (var _len2 = arguments.length, data = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      data[_key2 - 1] = arguments[_key2];\n    }\n\n    const listeners = this._getListeners(eventName);\n\n    listeners.forEach(listener => {\n      listener.apply(this, data);\n    });\n    return listeners.length > 0;\n  }\n\n  addListener(eventName, listener) {\n    this._emitInternalEvent(\"newListener\", eventName, listener);\n\n    const nextListeners = this._getListeners(eventName).concat(listener);\n\n    this.events.set(eventName, nextListeners);\n\n    if (this.maxListeners > 0 && this.listenerCount(eventName) > this.maxListeners && !this.hasWarnedAboutPotentialMemoryLeak) {\n      this.hasWarnedAboutPotentialMemoryLeak = true;\n      const memoryLeakWarning = new MemoryLeakError(this, eventName, this.listenerCount(eventName));\n      console.warn(memoryLeakWarning);\n    }\n\n    return this;\n  }\n\n  on(eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n\n  once(eventName, listener) {\n    return this.addListener(eventName, this._wrapOnceListener(eventName, listener));\n  }\n\n  prependListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners);\n      this.events.set(eventName, nextListeners);\n    } else {\n      this.events.set(eventName, listeners.concat(listener));\n    }\n\n    return this;\n  }\n\n  prependOnceListener(eventName, listener) {\n    return this.prependListener(eventName, this._wrapOnceListener(eventName, listener));\n  }\n\n  removeListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener);\n\n      this.events.set(eventName, listeners);\n\n      this._emitInternalEvent(\"removeListener\", eventName, listener);\n    }\n\n    return this;\n  }\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n\n\n  off(eventName, listener) {\n    return this.removeListener(eventName, listener);\n  }\n\n  removeAllListeners(eventName) {\n    if (eventName) {\n      this.events.delete(eventName);\n    } else {\n      this.events.clear();\n    }\n\n    return this;\n  }\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n\n\n  listeners(eventName) {\n    return Array.from(this._getListeners(eventName));\n  }\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n\n\n  listenerCount(eventName) {\n    return this._getListeners(eventName).length;\n  }\n\n  rawListeners(eventName) {\n    return this.listeners(eventName);\n  }\n\n};\n\nvar Emitter = _Emitter;\nEmitter.defaultMaxListeners = 10;\nexport { Emitter, MemoryLeakError };","map":{"version":3,"mappings":"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","names":["MemoryLeakError","Error","constructor","emitter","type","count","toString","name","_Emitter","eventName","listenerCount","events","Map","maxListeners","defaultMaxListeners","hasWarnedAboutPotentialMemoryLeak","_emitInternalEvent","internalEventName","listener","emit","_getListeners","Array","prototype","concat","apply","get","_removeListener","listeners","index","indexOf","splice","_wrapOnceListener","onceListener","removeListener","data","Object","defineProperty","value","setMaxListeners","getMaxListeners","eventNames","from","keys","forEach","length","addListener","nextListeners","set","memoryLeakWarning","console","warn","on","once","prependListener","prependOnceListener","off","removeAllListeners","delete","clear","rawListeners","Emitter"],"sources":["/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/strict-event-emitter/src/MemoryLeakError.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/strict-event-emitter/src/Emitter.ts"],"sourcesContent":["import type { Emitter } from './Emitter'\n\nexport class MemoryLeakError extends Error {\n  constructor(\n    public readonly emitter: Emitter<any>,\n    public readonly type: string | number | symbol,\n    public readonly count: number\n  ) {\n    super(\n      `Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`\n    )\n    this.name = 'MaxListenersExceededWarning'\n  }\n}\n","import { MemoryLeakError } from './MemoryLeakError'\n\nexport type EventMap = {\n  [eventName: string]: Array<unknown>\n}\n\nexport type InternalEventNames = 'newListener' | 'removeListener'\n\nexport type InternalListener<Events extends EventMap> = Listener<\n  [eventName: keyof Events, listener: Listener<Array<unknown>>]\n>\n\nexport type Listener<Data extends Array<unknown>> = (...data: Data) => void\n\n/**\n * Node.js-compatible implementation of `EventEmitter`.\n *\n * @example\n * const emitter = new Emitter<{ hello: [string] }>()\n * emitter.on('hello', (name) => console.log(name))\n * emitter.emit('hello', 'John')\n */\nexport class Emitter<Events extends EventMap> {\n  private events: Map<keyof Events, Array<Listener<any>>>\n  private maxListeners: number\n  private hasWarnedAboutPotentialMemoryLeak: boolean\n\n  static defaultMaxListeners = 10\n\n  static listenerCount<Events extends EventMap>(\n    emitter: Emitter<EventMap>,\n    eventName: keyof Events\n  ): number {\n    return emitter.listenerCount<any>(eventName)\n  }\n\n  constructor() {\n    this.events = new Map()\n    this.maxListeners = Emitter.defaultMaxListeners\n    this.hasWarnedAboutPotentialMemoryLeak = false\n  }\n\n  private _emitInternalEvent(\n    internalEventName: InternalEventNames,\n    eventName: keyof Events,\n    listener: Listener<Array<unknown>>\n  ): void {\n    this.emit(\n      internalEventName,\n      // Anything to make TypeScript happy.\n      ...([eventName, listener] as Events['newListener'] &\n        Events['removeListener'])\n    )\n  }\n\n  private _getListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Array<unknown>>> {\n    // Always return a copy of the listeners array\n    // so they are fixed at the time of the \"_getListeners\" call.\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || []\n  }\n\n  private _removeListener<EventName extends keyof Events>(\n    listeners: Array<Listener<Events[EventName]>>,\n    listener: Listener<Events[EventName]>\n  ): Array<Listener<Events[EventName]>> {\n    const index = listeners.indexOf(listener)\n\n    if (index > -1) {\n      listeners.splice(index, 1)\n    }\n\n    return []\n  }\n\n  private _wrapOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): Listener<Events[EventName]> {\n    const onceListener = (...data: Events[keyof Events]) => {\n      this.removeListener(eventName, onceListener)\n\n      /**\n       * @note Return the result of the original listener.\n       * This way this wrapped preserves listeners that are async.\n       */\n      return listener.apply(this, data)\n    }\n\n    // Inherit the name of the original listener.\n    Object.defineProperty(onceListener, 'name', { value: listener.name })\n\n    return onceListener\n  }\n\n  public setMaxListeners(maxListeners: number): this {\n    this.maxListeners = maxListeners\n    return this\n  }\n\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  public getMaxListeners(): number {\n    return this.maxListeners\n  }\n\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  public eventNames(): Array<keyof Events> {\n    return Array.from(this.events.keys())\n  }\n\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  public emit<EventName extends keyof Events>(\n    eventName: EventName,\n    ...data: Events[EventName]\n  ): boolean {\n    const listeners = this._getListeners(eventName)\n    listeners.forEach((listener) => {\n      listener.apply(this, data)\n    })\n\n    return listeners.length > 0\n  }\n\n  public addListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public addListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public addListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: InternalListener<Events> | Listener<Events[any]>\n  ): this {\n    // Emit the `newListener` event before adding the listener.\n    this._emitInternalEvent('newListener', eventName, listener)\n\n    const nextListeners = this._getListeners(eventName).concat(listener)\n    this.events.set(eventName, nextListeners)\n\n    if (\n      this.maxListeners > 0 &&\n      this.listenerCount(eventName) > this.maxListeners &&\n      !this.hasWarnedAboutPotentialMemoryLeak\n    ) {\n      this.hasWarnedAboutPotentialMemoryLeak = true\n\n      const memoryLeakWarning = new MemoryLeakError(\n        this,\n        eventName,\n        this.listenerCount(eventName)\n      )\n      console.warn(memoryLeakWarning)\n    }\n\n    return this\n  }\n\n  public on(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: 'removeListener' | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(eventName, listener)\n  }\n\n  public once(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: InternalEventNames | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public prependListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners)\n      this.events.set(eventName, nextListeners)\n    } else {\n      this.events.set(eventName, listeners.concat(listener))\n    }\n\n    return this\n  }\n\n  public prependOnceListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependOnceListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.prependListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public removeListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public removeListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public removeListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener)\n      this.events.set(eventName, listeners)\n\n      // Emit the `removeListener` event after removing the listener.\n      this._emitInternalEvent('removeListener', eventName, listener)\n    }\n\n    return this\n  }\n\n  public off(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public off<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  public off(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.removeListener(eventName, listener)\n  }\n\n  public removeAllListeners(eventName?: InternalEventNames): this\n  public removeAllListeners<EventName extends keyof Events>(\n    eventName?: EventName\n  ): this\n  public removeAllListeners(\n    eventName?: InternalEventNames | keyof Events\n  ): this {\n    if (eventName) {\n      this.events.delete(eventName)\n    } else {\n      this.events.clear()\n    }\n\n    return this\n  }\n\n  public listeners(eventName: InternalEventNames): Array<Listener<any>>\n  public listeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>>\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  public listeners(eventName: InternalEventNames | keyof Events) {\n    return Array.from(this._getListeners(eventName))\n  }\n\n  public listenerCount(eventName: InternalEventNames): number\n  public listenerCount<EventName extends keyof Events>(\n    eventName: EventName\n  ): number\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  public listenerCount(eventName: InternalEventNames | keyof Events): number {\n    return this._getListeners(eventName).length\n  }\n\n  public rawListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>> {\n    return this.listeners(eventName)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}