{"ast":null,"code":"// node_modules/.pnpm/outvariant@1.4.2/node_modules/outvariant/lib/index.mjs\nvar POSITIONALS_EXP = /(%?)(%([sdijo]))/g;\n\nfunction serializePositional(positional, flag) {\n  switch (flag) {\n    case \"s\":\n      return positional;\n\n    case \"d\":\n    case \"i\":\n      return Number(positional);\n\n    case \"j\":\n      return JSON.stringify(positional);\n\n    case \"o\":\n      {\n        if (typeof positional === \"string\") {\n          return positional;\n        }\n\n        const json = JSON.stringify(positional);\n\n        if (json === \"{}\" || json === \"[]\" || /^\\[object .+?\\]$/.test(json)) {\n          return positional;\n        }\n\n        return json;\n      }\n  }\n}\n\nfunction format(message) {\n  for (var _len = arguments.length, positionals = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    positionals[_key - 1] = arguments[_key];\n  }\n\n  if (positionals.length === 0) {\n    return message;\n  }\n\n  let positionalIndex = 0;\n  let formattedMessage = message.replace(POSITIONALS_EXP, (match, isEscaped, _, flag) => {\n    const positional = positionals[positionalIndex];\n    const value = serializePositional(positional, flag);\n\n    if (!isEscaped) {\n      positionalIndex++;\n      return value;\n    }\n\n    return match;\n  });\n\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(\" \")}`;\n  }\n\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, \"%\");\n  return formattedMessage;\n}\n\nvar STACK_FRAMES_TO_IGNORE = 2;\n\nfunction cleanErrorStack(error2) {\n  if (!error2.stack) {\n    return;\n  }\n\n  const nextStack = error2.stack.split(\"\\n\");\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE);\n  error2.stack = nextStack.join(\"\\n\");\n}\n\nvar InvariantError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = \"Invariant Violation\";\n\n    for (var _len2 = arguments.length, positionals = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      positionals[_key2 - 1] = arguments[_key2];\n    }\n\n    this.message = format(message, ...positionals);\n    cleanErrorStack(this);\n  }\n\n};\n\nvar invariant = function (predicate, message) {\n  if (!predicate) {\n    for (var _len3 = arguments.length, positionals = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      positionals[_key3 - 2] = arguments[_key3];\n    }\n\n    throw new InvariantError(message, ...positionals);\n  }\n};\n\ninvariant.as = function (ErrorConstructor, predicate, message) {\n  if (!predicate) {\n    for (var _len4 = arguments.length, positionals = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n      positionals[_key4 - 3] = arguments[_key4];\n    }\n\n    const formatMessage = positionals.length === 0 ? message : format(message, positionals);\n    let error2;\n\n    try {\n      error2 = Reflect.construct(ErrorConstructor, [formatMessage]);\n    } catch (err) {\n      error2 = ErrorConstructor(formatMessage);\n    }\n\n    throw error2;\n  }\n}; // node_modules/.pnpm/is-node-process@1.2.0/node_modules/is-node-process/lib/index.mjs\n\n\nfunction isNodeProcess() {\n  if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    return true;\n  }\n\n  if (typeof process !== \"undefined\") {\n    const type = process.type;\n\n    if (type === \"renderer\" || type === \"worker\") {\n      return false;\n    }\n\n    return !!(process.versions && process.versions.node);\n  }\n\n  return false;\n} // src/browser/setupWorker/start/createStartHandler.ts\n\n\nimport { devUtils as devUtils7 } from '../core/utils/internal/devUtils.mjs'; // node_modules/.pnpm/@open-draft+until@2.1.0/node_modules/@open-draft/until/lib/index.mjs\n\nvar until = async promise => {\n  try {\n    const data = await promise().catch(error2 => {\n      throw error2;\n    });\n    return {\n      error: null,\n      data\n    };\n  } catch (error2) {\n    return {\n      error: error2,\n      data: null\n    };\n  }\n}; // src/browser/setupWorker/start/utils/getWorkerInstance.ts\n\n\nimport { devUtils } from '../core/utils/internal/devUtils.mjs'; // src/browser/utils/getAbsoluteWorkerUrl.ts\n\nfunction getAbsoluteWorkerUrl(workerUrl) {\n  return new URL(workerUrl, location.href).href;\n} // src/browser/setupWorker/start/utils/getWorkerByRegistration.ts\n\n\nfunction getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker) {\n  const allStates = [registration.active, registration.installing, registration.waiting];\n  const relevantStates = allStates.filter(state => {\n    return state != null;\n  });\n  const worker = relevantStates.find(worker2 => {\n    return findWorker(worker2.scriptURL, absoluteWorkerUrl);\n  });\n  return worker || null;\n} // src/browser/setupWorker/start/utils/getWorkerInstance.ts\n\n\nvar getWorkerInstance = async function (url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let findWorker = arguments.length > 2 ? arguments[2] : undefined;\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n  const mockRegistrations = await navigator.serviceWorker.getRegistrations().then(registrations => registrations.filter(registration => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)));\n\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    location.reload();\n  }\n\n  const [existingRegistration] = mockRegistrations;\n\n  if (existingRegistration) {\n    return existingRegistration.update().then(() => {\n      return [getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker), existingRegistration];\n    });\n  }\n\n  const registrationResult = await until(async () => {\n    const registration = await navigator.serviceWorker.register(url, options);\n    return [// Compare existing worker registration by its worker URL,\n    // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n    getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker), registration];\n  });\n\n  if (registrationResult.error) {\n    const isWorkerMissing = registrationResult.error.message.includes(\"(404)\");\n\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || \"/\", location.href);\n      throw new Error(devUtils.formatMessage(`Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`));\n    }\n\n    throw new Error(devUtils.formatMessage(\"Failed to register the Service Worker:\\n\\n%s\", registrationResult.error.message));\n  }\n\n  return registrationResult.data;\n}; // src/browser/setupWorker/start/utils/enableMocking.ts\n\n\nimport { devUtils as devUtils3 } from '../core/utils/internal/devUtils.mjs'; // src/browser/setupWorker/start/utils/printStartMessage.ts\n\nimport { devUtils as devUtils2 } from '../core/utils/internal/devUtils.mjs';\n\nfunction printStartMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (args.quiet) {\n    return;\n  }\n\n  const message = args.message || \"Mocking enabled.\";\n  console.groupCollapsed(`%c${devUtils2.formatMessage(message)}`, \"color:orangered;font-weight:bold;\");\n  console.log(\"%cDocumentation: %chttps://mswjs.io/docs\", \"font-weight:bold\", \"font-weight:normal\");\n  console.log(\"Found an issue? https://github.com/mswjs/msw/issues\");\n\n  if (args.workerUrl) {\n    console.log(\"Worker script URL:\", args.workerUrl);\n  }\n\n  if (args.workerScope) {\n    console.log(\"Worker scope:\", args.workerScope);\n  }\n\n  console.groupEnd();\n} // src/browser/setupWorker/start/utils/enableMocking.ts\n\n\nasync function enableMocking(context, options) {\n  context.workerChannel.send(\"MOCK_ACTIVATE\");\n  await context.events.once(\"MOCKING_ENABLED\");\n\n  if (context.isMockingEnabled) {\n    devUtils3.warn(`Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`);\n    return;\n  }\n\n  context.isMockingEnabled = true;\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: context.registration?.scope,\n    workerUrl: context.worker?.scriptURL\n  });\n} // src/browser/setupWorker/start/utils/createMessageChannel.ts\n\n\nvar WorkerChannel = class {\n  constructor(port) {\n    this.port = port;\n  }\n\n  postMessage(event) {\n    for (var _len5 = arguments.length, rest = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      rest[_key5 - 1] = arguments[_key5];\n    }\n\n    const [data, transfer] = rest;\n    this.port.postMessage({\n      type: event,\n      data\n    }, {\n      transfer\n    });\n  }\n\n}; // src/browser/utils/pruneGetRequestBody.ts\n\nfunction pruneGetRequestBody(request) {\n  if ([\"HEAD\", \"GET\"].includes(request.method)) {\n    return void 0;\n  }\n\n  return request.body;\n} // src/browser/utils/parseWorkerRequest.ts\n\n\nfunction parseWorkerRequest(incomingRequest) {\n  return new Request(incomingRequest.url, { ...incomingRequest,\n    body: pruneGetRequestBody(incomingRequest)\n  });\n} // src/browser/setupWorker/start/createRequestListener.ts\n\n\nimport { RequestHandler } from '../core/handlers/RequestHandler.mjs';\nimport { handleRequest } from '../core/utils/handleRequest.mjs';\nimport { devUtils as devUtils4 } from '../core/utils/internal/devUtils.mjs';\nimport { toResponseInit } from '../core/utils/toResponseInit.mjs';\n\nvar createRequestListener = (context, options) => {\n  return async (event, message) => {\n    const messageChannel = new WorkerChannel(event.ports[0]);\n    const requestId = message.payload.id;\n    const request = parseWorkerRequest(message.payload);\n    const requestCloneForLogs = request.clone();\n    const requestClone = request.clone();\n    RequestHandler.cache.set(request, requestClone);\n    context.requests.set(requestId, requestClone);\n\n    try {\n      await handleRequest(request, requestId, context.getRequestHandlers(), options, context.emitter, {\n        onPassthroughResponse() {\n          messageChannel.postMessage(\"PASSTHROUGH\");\n        },\n\n        async onMockedResponse(response, _ref) {\n          let {\n            handler,\n            parsedResult\n          } = _ref;\n          const responseClone = response.clone();\n          const responseCloneForLogs = response.clone();\n          const responseInit = toResponseInit(response);\n\n          if (context.supports.readableStreamTransfer) {\n            const responseStreamOrNull = response.body;\n            messageChannel.postMessage(\"MOCK_RESPONSE\", { ...responseInit,\n              body: responseStreamOrNull\n            }, responseStreamOrNull ? [responseStreamOrNull] : void 0);\n          } else {\n            const responseBufferOrNull = response.body === null ? null : await responseClone.arrayBuffer();\n            messageChannel.postMessage(\"MOCK_RESPONSE\", { ...responseInit,\n              body: responseBufferOrNull\n            });\n          }\n\n          if (!options.quiet) {\n            context.emitter.once(\"response:mocked\", () => {\n              handler.log({\n                request: requestCloneForLogs,\n                response: responseCloneForLogs,\n                parsedResult\n              });\n            });\n          }\n        }\n\n      });\n    } catch (error2) {\n      if (error2 instanceof Error) {\n        devUtils4.error(`Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`, request.method, request.url, error2.stack ?? error2);\n        messageChannel.postMessage(\"MOCK_RESPONSE\", {\n          status: 500,\n          statusText: \"Request Handler Error\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            name: error2.name,\n            message: error2.message,\n            stack: error2.stack\n          })\n        });\n      }\n    }\n  };\n}; // src/browser/utils/checkWorkerIntegrity.ts\n\n\nimport { devUtils as devUtils5 } from '../core/utils/internal/devUtils.mjs';\n\nasync function checkWorkerIntegrity(context) {\n  context.workerChannel.send(\"INTEGRITY_CHECK_REQUEST\");\n  const {\n    payload\n  } = await context.events.once(\"INTEGRITY_CHECK_RESPONSE\");\n\n  if (payload.checksum !== \"26357c79639bfa20d64c0efca2a87423\") {\n    devUtils5.warn(`The currently registered Service Worker has been generated by a different version of MSW (${payload.packageVersion}) and may not be fully compatible with the installed version.\n\nIt's recommended you update your worker script by running this command:\n\n  \\u2022 npx msw init <PUBLIC_DIR>\n\nYou can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`);\n  }\n} // node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/lib/browser/chunk-6HYIRFX2.mjs\n\n\nvar encoder = new TextEncoder();\n\nfunction encodeBuffer(text) {\n  return encoder.encode(text);\n}\n\nfunction decodeBuffer(buffer, encoding) {\n  const decoder = new TextDecoder(encoding);\n  return decoder.decode(buffer);\n}\n\nfunction toArrayBuffer(array) {\n  return array.buffer.slice(array.byteOffset, array.byteOffset + array.byteLength);\n} // node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/lib/browser/chunk-OMISYKWR.mjs\n\n\nvar IS_PATCHED_MODULE = Symbol(\"isPatchedModule\");\n\nfunction isPropertyAccessible(obj, key) {\n  try {\n    obj[key];\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar RESPONSE_STATUS_CODES_WITHOUT_BODY = /* @__PURE__ */new Set([101, 103, 204, 205, 304]);\n\nfunction isResponseWithoutBody(status) {\n  return RESPONSE_STATUS_CODES_WITHOUT_BODY.has(status);\n}\n\nfunction createServerErrorResponse(body) {\n  return new Response(JSON.stringify(body instanceof Error ? {\n    name: body.name,\n    message: body.message,\n    stack: body.stack\n  } : body), {\n    status: 500,\n    statusText: \"Unhandled Exception\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  });\n}\n\nfunction isResponseError(response) {\n  return isPropertyAccessible(response, \"type\") && response.type === \"error\";\n} // node_modules/.pnpm/@open-draft+logger@0.3.0/node_modules/@open-draft/logger/lib/index.mjs\n\n\nvar __defProp = Object.defineProperty;\n\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\nvar colors_exports = {};\n\n__export(colors_exports, {\n  blue: () => blue,\n  gray: () => gray,\n  green: () => green,\n  red: () => red,\n  yellow: () => yellow\n});\n\nfunction yellow(text) {\n  return `\\x1B[33m${text}\\x1B[0m`;\n}\n\nfunction blue(text) {\n  return `\\x1B[34m${text}\\x1B[0m`;\n}\n\nfunction gray(text) {\n  return `\\x1B[90m${text}\\x1B[0m`;\n}\n\nfunction red(text) {\n  return `\\x1B[31m${text}\\x1B[0m`;\n}\n\nfunction green(text) {\n  return `\\x1B[32m${text}\\x1B[0m`;\n}\n\nvar IS_NODE = isNodeProcess();\nvar Logger = class {\n  constructor(name) {\n    this.name = name;\n    this.prefix = `[${this.name}]`;\n    const LOGGER_NAME = getVariable(\"DEBUG\");\n    const LOGGER_LEVEL = getVariable(\"LOG_LEVEL\");\n    const isLoggingEnabled = LOGGER_NAME === \"1\" || LOGGER_NAME === \"true\" || typeof LOGGER_NAME !== \"undefined\" && this.name.startsWith(LOGGER_NAME);\n\n    if (isLoggingEnabled) {\n      this.debug = isDefinedAndNotEquals(LOGGER_LEVEL, \"debug\") ? noop : this.debug;\n      this.info = isDefinedAndNotEquals(LOGGER_LEVEL, \"info\") ? noop : this.info;\n      this.success = isDefinedAndNotEquals(LOGGER_LEVEL, \"success\") ? noop : this.success;\n      this.warning = isDefinedAndNotEquals(LOGGER_LEVEL, \"warning\") ? noop : this.warning;\n      this.error = isDefinedAndNotEquals(LOGGER_LEVEL, \"error\") ? noop : this.error;\n    } else {\n      this.info = noop;\n      this.success = noop;\n      this.warning = noop;\n      this.error = noop;\n      this.only = noop;\n    }\n  }\n\n  prefix;\n\n  extend(domain) {\n    return new Logger(`${this.name}:${domain}`);\n  }\n  /**\n   * Print a debug message.\n   * @example\n   * logger.debug('no duplicates found, creating a document...')\n   */\n\n\n  debug(message) {\n    for (var _len6 = arguments.length, positionals = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      positionals[_key6 - 1] = arguments[_key6];\n    }\n\n    this.logEntry({\n      level: \"debug\",\n      message: gray(message),\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"gray\"\n      }\n    });\n  }\n  /**\n   * Print an info message.\n   * @example\n   * logger.info('start parsing...')\n   */\n\n\n  info(message) {\n    var _this = this;\n\n    for (var _len7 = arguments.length, positionals = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      positionals[_key7 - 1] = arguments[_key7];\n    }\n\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"blue\"\n      }\n    });\n    const performance2 = new PerformanceEntry();\n    return function (message2) {\n      performance2.measure();\n\n      for (var _len8 = arguments.length, positionals2 = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        positionals2[_key8 - 1] = arguments[_key8];\n      }\n\n      _this.logEntry({\n        level: \"info\",\n        message: `${message2} ${gray(`${performance2.deltaTime}ms`)}`,\n        positionals: positionals2,\n        prefix: _this.prefix,\n        colors: {\n          prefix: \"blue\"\n        }\n      });\n    };\n  }\n  /**\n   * Print a success message.\n   * @example\n   * logger.success('successfully created document')\n   */\n\n\n  success(message) {\n    for (var _len9 = arguments.length, positionals = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n      positionals[_key9 - 1] = arguments[_key9];\n    }\n\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: `\\u2714 ${this.prefix}`,\n      colors: {\n        timestamp: \"green\",\n        prefix: \"green\"\n      }\n    });\n  }\n  /**\n   * Print a warning.\n   * @example\n   * logger.warning('found legacy document format')\n   */\n\n\n  warning(message) {\n    for (var _len10 = arguments.length, positionals = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n      positionals[_key10 - 1] = arguments[_key10];\n    }\n\n    this.logEntry({\n      level: \"warning\",\n      message,\n      positionals,\n      prefix: `\\u26A0 ${this.prefix}`,\n      colors: {\n        timestamp: \"yellow\",\n        prefix: \"yellow\"\n      }\n    });\n  }\n  /**\n   * Print an error message.\n   * @example\n   * logger.error('something went wrong')\n   */\n\n\n  error(message) {\n    for (var _len11 = arguments.length, positionals = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n      positionals[_key11 - 1] = arguments[_key11];\n    }\n\n    this.logEntry({\n      level: \"error\",\n      message,\n      positionals,\n      prefix: `\\u2716 ${this.prefix}`,\n      colors: {\n        timestamp: \"red\",\n        prefix: \"red\"\n      }\n    });\n  }\n  /**\n   * Execute the given callback only when the logging is enabled.\n   * This is skipped in its entirety and has no runtime cost otherwise.\n   * This executes regardless of the log level.\n   * @example\n   * logger.only(() => {\n   *   logger.info('additional info')\n   * })\n   */\n\n\n  only(callback) {\n    callback();\n  }\n\n  createEntry(level, message) {\n    return {\n      timestamp: /* @__PURE__ */new Date(),\n      level,\n      message\n    };\n  }\n\n  logEntry(args) {\n    const {\n      level,\n      message,\n      prefix,\n      colors: customColors,\n      positionals = []\n    } = args;\n    const entry = this.createEntry(level, message);\n    const timestampColor = customColors?.timestamp || \"gray\";\n    const prefixColor = customColors?.prefix || \"gray\";\n    const colorize = {\n      timestamp: colors_exports[timestampColor],\n      prefix: colors_exports[prefixColor]\n    };\n    const write = this.getWriter(level);\n    write([colorize.timestamp(this.formatTimestamp(entry.timestamp))].concat(prefix != null ? colorize.prefix(prefix) : []).concat(serializeInput(message)).join(\" \"), ...positionals.map(serializeInput));\n  }\n\n  formatTimestamp(timestamp) {\n    return `${timestamp.toLocaleTimeString(\"en-GB\")}:${timestamp.getMilliseconds()}`;\n  }\n\n  getWriter(level) {\n    switch (level) {\n      case \"debug\":\n      case \"success\":\n      case \"info\":\n        {\n          return log;\n        }\n\n      case \"warning\":\n        {\n          return warn;\n        }\n\n      case \"error\":\n        {\n          return error;\n        }\n    }\n  }\n\n};\nvar PerformanceEntry = class {\n  startTime;\n  endTime;\n  deltaTime;\n\n  constructor() {\n    this.startTime = performance.now();\n  }\n\n  measure() {\n    this.endTime = performance.now();\n    const deltaTime = this.endTime - this.startTime;\n    this.deltaTime = deltaTime.toFixed(2);\n  }\n\n};\n\nvar noop = () => void 0;\n\nfunction log(message) {\n  for (var _len12 = arguments.length, positionals = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n    positionals[_key12 - 1] = arguments[_key12];\n  }\n\n  if (IS_NODE) {\n    process.stdout.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n\n  console.log(message, ...positionals);\n}\n\nfunction warn(message) {\n  for (var _len13 = arguments.length, positionals = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {\n    positionals[_key13 - 1] = arguments[_key13];\n  }\n\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n\n  console.warn(message, ...positionals);\n}\n\nfunction error(message) {\n  for (var _len14 = arguments.length, positionals = new Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {\n    positionals[_key14 - 1] = arguments[_key14];\n  }\n\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n\n  console.error(message, ...positionals);\n}\n\nfunction getVariable(variableName) {\n  if (IS_NODE) {\n    return process.env[variableName];\n  }\n\n  return globalThis[variableName]?.toString();\n}\n\nfunction isDefinedAndNotEquals(value, expected) {\n  return value !== void 0 && value !== expected;\n}\n\nfunction serializeInput(message) {\n  if (typeof message === \"undefined\") {\n    return \"undefined\";\n  }\n\n  if (message === null) {\n    return \"null\";\n  }\n\n  if (typeof message === \"string\") {\n    return message;\n  }\n\n  if (typeof message === \"object\") {\n    return JSON.stringify(message);\n  }\n\n  return message.toString();\n} // node_modules/.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/lib/index.mjs\n\n\nvar MemoryLeakError = class extends Error {\n  constructor(emitter, type, count) {\n    super(`Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`);\n    this.emitter = emitter;\n    this.type = type;\n    this.count = count;\n    this.name = \"MaxListenersExceededWarning\";\n  }\n\n};\n\nvar _Emitter = class {\n  static listenerCount(emitter, eventName) {\n    return emitter.listenerCount(eventName);\n  }\n\n  constructor() {\n    this.events = /* @__PURE__ */new Map();\n    this.maxListeners = _Emitter.defaultMaxListeners;\n    this.hasWarnedAboutPotentialMemoryLeak = false;\n  }\n\n  _emitInternalEvent(internalEventName, eventName, listener) {\n    this.emit(internalEventName, ...[eventName, listener]);\n  }\n\n  _getListeners(eventName) {\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || [];\n  }\n\n  _removeListener(listeners, listener) {\n    const index = listeners.indexOf(listener);\n\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n\n    return [];\n  }\n\n  _wrapOnceListener(eventName, listener) {\n    var _this2 = this;\n\n    const onceListener = function () {\n      _this2.removeListener(eventName, onceListener);\n\n      for (var _len15 = arguments.length, data = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        data[_key15] = arguments[_key15];\n      }\n\n      return listener.apply(_this2, data);\n    };\n\n    Object.defineProperty(onceListener, \"name\", {\n      value: listener.name\n    });\n    return onceListener;\n  }\n\n  setMaxListeners(maxListeners) {\n    this.maxListeners = maxListeners;\n    return this;\n  }\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n\n\n  getMaxListeners() {\n    return this.maxListeners;\n  }\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n\n\n  eventNames() {\n    return Array.from(this.events.keys());\n  }\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n\n\n  emit(eventName) {\n    for (var _len16 = arguments.length, data = new Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) {\n      data[_key16 - 1] = arguments[_key16];\n    }\n\n    const listeners = this._getListeners(eventName);\n\n    listeners.forEach(listener => {\n      listener.apply(this, data);\n    });\n    return listeners.length > 0;\n  }\n\n  addListener(eventName, listener) {\n    this._emitInternalEvent(\"newListener\", eventName, listener);\n\n    const nextListeners = this._getListeners(eventName).concat(listener);\n\n    this.events.set(eventName, nextListeners);\n\n    if (this.maxListeners > 0 && this.listenerCount(eventName) > this.maxListeners && !this.hasWarnedAboutPotentialMemoryLeak) {\n      this.hasWarnedAboutPotentialMemoryLeak = true;\n      const memoryLeakWarning = new MemoryLeakError(this, eventName, this.listenerCount(eventName));\n      console.warn(memoryLeakWarning);\n    }\n\n    return this;\n  }\n\n  on(eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n\n  once(eventName, listener) {\n    return this.addListener(eventName, this._wrapOnceListener(eventName, listener));\n  }\n\n  prependListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners);\n      this.events.set(eventName, nextListeners);\n    } else {\n      this.events.set(eventName, listeners.concat(listener));\n    }\n\n    return this;\n  }\n\n  prependOnceListener(eventName, listener) {\n    return this.prependListener(eventName, this._wrapOnceListener(eventName, listener));\n  }\n\n  removeListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener);\n\n      this.events.set(eventName, listeners);\n\n      this._emitInternalEvent(\"removeListener\", eventName, listener);\n    }\n\n    return this;\n  }\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n\n\n  off(eventName, listener) {\n    return this.removeListener(eventName, listener);\n  }\n\n  removeAllListeners(eventName) {\n    if (eventName) {\n      this.events.delete(eventName);\n    } else {\n      this.events.clear();\n    }\n\n    return this;\n  }\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n\n\n  listeners(eventName) {\n    return Array.from(this._getListeners(eventName));\n  }\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n\n\n  listenerCount(eventName) {\n    return this._getListeners(eventName).length;\n  }\n\n  rawListeners(eventName) {\n    return this.listeners(eventName);\n  }\n\n};\n\nvar Emitter = _Emitter;\nEmitter.defaultMaxListeners = 10; // node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/lib/browser/chunk-QED3Q6Z2.mjs\n\nvar INTERNAL_REQUEST_ID_HEADER_NAME = \"x-interceptors-internal-request-id\";\n\nfunction getGlobalSymbol(symbol) {\n  return (// @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || void 0\n  );\n}\n\nfunction setGlobalSymbol(symbol, value) {\n  globalThis[symbol] = value;\n}\n\nfunction deleteGlobalSymbol(symbol) {\n  delete globalThis[symbol];\n}\n\nvar Interceptor = class {\n  constructor(symbol) {\n    this.symbol = symbol;\n    this.readyState = \"INACTIVE\";\n    this.emitter = new Emitter();\n    this.subscriptions = [];\n    this.logger = new Logger(symbol.description);\n    this.emitter.setMaxListeners(0);\n    this.logger.info(\"constructing the interceptor...\");\n  }\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n\n\n  checkEnvironment() {\n    return true;\n  }\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n\n\n  apply() {\n    const logger = this.logger.extend(\"apply\");\n    logger.info(\"applying the interceptor...\");\n\n    if (this.readyState === \"APPLIED\") {\n      logger.info(\"intercepted already applied!\");\n      return;\n    }\n\n    const shouldApply = this.checkEnvironment();\n\n    if (!shouldApply) {\n      logger.info(\"the interceptor cannot be applied in this environment!\");\n      return;\n    }\n\n    this.readyState = \"APPLYING\";\n    const runningInstance = this.getInstance();\n\n    if (runningInstance) {\n      logger.info(\"found a running instance, reusing...\");\n\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event);\n        runningInstance.emitter.addListener(event, listener);\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener);\n          logger.info('removed proxied \"%s\" listener!', event);\n        });\n        return this;\n      };\n\n      this.readyState = \"APPLIED\";\n      return;\n    }\n\n    logger.info(\"no running instance found, setting up a new instance...\");\n    this.setup();\n    this.setInstance();\n    this.readyState = \"APPLIED\";\n  }\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n\n\n  setup() {}\n  /**\n   * Listen to the interceptor's public events.\n   */\n\n\n  on(event, listener) {\n    const logger = this.logger.extend(\"on\");\n\n    if (this.readyState === \"DISPOSING\" || this.readyState === \"DISPOSED\") {\n      logger.info(\"cannot listen to events, already disposed!\");\n      return this;\n    }\n\n    logger.info('adding \"%s\" event listener:', event, listener);\n    this.emitter.on(event, listener);\n    return this;\n  }\n\n  once(event, listener) {\n    this.emitter.once(event, listener);\n    return this;\n  }\n\n  off(event, listener) {\n    this.emitter.off(event, listener);\n    return this;\n  }\n\n  removeAllListeners(event) {\n    this.emitter.removeAllListeners(event);\n    return this;\n  }\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n\n\n  dispose() {\n    const logger = this.logger.extend(\"dispose\");\n\n    if (this.readyState === \"DISPOSED\") {\n      logger.info(\"cannot dispose, already disposed!\");\n      return;\n    }\n\n    logger.info(\"disposing the interceptor...\");\n    this.readyState = \"DISPOSING\";\n\n    if (!this.getInstance()) {\n      logger.info(\"no interceptors running, skipping dispose...\");\n      return;\n    }\n\n    this.clearInstance();\n    logger.info(\"global symbol deleted:\", getGlobalSymbol(this.symbol));\n\n    if (this.subscriptions.length > 0) {\n      logger.info(\"disposing of %d subscriptions...\", this.subscriptions.length);\n\n      for (const dispose of this.subscriptions) {\n        dispose();\n      }\n\n      this.subscriptions = [];\n      logger.info(\"disposed of all subscriptions!\", this.subscriptions.length);\n    }\n\n    this.emitter.removeAllListeners();\n    logger.info(\"destroyed the listener!\");\n    this.readyState = \"DISPOSED\";\n  }\n\n  getInstance() {\n    var _a;\n\n    const instance = getGlobalSymbol(this.symbol);\n    this.logger.info(\"retrieved global instance:\", (_a = instance == null ? void 0 : instance.constructor) == null ? void 0 : _a.name);\n    return instance;\n  }\n\n  setInstance() {\n    setGlobalSymbol(this.symbol, this);\n    this.logger.info(\"set global instance!\", this.symbol.description);\n  }\n\n  clearInstance() {\n    deleteGlobalSymbol(this.symbol);\n    this.logger.info(\"cleared global instance!\", this.symbol.description);\n  }\n\n};\n\nfunction createRequestId() {\n  return Math.random().toString(16).slice(2);\n} // node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/lib/browser/index.mjs\n\n\nvar BatchInterceptor = class extends Interceptor {\n  constructor(options) {\n    BatchInterceptor.symbol = Symbol(options.name);\n    super(BatchInterceptor.symbol);\n    this.interceptors = options.interceptors;\n  }\n\n  setup() {\n    const logger = this.logger.extend(\"setup\");\n    logger.info(\"applying all %d interceptors...\", this.interceptors.length);\n\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name);\n      interceptor.apply();\n      logger.info(\"adding interceptor dispose subscription\");\n      this.subscriptions.push(() => interceptor.dispose());\n    }\n  }\n\n  on(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener);\n    }\n\n    return this;\n  }\n\n  once(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener);\n    }\n\n    return this;\n  }\n\n  off(event, listener) {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener);\n    }\n\n    return this;\n  }\n\n  removeAllListeners(event) {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event);\n    }\n\n    return this;\n  }\n\n}; // src/browser/setupWorker/start/createResponseListener.ts\n\nfunction createResponseListener(context) {\n  return (_, message) => {\n    const {\n      payload: responseJson\n    } = message;\n    const {\n      requestId\n    } = responseJson;\n    const request = context.requests.get(requestId);\n    context.requests.delete(requestId);\n\n    if (responseJson.type?.includes(\"opaque\")) {\n      return;\n    }\n\n    const response = responseJson.status === 0 ? Response.error() : new Response(\n    /**\n     * Responses may be streams here, but when we create a response object\n     * with null-body status codes, like 204, 205, 304 Response will\n     * throw when passed a non-null body, so ensure it's null here\n     * for those codes\n     */\n    isResponseWithoutBody(responseJson.status) ? null : responseJson.body, responseJson);\n\n    if (!response.url) {\n      Object.defineProperty(response, \"url\", {\n        value: request.url,\n        enumerable: true,\n        writable: false\n      });\n    }\n\n    context.emitter.emit(responseJson.isMockedResponse ? \"response:mocked\" : \"response:bypass\", {\n      response,\n      request,\n      requestId: responseJson.requestId\n    });\n  };\n} // src/browser/setupWorker/start/utils/validateWorkerScope.ts\n\n\nimport { devUtils as devUtils6 } from '../core/utils/internal/devUtils.mjs';\n\nfunction validateWorkerScope(registration, options) {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    devUtils6.warn(`Cannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.`);\n  }\n} // src/browser/setupWorker/start/createStartHandler.ts\n\n\nvar createStartHandler = context => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      context.events.removeAllListeners();\n      context.workerChannel.on(\"REQUEST\", createRequestListener(context, options));\n      context.workerChannel.on(\"RESPONSE\", createResponseListener(context));\n      const instance = await getWorkerInstance(options.serviceWorker.url, options.serviceWorker.options, options.findWorker);\n      const [worker, registration] = instance;\n\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker ? devUtils7.formatMessage(`Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`, options.serviceWorker.url) : devUtils7.formatMessage(`Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`, options.serviceWorker.url, location.host);\n        throw new Error(missingWorkerMessage);\n      }\n\n      context.worker = worker;\n      context.registration = registration;\n      context.events.addListener(window, \"beforeunload\", () => {\n        if (worker.state !== \"redundant\") {\n          context.workerChannel.send(\"CLIENT_CLOSED\");\n        }\n\n        window.clearInterval(context.keepAliveInterval);\n      });\n      await checkWorkerIntegrity(context).catch(error2 => {\n        devUtils7.error(\"Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues), including the original error below.\");\n        console.error(error2);\n      });\n      context.keepAliveInterval = window.setInterval(() => context.workerChannel.send(\"KEEPALIVE_REQUEST\"), 5e3);\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    };\n\n    const workerRegistration = startWorkerInstance().then(async registration => {\n      const pendingInstance = registration.installing || registration.waiting;\n\n      if (pendingInstance) {\n        await new Promise(resolve => {\n          pendingInstance.addEventListener(\"statechange\", () => {\n            if (pendingInstance.state === \"activated\") {\n              return resolve();\n            }\n          });\n        });\n      }\n\n      await enableMocking(context, options).catch(error2 => {\n        throw new Error(`Failed to enable mocking: ${error2?.message}`);\n      });\n      return registration;\n    });\n    return workerRegistration;\n  };\n}; // src/browser/setupWorker/stop/createStop.ts\n\n\nimport { devUtils as devUtils9 } from '../core/utils/internal/devUtils.mjs'; // src/browser/setupWorker/stop/utils/printStopMessage.ts\n\nimport { devUtils as devUtils8 } from '../core/utils/internal/devUtils.mjs';\n\nfunction printStopMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (args.quiet) {\n    return;\n  }\n\n  console.log(`%c${devUtils8.formatMessage(\"Mocking disabled.\")}`, \"color:orangered;font-weight:bold;\");\n} // src/browser/setupWorker/stop/createStop.ts\n\n\nvar createStop = context => {\n  return function stop() {\n    if (!context.isMockingEnabled) {\n      devUtils9.warn('Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.');\n      return;\n    }\n\n    context.workerChannel.send(\"MOCK_DEACTIVATE\");\n    context.isMockingEnabled = false;\n    window.clearInterval(context.keepAliveInterval);\n    printStopMessage({\n      quiet: context.startOptions?.quiet\n    });\n  };\n}; // src/browser/setupWorker/start/utils/prepareStartHandler.ts\n\n\nimport { mergeRight } from '../core/utils/internal/mergeRight.mjs';\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: \"/mockServiceWorker.js\",\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: \"warn\",\n\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n\n}; // node_modules/.pnpm/@open-draft+deferred-promise@2.2.0/node_modules/@open-draft/deferred-promise/build/index.mjs\n\nfunction createDeferredExecutor() {\n  const executor = (resolve, reject) => {\n    executor.state = \"pending\";\n\n    executor.resolve = data => {\n      if (executor.state !== \"pending\") {\n        return;\n      }\n\n      executor.result = data;\n\n      const onFulfilled = value => {\n        executor.state = \"fulfilled\";\n        return value;\n      };\n\n      return resolve(data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled));\n    };\n\n    executor.reject = reason => {\n      if (executor.state !== \"pending\") {\n        return;\n      }\n\n      queueMicrotask(() => {\n        executor.state = \"rejected\";\n      });\n      return reject(executor.rejectionReason = reason);\n    };\n  };\n\n  return executor;\n}\n\nvar DeferredPromise = class extends Promise {\n  #executor;\n  resolve;\n  reject;\n\n  constructor() {\n    let executor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const deferredExecutor = createDeferredExecutor();\n    super((originalResolve, originalReject) => {\n      deferredExecutor(originalResolve, originalReject);\n      executor?.(deferredExecutor.resolve, deferredExecutor.reject);\n    });\n    this.#executor = deferredExecutor;\n    this.resolve = this.#executor.resolve;\n    this.reject = this.#executor.reject;\n  }\n\n  get state() {\n    return this.#executor.state;\n  }\n\n  get rejectionReason() {\n    return this.#executor.rejectionReason;\n  }\n\n  then(onFulfilled, onRejected) {\n    return this.#decorate(super.then(onFulfilled, onRejected));\n  }\n\n  catch(onRejected) {\n    return this.#decorate(super.catch(onRejected));\n  }\n\n  finally(onfinally) {\n    return this.#decorate(super.finally(onfinally));\n  }\n\n  #decorate(promise) {\n    return Object.defineProperties(promise, {\n      resolve: {\n        configurable: true,\n        value: this.resolve\n      },\n      reject: {\n        configurable: true,\n        value: this.reject\n      }\n    });\n  }\n\n}; // node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/lib/browser/chunk-OUWBQF3Z.mjs\n\nvar RequestController = class {\n  constructor(request) {\n    this.request = request;\n    this.responsePromise = new DeferredPromise();\n  }\n\n  respondWith(response) {\n    invariant(this.responsePromise.state === \"pending\", 'Failed to respond to \"%s %s\" request: the \"request\" event has already been responded to.', this.request.method, this.request.url);\n    this.responsePromise.resolve(response);\n  }\n\n};\n\nfunction toInteractiveRequest(request) {\n  const requestController = new RequestController(request);\n  Reflect.set(request, \"respondWith\", requestController.respondWith.bind(requestController));\n  return {\n    interactiveRequest: request,\n    requestController\n  };\n}\n\nasync function emitAsync(emitter, eventName) {\n  const listners = emitter.listeners(eventName);\n\n  if (listners.length === 0) {\n    return;\n  }\n\n  for (var _len17 = arguments.length, data = new Array(_len17 > 2 ? _len17 - 2 : 0), _key17 = 2; _key17 < _len17; _key17++) {\n    data[_key17 - 2] = arguments[_key17];\n  }\n\n  for (const listener of listners) {\n    await listener.apply(emitter, data);\n  }\n} // node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/lib/browser/chunk-MAEPOYB6.mjs\n\n\nfunction canParseUrl(url) {\n  try {\n    new URL(url);\n    return true;\n  } catch (_error) {\n    return false;\n  }\n}\n\nvar _FetchInterceptor = class extends Interceptor {\n  constructor() {\n    super(_FetchInterceptor.symbol);\n  }\n\n  checkEnvironment() {\n    return typeof globalThis !== \"undefined\" && typeof globalThis.fetch !== \"undefined\";\n  }\n\n  async setup() {\n    const pureFetch = globalThis.fetch;\n    invariant(!pureFetch[IS_PATCHED_MODULE], 'Failed to patch the \"fetch\" module: already patched.');\n\n    globalThis.fetch = async (input, init) => {\n      var _a;\n\n      const requestId = createRequestId();\n      const resolvedInput = typeof input === \"string\" && typeof location !== \"undefined\" && !canParseUrl(input) ? new URL(input, location.origin) : input;\n      const request = new Request(resolvedInput, init);\n      this.logger.info(\"[%s] %s\", request.method, request.url);\n      const {\n        interactiveRequest,\n        requestController\n      } = toInteractiveRequest(request);\n      this.logger.info('emitting the \"request\" event for %d listener(s)...', this.emitter.listenerCount(\"request\"));\n      this.emitter.once(\"request\", _ref2 => {\n        let {\n          requestId: pendingRequestId\n        } = _ref2;\n\n        if (pendingRequestId !== requestId) {\n          return;\n        }\n\n        if (requestController.responsePromise.state === \"pending\") {\n          requestController.responsePromise.resolve(void 0);\n        }\n      });\n      this.logger.info(\"awaiting for the mocked response...\");\n      const signal = interactiveRequest.signal;\n      const requestAborted = new DeferredPromise();\n\n      if (signal) {\n        signal.addEventListener(\"abort\", () => {\n          requestAborted.reject(signal.reason);\n        }, {\n          once: true\n        });\n      }\n\n      const responsePromise = new DeferredPromise();\n\n      const respondWith = response => {\n        this.logger.info(\"responding with a mock response:\", response);\n\n        if (this.emitter.listenerCount(\"response\") > 0) {\n          this.logger.info('emitting the \"response\" event...');\n          const responseClone = response.clone();\n          this.emitter.emit(\"response\", {\n            response: responseClone,\n            isMockedResponse: true,\n            request: interactiveRequest,\n            requestId\n          });\n        }\n\n        Object.defineProperty(response, \"url\", {\n          writable: false,\n          enumerable: true,\n          configurable: false,\n          value: request.url\n        });\n        responsePromise.resolve(response);\n      };\n\n      const errorWith = reason => {\n        responsePromise.reject(reason);\n      };\n\n      const resolverResult = await until(async () => {\n        const listenersFinished = emitAsync(this.emitter, \"request\", {\n          request: interactiveRequest,\n          requestId\n        });\n        await Promise.race([requestAborted, // Put the listeners invocation Promise in the same race condition\n        // with the request abort Promise because otherwise awaiting the listeners\n        // would always yield some response (or undefined).\n        listenersFinished, requestController.responsePromise]);\n        this.logger.info(\"all request listeners have been resolved!\");\n        const mockedResponse2 = await requestController.responsePromise;\n        this.logger.info(\"event.respondWith called with:\", mockedResponse2);\n        return mockedResponse2;\n      });\n\n      if (requestAborted.state === \"rejected\") {\n        this.logger.info(\"request has been aborted:\", requestAborted.rejectionReason);\n        responsePromise.reject(requestAborted.rejectionReason);\n        return responsePromise;\n      }\n\n      if (resolverResult.error) {\n        this.logger.info(\"request listerner threw an error:\", resolverResult.error);\n\n        if (resolverResult.error instanceof Response) {\n          if (isResponseError(resolverResult.error)) {\n            errorWith(createNetworkError(resolverResult.error));\n          } else {\n            respondWith(resolverResult.error);\n          }\n        }\n\n        if (this.emitter.listenerCount(\"unhandledException\") > 0) {\n          await emitAsync(this.emitter, \"unhandledException\", {\n            error: resolverResult.error,\n            request,\n            requestId,\n            controller: {\n              respondWith,\n              errorWith\n            }\n          });\n\n          if (responsePromise.state !== \"pending\") {\n            return responsePromise;\n          }\n        }\n\n        respondWith(createServerErrorResponse(resolverResult.error));\n        return responsePromise;\n      }\n\n      const mockedResponse = resolverResult.data;\n\n      if (mockedResponse && !((_a = request.signal) == null ? void 0 : _a.aborted)) {\n        this.logger.info(\"received mocked response:\", mockedResponse);\n\n        if (isResponseError(mockedResponse)) {\n          this.logger.info(\"received a network error response, rejecting the request promise...\");\n          errorWith(createNetworkError(mockedResponse));\n        } else {\n          respondWith(mockedResponse);\n        }\n\n        return responsePromise;\n      }\n\n      this.logger.info(\"no mocked response received!\");\n      return pureFetch(request).then(response => {\n        this.logger.info(\"original fetch performed\", response);\n\n        if (this.emitter.listenerCount(\"response\") > 0) {\n          this.logger.info('emitting the \"response\" event...');\n          const responseClone = response.clone();\n          this.emitter.emit(\"response\", {\n            response: responseClone,\n            isMockedResponse: false,\n            request: interactiveRequest,\n            requestId\n          });\n        }\n\n        return response;\n      });\n    };\n\n    Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true\n    });\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n        value: void 0\n      });\n      globalThis.fetch = pureFetch;\n      this.logger.info('restored native \"globalThis.fetch\"!', globalThis.fetch.name);\n    });\n  }\n\n};\n\nvar FetchInterceptor = _FetchInterceptor;\nFetchInterceptor.symbol = Symbol(\"fetch\");\n\nfunction createNetworkError(cause) {\n  return Object.assign(new TypeError(\"Failed to fetch\"), {\n    cause\n  });\n} // node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/lib/browser/chunk-732REFPX.mjs\n\n\nfunction concatArrayBuffer(left, right) {\n  const result = new Uint8Array(left.byteLength + right.byteLength);\n  result.set(left, 0);\n  result.set(right, left.byteLength);\n  return result;\n}\n\nvar EventPolyfill = class {\n  constructor(type, options) {\n    this.AT_TARGET = 0;\n    this.BUBBLING_PHASE = 0;\n    this.CAPTURING_PHASE = 0;\n    this.NONE = 0;\n    this.type = \"\";\n    this.srcElement = null;\n    this.currentTarget = null;\n    this.eventPhase = 0;\n    this.isTrusted = true;\n    this.composed = false;\n    this.cancelable = true;\n    this.defaultPrevented = false;\n    this.bubbles = true;\n    this.lengthComputable = true;\n    this.loaded = 0;\n    this.total = 0;\n    this.cancelBubble = false;\n    this.returnValue = true;\n    this.type = type;\n    this.target = (options == null ? void 0 : options.target) || null;\n    this.currentTarget = (options == null ? void 0 : options.currentTarget) || null;\n    this.timeStamp = Date.now();\n  }\n\n  composedPath() {\n    return [];\n  }\n\n  initEvent(type, bubbles, cancelable) {\n    this.type = type;\n    this.bubbles = !!bubbles;\n    this.cancelable = !!cancelable;\n  }\n\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n\n  stopPropagation() {}\n\n  stopImmediatePropagation() {}\n\n};\nvar ProgressEventPolyfill = class extends EventPolyfill {\n  constructor(type, init) {\n    super(type);\n    this.lengthComputable = (init == null ? void 0 : init.lengthComputable) || false;\n    this.composed = (init == null ? void 0 : init.composed) || false;\n    this.loaded = (init == null ? void 0 : init.loaded) || 0;\n    this.total = (init == null ? void 0 : init.total) || 0;\n  }\n\n};\nvar SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== \"undefined\";\n\nfunction createEvent(target, type, init) {\n  const progressEvents = [\"error\", \"progress\", \"loadstart\", \"loadend\", \"load\", \"timeout\", \"abort\"];\n  const ProgressEventClass = SUPPORTS_PROGRESS_EVENT ? ProgressEvent : ProgressEventPolyfill;\n  const event = progressEvents.includes(type) ? new ProgressEventClass(type, {\n    lengthComputable: true,\n    loaded: (init == null ? void 0 : init.loaded) || 0,\n    total: (init == null ? void 0 : init.total) || 0\n  }) : new EventPolyfill(type, {\n    target,\n    currentTarget: target\n  });\n  return event;\n}\n\nfunction findPropertySource(target, propertyName) {\n  if (!(propertyName in target)) {\n    return null;\n  }\n\n  const hasProperty = Object.prototype.hasOwnProperty.call(target, propertyName);\n\n  if (hasProperty) {\n    return target;\n  }\n\n  const prototype = Reflect.getPrototypeOf(target);\n  return prototype ? findPropertySource(prototype, propertyName) : null;\n}\n\nfunction createProxy(target, options) {\n  const proxy = new Proxy(target, optionsToProxyHandler(options));\n  return proxy;\n}\n\nfunction optionsToProxyHandler(options) {\n  const {\n    constructorCall,\n    methodCall,\n    getProperty,\n    setProperty\n  } = options;\n  const handler = {};\n\n  if (typeof constructorCall !== \"undefined\") {\n    handler.construct = function (target, args, newTarget) {\n      const next = Reflect.construct.bind(null, target, args, newTarget);\n      return constructorCall.call(newTarget, args, next);\n    };\n  }\n\n  handler.set = function (target, propertyName, nextValue) {\n    const next = () => {\n      const propertySource = findPropertySource(target, propertyName) || target;\n      const ownDescriptors = Reflect.getOwnPropertyDescriptor(propertySource, propertyName);\n\n      if (typeof (ownDescriptors == null ? void 0 : ownDescriptors.set) !== \"undefined\") {\n        ownDescriptors.set.apply(target, [nextValue]);\n        return true;\n      }\n\n      return Reflect.defineProperty(propertySource, propertyName, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: nextValue\n      });\n    };\n\n    if (typeof setProperty !== \"undefined\") {\n      return setProperty.call(target, [propertyName, nextValue], next);\n    }\n\n    return next();\n  };\n\n  handler.get = function (target, propertyName, receiver) {\n    const next = () => target[propertyName];\n\n    const value = typeof getProperty !== \"undefined\" ? getProperty.call(target, [propertyName, receiver], next) : next();\n\n    if (typeof value === \"function\") {\n      return function () {\n        for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n          args[_key18] = arguments[_key18];\n        }\n\n        const next2 = value.bind(target, ...args);\n\n        if (typeof methodCall !== \"undefined\") {\n          return methodCall.call(target, [propertyName, args], next2);\n        }\n\n        return next2();\n      };\n    }\n\n    return value;\n  };\n\n  return handler;\n}\n\nfunction isDomParserSupportedType(type) {\n  const supportedTypes = [\"application/xhtml+xml\", \"application/xml\", \"image/svg+xml\", \"text/html\", \"text/xml\"];\n  return supportedTypes.some(supportedType => {\n    return type.startsWith(supportedType);\n  });\n}\n\nfunction parseJson(data) {\n  try {\n    const json = JSON.parse(data);\n    return json;\n  } catch (_) {\n    return null;\n  }\n}\n\nfunction createResponse(request, body) {\n  const responseBodyOrNull = isResponseWithoutBody(request.status) ? null : body;\n  return new Response(responseBodyOrNull, {\n    status: request.status,\n    statusText: request.statusText,\n    headers: createHeadersFromXMLHttpReqestHeaders(request.getAllResponseHeaders())\n  });\n}\n\nfunction createHeadersFromXMLHttpReqestHeaders(headersString) {\n  const headers = new Headers();\n  const lines = headersString.split(/[\\r\\n]+/);\n\n  for (const line of lines) {\n    if (line.trim() === \"\") {\n      continue;\n    }\n\n    const [name, ...parts] = line.split(\": \");\n    const value = parts.join(\": \");\n    headers.append(name, value);\n  }\n\n  return headers;\n}\n\nvar IS_MOCKED_RESPONSE = Symbol(\"isMockedResponse\");\nvar IS_NODE2 = isNodeProcess();\nvar XMLHttpRequestController = class {\n  constructor(initialRequest, logger) {\n    this.initialRequest = initialRequest;\n    this.logger = logger;\n    this.method = \"GET\";\n    this.url = null;\n    this.events = /* @__PURE__ */new Map();\n    this.requestId = createRequestId();\n    this.requestHeaders = new Headers();\n    this.responseBuffer = new Uint8Array();\n    this.request = createProxy(initialRequest, {\n      setProperty: (_ref3, invoke) => {\n        let [propertyName, nextValue] = _ref3;\n\n        switch (propertyName) {\n          case \"ontimeout\":\n            {\n              const eventName = propertyName.slice(2);\n              this.request.addEventListener(eventName, nextValue);\n              return invoke();\n            }\n\n          default:\n            {\n              return invoke();\n            }\n        }\n      },\n      methodCall: (_ref4, invoke) => {\n        let [methodName, args] = _ref4;\n\n        var _a;\n\n        switch (methodName) {\n          case \"open\":\n            {\n              const [method, url] = args;\n\n              if (typeof url === \"undefined\") {\n                this.method = \"GET\";\n                this.url = toAbsoluteUrl(method);\n              } else {\n                this.method = method;\n                this.url = toAbsoluteUrl(url);\n              }\n\n              this.logger = this.logger.extend(`${this.method} ${this.url.href}`);\n              this.logger.info(\"open\", this.method, this.url.href);\n              return invoke();\n            }\n\n          case \"addEventListener\":\n            {\n              const [eventName, listener] = args;\n              this.registerEvent(eventName, listener);\n              this.logger.info(\"addEventListener\", eventName, listener);\n              return invoke();\n            }\n\n          case \"setRequestHeader\":\n            {\n              const [name, value] = args;\n              this.requestHeaders.set(name, value);\n              this.logger.info(\"setRequestHeader\", name, value);\n              return invoke();\n            }\n\n          case \"send\":\n            {\n              const [body] = args;\n\n              if (body != null) {\n                this.requestBody = typeof body === \"string\" ? encodeBuffer(body) : body;\n              }\n\n              this.request.addEventListener(\"load\", () => {\n                if (typeof this.onResponse !== \"undefined\") {\n                  const fetchResponse = createResponse(this.request,\n                  /**\n                   * The `response` property is the right way to read\n                   * the ambiguous response body, as the request's \"responseType\" may differ.\n                   * @see https://xhr.spec.whatwg.org/#the-response-attribute\n                   */\n                  this.request.response);\n                  this.onResponse.call(this, {\n                    response: fetchResponse,\n                    isMockedResponse: IS_MOCKED_RESPONSE in this.request,\n                    request: fetchRequest,\n                    requestId: this.requestId\n                  });\n                }\n              });\n              const fetchRequest = this.toFetchApiRequest();\n              const onceRequestSettled = ((_a = this.onRequest) == null ? void 0 : _a.call(this, {\n                request: fetchRequest,\n                requestId: this.requestId\n              })) || Promise.resolve();\n              onceRequestSettled.finally(() => {\n                if (this.request.readyState < this.request.LOADING) {\n                  this.logger.info(\"request callback settled but request has not been handled (readystate %d), performing as-is...\", this.request.readyState);\n\n                  if (IS_NODE2) {\n                    this.request.setRequestHeader(INTERNAL_REQUEST_ID_HEADER_NAME, this.requestId);\n                  }\n\n                  return invoke();\n                }\n              });\n              break;\n            }\n\n          default:\n            {\n              return invoke();\n            }\n        }\n      }\n    });\n  }\n\n  registerEvent(eventName, listener) {\n    const prevEvents = this.events.get(eventName) || [];\n    const nextEvents = prevEvents.concat(listener);\n    this.events.set(eventName, nextEvents);\n    this.logger.info('registered event \"%s\"', eventName, listener);\n  }\n  /**\n   * Responds to the current request with the given\n   * Fetch API `Response` instance.\n   */\n\n\n  respondWith(response) {\n    this.logger.info(\"responding with a mocked response: %d %s\", response.status, response.statusText);\n    define(this.request, IS_MOCKED_RESPONSE, true);\n    define(this.request, \"status\", response.status);\n    define(this.request, \"statusText\", response.statusText);\n    define(this.request, \"responseURL\", this.url.href);\n    this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, {\n      apply: (_, __, args) => {\n        this.logger.info(\"getResponseHeader\", args[0]);\n\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info(\"headers not received yet, returning null\");\n          return null;\n        }\n\n        const headerValue = response.headers.get(args[0]);\n        this.logger.info('resolved response header \"%s\" to', args[0], headerValue);\n        return headerValue;\n      }\n    });\n    this.request.getAllResponseHeaders = new Proxy(this.request.getAllResponseHeaders, {\n      apply: () => {\n        this.logger.info(\"getAllResponseHeaders\");\n\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info(\"headers not received yet, returning empty string\");\n          return \"\";\n        }\n\n        const headersList = Array.from(response.headers.entries());\n        const allHeaders = headersList.map(_ref5 => {\n          let [headerName, headerValue] = _ref5;\n          return `${headerName}: ${headerValue}`;\n        }).join(\"\\r\\n\");\n        this.logger.info(\"resolved all response headers to\", allHeaders);\n        return allHeaders;\n      }\n    });\n    Object.defineProperties(this.request, {\n      response: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.response\n      },\n      responseText: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseText\n      },\n      responseXML: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseXML\n      }\n    });\n    const totalResponseBodyLength = response.headers.has(\"Content-Length\") ? Number(response.headers.get(\"Content-Length\")) :\n    /**\n     * @todo Infer the response body length from the response body.\n     */\n    void 0;\n    this.logger.info(\"calculated response body length\", totalResponseBodyLength);\n    this.trigger(\"loadstart\", {\n      loaded: 0,\n      total: totalResponseBodyLength\n    });\n    this.setReadyState(this.request.HEADERS_RECEIVED);\n    this.setReadyState(this.request.LOADING);\n\n    const finalizeResponse = () => {\n      this.logger.info(\"finalizing the mocked response...\");\n      this.setReadyState(this.request.DONE);\n      this.trigger(\"load\", {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength\n      });\n      this.trigger(\"loadend\", {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength\n      });\n    };\n\n    if (response.body) {\n      this.logger.info(\"mocked response has body, streaming...\");\n      const reader = response.body.getReader();\n\n      const readNextResponseBodyChunk = async () => {\n        const {\n          value,\n          done\n        } = await reader.read();\n\n        if (done) {\n          this.logger.info(\"response body stream done!\");\n          finalizeResponse();\n          return;\n        }\n\n        if (value) {\n          this.logger.info(\"read response body chunk:\", value);\n          this.responseBuffer = concatArrayBuffer(this.responseBuffer, value);\n          this.trigger(\"progress\", {\n            loaded: this.responseBuffer.byteLength,\n            total: totalResponseBodyLength\n          });\n        }\n\n        readNextResponseBodyChunk();\n      };\n\n      readNextResponseBodyChunk();\n    } else {\n      finalizeResponse();\n    }\n  }\n\n  responseBufferToText() {\n    return decodeBuffer(this.responseBuffer);\n  }\n\n  get response() {\n    this.logger.info(\"getResponse (responseType: %s)\", this.request.responseType);\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null;\n    }\n\n    switch (this.request.responseType) {\n      case \"json\":\n        {\n          const responseJson = parseJson(this.responseBufferToText());\n          this.logger.info(\"resolved response JSON\", responseJson);\n          return responseJson;\n        }\n\n      case \"arraybuffer\":\n        {\n          const arrayBuffer = toArrayBuffer(this.responseBuffer);\n          this.logger.info(\"resolved response ArrayBuffer\", arrayBuffer);\n          return arrayBuffer;\n        }\n\n      case \"blob\":\n        {\n          const mimeType = this.request.getResponseHeader(\"Content-Type\") || \"text/plain\";\n          const responseBlob = new Blob([this.responseBufferToText()], {\n            type: mimeType\n          });\n          this.logger.info(\"resolved response Blob (mime type: %s)\", responseBlob, mimeType);\n          return responseBlob;\n        }\n\n      default:\n        {\n          const responseText = this.responseBufferToText();\n          this.logger.info('resolving \"%s\" response type as text', this.request.responseType, responseText);\n          return responseText;\n        }\n    }\n  }\n\n  get responseText() {\n    invariant(this.request.responseType === \"\" || this.request.responseType === \"text\", \"InvalidStateError: The object is in invalid state.\");\n\n    if (this.request.readyState !== this.request.LOADING && this.request.readyState !== this.request.DONE) {\n      return \"\";\n    }\n\n    const responseText = this.responseBufferToText();\n    this.logger.info('getResponseText: \"%s\"', responseText);\n    return responseText;\n  }\n\n  get responseXML() {\n    invariant(this.request.responseType === \"\" || this.request.responseType === \"document\", \"InvalidStateError: The object is in invalid state.\");\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null;\n    }\n\n    const contentType = this.request.getResponseHeader(\"Content-Type\") || \"\";\n\n    if (typeof DOMParser === \"undefined\") {\n      console.warn(\"Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly.\");\n      return null;\n    }\n\n    if (isDomParserSupportedType(contentType)) {\n      return new DOMParser().parseFromString(this.responseBufferToText(), contentType);\n    }\n\n    return null;\n  }\n\n  errorWith(error2) {\n    this.logger.info(\"responding with an error\");\n    this.setReadyState(this.request.DONE);\n    this.trigger(\"error\");\n    this.trigger(\"loadend\");\n  }\n  /**\n   * Transitions this request's `readyState` to the given one.\n   */\n\n\n  setReadyState(nextReadyState) {\n    this.logger.info(\"setReadyState: %d -> %d\", this.request.readyState, nextReadyState);\n\n    if (this.request.readyState === nextReadyState) {\n      this.logger.info(\"ready state identical, skipping transition...\");\n      return;\n    }\n\n    define(this.request, \"readyState\", nextReadyState);\n    this.logger.info(\"set readyState to: %d\", nextReadyState);\n\n    if (nextReadyState !== this.request.UNSENT) {\n      this.logger.info('triggerring \"readystatechange\" event...');\n      this.trigger(\"readystatechange\");\n    }\n  }\n  /**\n   * Triggers given event on the `XMLHttpRequest` instance.\n   */\n\n\n  trigger(eventName, options) {\n    const callback = this.request[`on${eventName}`];\n    const event = createEvent(this.request, eventName, options);\n    this.logger.info('trigger \"%s\"', eventName, options || \"\");\n\n    if (typeof callback === \"function\") {\n      this.logger.info('found a direct \"%s\" callback, calling...', eventName);\n      callback.call(this.request, event);\n    }\n\n    for (const [registeredEventName, listeners] of this.events) {\n      if (registeredEventName === eventName) {\n        this.logger.info('found %d listener(s) for \"%s\" event, calling...', listeners.length, eventName);\n        listeners.forEach(listener => listener.call(this.request, event));\n      }\n    }\n  }\n  /**\n   * Converts this `XMLHttpRequest` instance into a Fetch API `Request` instance.\n   */\n\n\n  toFetchApiRequest() {\n    this.logger.info(\"converting request to a Fetch API Request...\");\n    const fetchRequest = new Request(this.url.href, {\n      method: this.method,\n      headers: this.requestHeaders,\n\n      /**\n       * @see https://xhr.spec.whatwg.org/#cross-origin-credentials\n       */\n      credentials: this.request.withCredentials ? \"include\" : \"same-origin\",\n      body: [\"GET\", \"HEAD\"].includes(this.method) ? null : this.requestBody\n    });\n    const proxyHeaders = createProxy(fetchRequest.headers, {\n      methodCall: (_ref6, invoke) => {\n        let [methodName, args] = _ref6;\n\n        switch (methodName) {\n          case \"append\":\n          case \"set\":\n            {\n              const [headerName, headerValue] = args;\n              this.request.setRequestHeader(headerName, headerValue);\n              break;\n            }\n\n          case \"delete\":\n            {\n              const [headerName] = args;\n              console.warn(`XMLHttpRequest: Cannot remove a \"${headerName}\" header from the Fetch API representation of the \"${fetchRequest.method} ${fetchRequest.url}\" request. XMLHttpRequest headers cannot be removed.`);\n              break;\n            }\n        }\n\n        return invoke();\n      }\n    });\n    define(fetchRequest, \"headers\", proxyHeaders);\n    this.logger.info(\"converted request to a Fetch API Request!\", fetchRequest);\n    return fetchRequest;\n  }\n\n};\n\nfunction toAbsoluteUrl(url) {\n  if (typeof location === \"undefined\") {\n    return new URL(url);\n  }\n\n  return new URL(url.toString(), location.href);\n}\n\nfunction define(target, property, value) {\n  Reflect.defineProperty(target, property, {\n    // Ensure writable properties to allow redefining readonly properties.\n    writable: true,\n    enumerable: true,\n    value\n  });\n}\n\nfunction createXMLHttpRequestProxy(_ref7) {\n  let {\n    emitter,\n    logger\n  } = _ref7;\n  const XMLHttpRequestProxy = new Proxy(globalThis.XMLHttpRequest, {\n    construct(target, args, newTarget) {\n      logger.info(\"constructed new XMLHttpRequest\");\n      const originalRequest = Reflect.construct(target, args, newTarget);\n      const prototypeDescriptors = Object.getOwnPropertyDescriptors(target.prototype);\n\n      for (const propertyName in prototypeDescriptors) {\n        Reflect.defineProperty(originalRequest, propertyName, prototypeDescriptors[propertyName]);\n      }\n\n      const xhrRequestController = new XMLHttpRequestController(originalRequest, logger);\n\n      xhrRequestController.onRequest = async function (_ref8) {\n        let {\n          request,\n          requestId\n        } = _ref8;\n        const {\n          interactiveRequest,\n          requestController\n        } = toInteractiveRequest(request);\n        this.logger.info(\"awaiting mocked response...\");\n        emitter.once(\"request\", _ref9 => {\n          let {\n            requestId: pendingRequestId\n          } = _ref9;\n\n          if (pendingRequestId !== requestId) {\n            return;\n          }\n\n          if (requestController.responsePromise.state === \"pending\") {\n            requestController.respondWith(void 0);\n          }\n        });\n        const resolverResult = await until(async () => {\n          this.logger.info('emitting the \"request\" event for %s listener(s)...', emitter.listenerCount(\"request\"));\n          await emitAsync(emitter, \"request\", {\n            request: interactiveRequest,\n            requestId\n          });\n          this.logger.info('all \"request\" listeners settled!');\n          const mockedResponse2 = await requestController.responsePromise;\n          this.logger.info(\"event.respondWith called with:\", mockedResponse2);\n          return mockedResponse2;\n        });\n\n        if (resolverResult.error) {\n          this.logger.info(\"request listener threw an exception, aborting request...\", resolverResult.error);\n\n          if (resolverResult.error instanceof Response) {\n            if (isResponseError(resolverResult.error)) {\n              xhrRequestController.errorWith(new TypeError(\"Network error\"));\n            } else {\n              this.respondWith(resolverResult.error);\n            }\n\n            return;\n          }\n\n          if (emitter.listenerCount(\"unhandledException\") > 0) {\n            await emitAsync(emitter, \"unhandledException\", {\n              error: resolverResult.error,\n              request,\n              requestId,\n              controller: {\n                respondWith: xhrRequestController.respondWith.bind(xhrRequestController),\n                errorWith: xhrRequestController.errorWith.bind(xhrRequestController)\n              }\n            });\n\n            if (originalRequest.readyState > XMLHttpRequest.OPENED) {\n              return;\n            }\n          }\n\n          xhrRequestController.respondWith(createServerErrorResponse(resolverResult.error));\n          return;\n        }\n\n        const mockedResponse = resolverResult.data;\n\n        if (typeof mockedResponse !== \"undefined\") {\n          this.logger.info(\"received mocked response: %d %s\", mockedResponse.status, mockedResponse.statusText);\n\n          if (isResponseError(mockedResponse)) {\n            this.logger.info(\"received a network error response, rejecting the request promise...\");\n            xhrRequestController.errorWith(new TypeError(\"Network error\"));\n            return;\n          }\n\n          return xhrRequestController.respondWith(mockedResponse);\n        }\n\n        this.logger.info(\"no mocked response received, performing request as-is...\");\n      };\n\n      xhrRequestController.onResponse = async function (_ref10) {\n        let {\n          response,\n          isMockedResponse,\n          request,\n          requestId\n        } = _ref10;\n        this.logger.info('emitting the \"response\" event for %s listener(s)...', emitter.listenerCount(\"response\"));\n        emitter.emit(\"response\", {\n          response,\n          isMockedResponse,\n          request,\n          requestId\n        });\n      };\n\n      return xhrRequestController.request;\n    }\n\n  });\n  return XMLHttpRequestProxy;\n}\n\nvar _XMLHttpRequestInterceptor = class extends Interceptor {\n  constructor() {\n    super(_XMLHttpRequestInterceptor.interceptorSymbol);\n  }\n\n  checkEnvironment() {\n    return typeof globalThis.XMLHttpRequest !== \"undefined\";\n  }\n\n  setup() {\n    const logger = this.logger.extend(\"setup\");\n    logger.info('patching \"XMLHttpRequest\" module...');\n    const PureXMLHttpRequest = globalThis.XMLHttpRequest;\n    invariant(!PureXMLHttpRequest[IS_PATCHED_MODULE], 'Failed to patch the \"XMLHttpRequest\" module: already patched.');\n    globalThis.XMLHttpRequest = createXMLHttpRequestProxy({\n      emitter: this.emitter,\n      logger: this.logger\n    });\n    logger.info('native \"XMLHttpRequest\" module patched!', globalThis.XMLHttpRequest.name);\n    Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true\n    });\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n        value: void 0\n      });\n      globalThis.XMLHttpRequest = PureXMLHttpRequest;\n      logger.info('native \"XMLHttpRequest\" module restored!', globalThis.XMLHttpRequest.name);\n    });\n  }\n\n};\n\nvar XMLHttpRequestInterceptor = _XMLHttpRequestInterceptor;\nXMLHttpRequestInterceptor.interceptorSymbol = Symbol(\"xhr\"); // src/browser/setupWorker/start/createFallbackRequestListener.ts\n\nimport { handleRequest as handleRequest2 } from '../core/utils/handleRequest.mjs';\n\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = new BatchInterceptor({\n    name: \"fallback\",\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()]\n  });\n  interceptor.on(\"request\", async _ref11 => {\n    let {\n      request,\n      requestId\n    } = _ref11;\n    const requestCloneForLogs = request.clone();\n    const response = await handleRequest2(request, requestId, context.getRequestHandlers(), options, context.emitter, {\n      onMockedResponse(_, _ref12) {\n        let {\n          handler,\n          parsedResult\n        } = _ref12;\n\n        if (!options.quiet) {\n          context.emitter.once(\"response:mocked\", _ref13 => {\n            let {\n              response: response2\n            } = _ref13;\n            handler.log({\n              request: requestCloneForLogs,\n              response: response2,\n              parsedResult\n            });\n          });\n        }\n      }\n\n    });\n\n    if (response) {\n      request.respondWith(response);\n    }\n  });\n  interceptor.on(\"response\", _ref14 => {\n    let {\n      response,\n      isMockedResponse,\n      request,\n      requestId\n    } = _ref14;\n    context.emitter.emit(isMockedResponse ? \"response:mocked\" : \"response:bypass\", {\n      response,\n      request,\n      requestId\n    });\n  });\n  interceptor.apply();\n  return interceptor;\n} // src/browser/setupWorker/start/createFallbackStart.ts\n\n\nfunction createFallbackStart(context) {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(context, options);\n    printStartMessage({\n      message: \"Mocking enabled (fallback mode).\",\n      quiet: options.quiet\n    });\n    return void 0;\n  };\n} // src/browser/setupWorker/stop/createFallbackStop.ts\n\n\nfunction createFallbackStop(context) {\n  return function stop() {\n    context.fallbackInterceptor?.dispose();\n    printStopMessage({\n      quiet: context.startOptions?.quiet\n    });\n  };\n} // src/browser/setupWorker/setupWorker.ts\n\n\nimport { devUtils as devUtils10 } from '../core/utils/internal/devUtils.mjs';\nimport { SetupApi } from '../core/SetupApi.mjs';\nimport { mergeRight as mergeRight2 } from '../core/utils/internal/mergeRight.mjs'; // src/browser/utils/supportsReadableStreamTransfer.ts\n\nfunction supportsReadableStreamTransfer() {\n  try {\n    const stream = new ReadableStream({\n      start: controller => controller.close()\n    });\n    const message = new MessageChannel();\n    message.port1.postMessage(stream, [stream]);\n    return true;\n  } catch (error2) {\n    return false;\n  }\n} // src/browser/setupWorker/setupWorker.ts\n\n\nvar SetupWorkerApi = class extends SetupApi {\n  context;\n  startHandler = null;\n  stopHandler = null;\n  listeners;\n\n  constructor() {\n    super(...arguments);\n    invariant(!isNodeProcess(), devUtils10.formatMessage(\"Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.\"));\n    this.listeners = [];\n    this.context = this.createWorkerContext();\n  }\n\n  createWorkerContext() {\n    const context = {\n      // Mocking is not considered enabled until the worker\n      // signals back the successful activation event.\n      isMockingEnabled: false,\n      startOptions: null,\n      worker: null,\n      getRequestHandlers: () => {\n        return this.handlersController.currentHandlers();\n      },\n      registration: null,\n      requests: /* @__PURE__ */new Map(),\n      emitter: this.emitter,\n      workerChannel: {\n        on: (eventType, callback) => {\n          this.context.events.addListener(navigator.serviceWorker, \"message\", event => {\n            if (event.source !== this.context.worker) {\n              return;\n            }\n\n            const message = event.data;\n\n            if (!message) {\n              return;\n            }\n\n            if (message.type === eventType) {\n              callback(event, message);\n            }\n          });\n        },\n        send: type => {\n          this.context.worker?.postMessage(type);\n        }\n      },\n      events: {\n        addListener: (target, eventType, callback) => {\n          target.addEventListener(eventType, callback);\n          this.listeners.push({\n            eventType,\n            target,\n            callback\n          });\n          return () => {\n            target.removeEventListener(eventType, callback);\n          };\n        },\n        removeAllListeners: () => {\n          for (const {\n            target,\n            eventType,\n            callback\n          } of this.listeners) {\n            target.removeEventListener(eventType, callback);\n          }\n\n          this.listeners = [];\n        },\n        once: eventType => {\n          const bindings = [];\n          return new Promise((resolve, reject) => {\n            const handleIncomingMessage = event => {\n              try {\n                const message = event.data;\n\n                if (message.type === eventType) {\n                  resolve(message);\n                }\n              } catch (error2) {\n                reject(error2);\n              }\n            };\n\n            bindings.push(this.context.events.addListener(navigator.serviceWorker, \"message\", handleIncomingMessage), this.context.events.addListener(navigator.serviceWorker, \"messageerror\", reject));\n          }).finally(() => {\n            bindings.forEach(unbind => unbind());\n          });\n        }\n      },\n      supports: {\n        serviceWorkerApi: !(\"serviceWorker\" in navigator) || location.protocol === \"file:\",\n        readableStreamTransfer: supportsReadableStreamTransfer()\n      }\n    };\n    this.startHandler = context.supports.serviceWorkerApi ? createFallbackStart(context) : createStartHandler(context);\n    this.stopHandler = context.supports.serviceWorkerApi ? createFallbackStop(context) : createStop(context);\n    return context;\n  }\n\n  async start() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options.waitUntilReady === true) {\n      devUtils10.warn('The \"waitUntilReady\" option has been deprecated. Please remove it from this \"worker.start()\" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.');\n    }\n\n    this.context.startOptions = mergeRight2(DEFAULT_START_OPTIONS, options);\n    return await this.startHandler(this.context.startOptions, options);\n  }\n\n  stop() {\n    super.dispose();\n    this.context.events.removeAllListeners();\n    this.context.emitter.removeAllListeners();\n    this.stopHandler();\n  }\n\n};\n\nfunction setupWorker() {\n  for (var _len19 = arguments.length, handlers = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n    handlers[_key19] = arguments[_key19];\n  }\n\n  return new SetupWorkerApi(...handlers);\n}\n\nexport { SetupWorkerApi, setupWorker };","map":{"version":3,"mappings":"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","names":["POSITIONALS_EXP","serializePositional","positional","flag","Number","JSON","stringify","json","test","format","message","positionals","length","positionalIndex","formattedMessage","replace","match","isEscaped","_","value","slice","join","STACK_FRAMES_TO_IGNORE","cleanErrorStack","error","stack","nextStack","split","splice","InvariantError","Error","constructor","invariant","predicate","as","ErrorConstructor","formatMessage","Reflect","construct","err","isNodeProcess","navigator","product","process","type","versions","node","devUtils","until","promise","data","catch","getAbsoluteWorkerUrl","workerUrl","URL","location","href","getWorkerByRegistration","registration","absoluteWorkerUrl","findWorker","allStates","active","installing","waiting","relevantStates","filter","state","worker","find","scriptURL","getWorkerInstance","url","options","mockRegistrations","serviceWorker","getRegistrations","then","registrations","controller","reload","existingRegistration","update","registrationResult","register","isWorkerMissing","includes","scopeUrl","scope","printStartMessage","args","quiet","console","groupCollapsed","log","workerScope","groupEnd","enableMocking","context","workerChannel","send","events","once","isMockingEnabled","warn","WorkerChannel","port","postMessage","event","rest","transfer","pruneGetRequestBody","request","method","body","parseWorkerRequest","incomingRequest","Request","RequestHandler","handleRequest","toResponseInit","createRequestListener","messageChannel","ports","requestId","payload","id","requestCloneForLogs","clone","requestClone","cache","set","requests","getRequestHandlers","emitter","onPassthroughResponse","onMockedResponse","response","handler","parsedResult","responseClone","responseCloneForLogs","responseInit","supports","readableStreamTransfer","responseStreamOrNull","responseBufferOrNull","arrayBuffer","status","statusText","headers","name","checkWorkerIntegrity","checksum","packageVersion","encoder","TextEncoder","encodeBuffer","text","encode","decodeBuffer","buffer","encoding","decoder","TextDecoder","decode","toArrayBuffer","array","byteOffset","byteLength","IS_PATCHED_MODULE","Symbol","isPropertyAccessible","obj","key","e","RESPONSE_STATUS_CODES_WITHOUT_BODY","Set","isResponseWithoutBody","has","createServerErrorResponse","Response","isResponseError","__defProp","Object","defineProperty","__export","target","all","get","enumerable","colors_exports","blue","gray","green","red","yellow","IS_NODE","Logger","prefix","LOGGER_NAME","getVariable","LOGGER_LEVEL","isLoggingEnabled","startsWith","debug","isDefinedAndNotEquals","noop","info","success","warning","only","extend","domain","logEntry","level","colors","performance2","PerformanceEntry","message2","measure","positionals2","deltaTime","timestamp","callback","createEntry","Date","customColors","entry","timestampColor","prefixColor","colorize","write","getWriter","formatTimestamp","concat","serializeInput","map","toLocaleTimeString","getMilliseconds","startTime","endTime","performance","now","toFixed","stdout","stderr","variableName","env","globalThis","toString","expected","MemoryLeakError","count","_Emitter","eventName","listenerCount","Map","maxListeners","defaultMaxListeners","hasWarnedAboutPotentialMemoryLeak","_emitInternalEvent","internalEventName","listener","emit","_getListeners","Array","prototype","apply","_removeListener","listeners","index","indexOf","_wrapOnceListener","onceListener","removeListener","setMaxListeners","getMaxListeners","eventNames","from","keys","forEach","addListener","nextListeners","memoryLeakWarning","on","prependListener","prependOnceListener","off","removeAllListeners","delete","clear","rawListeners","Emitter","INTERNAL_REQUEST_ID_HEADER_NAME","getGlobalSymbol","symbol","setGlobalSymbol","deleteGlobalSymbol","Interceptor","readyState","subscriptions","logger","description","checkEnvironment","shouldApply","runningInstance","getInstance","push","setup","setInstance","dispose","clearInstance","instance","_a","createRequestId","Math","random","BatchInterceptor","interceptors","interceptor","createResponseListener","responseJson","writable","isMockedResponse","validateWorkerScope","createStartHandler","start","customOptions","startWorkerInstance","missingWorkerMessage","host","window","clearInterval","keepAliveInterval","setInterval","startOptions","workerRegistration","pendingInstance","Promise","resolve","addEventListener","printStopMessage","createStop","stop","mergeRight","DEFAULT_START_OPTIONS","waitUntilReady","onUnhandledRequest","mockServiceWorkerUrl","createDeferredExecutor","executor","reject","result","onFulfilled","reason","queueMicrotask","rejectionReason","DeferredPromise","deferredExecutor","originalResolve","originalReject","onRejected","finally","onfinally","defineProperties","configurable","RequestController","responsePromise","respondWith","toInteractiveRequest","requestController","bind","interactiveRequest","emitAsync","listners","canParseUrl","_error","_FetchInterceptor","fetch","pureFetch","input","init","resolvedInput","origin","pendingRequestId","signal","requestAborted","errorWith","resolverResult","listenersFinished","race","mockedResponse","createNetworkError","aborted","FetchInterceptor","cause","assign","TypeError","concatArrayBuffer","left","right","Uint8Array","EventPolyfill","AT_TARGET","BUBBLING_PHASE","CAPTURING_PHASE","NONE","srcElement","currentTarget","eventPhase","isTrusted","composed","cancelable","defaultPrevented","bubbles","lengthComputable","loaded","total","timeStamp","composedPath","initEvent","preventDefault","stopPropagation","stopImmediatePropagation","ProgressEventPolyfill","SUPPORTS_PROGRESS_EVENT","ProgressEvent","createEvent","progressEvents","ProgressEventClass","findPropertySource","propertyName","hasProperty","hasOwnProperty","call","getPrototypeOf","createProxy","proxy","Proxy","optionsToProxyHandler","constructorCall","methodCall","getProperty","setProperty","newTarget","next","nextValue","propertySource","ownDescriptors","getOwnPropertyDescriptor","receiver","isDomParserSupportedType","supportedTypes","some","supportedType","parseJson","parse","createResponse","responseBodyOrNull","createHeadersFromXMLHttpReqestHeaders","getAllResponseHeaders","headersString","Headers","lines","line","trim","parts","append","IS_MOCKED_RESPONSE","XMLHttpRequestController","initialRequest","requestHeaders","responseBuffer","invoke","methodName","toAbsoluteUrl","registerEvent","requestBody","onResponse","fetchResponse","fetchRequest","toFetchApiRequest","onceRequestSettled","onRequest","LOADING","setRequestHeader","prevEvents","nextEvents","define","getResponseHeader","__","HEADERS_RECEIVED","headerValue","headersList","entries","allHeaders","headerName","responseText","responseXML","totalResponseBodyLength","trigger","setReadyState","finalizeResponse","DONE","reader","getReader","readNextResponseBodyChunk","done","read","responseBufferToText","responseType","mimeType","responseBlob","Blob","contentType","DOMParser","parseFromString","nextReadyState","UNSENT","registeredEventName","credentials","withCredentials","proxyHeaders","property","createXMLHttpRequestProxy","XMLHttpRequestProxy","XMLHttpRequest","originalRequest","prototypeDescriptors","getOwnPropertyDescriptors","xhrRequestController","OPENED","_XMLHttpRequestInterceptor","interceptorSymbol","PureXMLHttpRequest","XMLHttpRequestInterceptor","createFallbackRequestListener","createFallbackStart","fallbackInterceptor","createFallbackStop","SetupApi","supportsReadableStreamTransfer","stream","ReadableStream","close","MessageChannel","port1","SetupWorkerApi","startHandler","stopHandler","createWorkerContext","handlersController","currentHandlers","eventType","source","removeEventListener","bindings","handleIncomingMessage","unbind","serviceWorkerApi","protocol","setupWorker","handlers"],"sources":["/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/outvariant@1.4.2/node_modules/outvariant/src/format.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/outvariant@1.4.2/node_modules/outvariant/src/invariant.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/is-node-process@1.2.0/node_modules/is-node-process/src/index.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/start/createStartHandler.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@open-draft+until@2.1.0/node_modules/@open-draft/until/src/until.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/start/utils/getWorkerInstance.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/utils/getAbsoluteWorkerUrl.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/start/utils/getWorkerByRegistration.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/start/utils/enableMocking.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/start/utils/printStartMessage.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/start/utils/createMessageChannel.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/utils/pruneGetRequestBody.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/utils/parseWorkerRequest.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/start/createRequestListener.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/utils/checkWorkerIntegrity.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/utils/bufferUtils.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/glossary.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/utils/isPropertyAccessible.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/utils/responseUtils.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@open-draft+logger@0.3.0/node_modules/@open-draft/logger/lib/index.mjs","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/src/MemoryLeakError.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/src/Emitter.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/Interceptor.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/createRequestId.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/BatchInterceptor.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/start/createResponseListener.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/start/utils/validateWorkerScope.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/stop/createStop.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/stop/utils/printStopMessage.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/start/utils/prepareStartHandler.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@open-draft+deferred-promise@2.2.0/node_modules/@open-draft/deferred-promise/src/createDeferredExecutor.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@open-draft+deferred-promise@2.2.0/node_modules/@open-draft/deferred-promise/src/DeferredPromise.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/utils/RequestController.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/utils/toInteractiveRequest.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/utils/emitAsync.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/utils/canParseUrl.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/interceptors/fetch/index.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/concatArrayBuffer.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/polyfills/EventPolyfill.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/polyfills/ProgressEventPolyfill.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/createEvent.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/utils/findPropertySource.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/utils/createProxy.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/isDomParserSupportedType.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/utils/parseJson.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/createResponse.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/XMLHttpRequestController.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/XMLHttpRequestProxy.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/node_modules/.pnpm/@mswjs+interceptors@0.29.0/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/index.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/start/createFallbackRequestListener.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/start/createFallbackStart.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/stop/createFallbackStop.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/setupWorker/setupWorker.ts","/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/browser/utils/supportsReadableStreamTransfer.ts"],"sourcesContent":["const POSITIONALS_EXP = /(%?)(%([sdijo]))/g\n\nfunction serializePositional(positional: any, flag: string): any {\n  switch (flag) {\n    // Strings.\n    case 's':\n      return positional\n\n    // Digits.\n    case 'd':\n    case 'i':\n      return Number(positional)\n\n    // JSON.\n    case 'j':\n      return JSON.stringify(positional)\n\n    // Objects.\n    case 'o': {\n      // Preserve stings to prevent extra quotes around them.\n      if (typeof positional === 'string') {\n        return positional\n      }\n\n      const json = JSON.stringify(positional)\n\n      // If the positional isn't serializable, return it as-is.\n      if (json === '{}' || json === '[]' || /^\\[object .+?\\]$/.test(json)) {\n        return positional\n      }\n\n      return json\n    }\n  }\n}\n\nexport function format(message: string, ...positionals: any[]): string {\n  if (positionals.length === 0) {\n    return message\n  }\n\n  let positionalIndex = 0\n  let formattedMessage = message.replace(\n    POSITIONALS_EXP,\n    (match, isEscaped, _, flag) => {\n      const positional = positionals[positionalIndex]\n      const value = serializePositional(positional, flag)\n\n      if (!isEscaped) {\n        positionalIndex++\n        return value\n      }\n\n      return match\n    }\n  )\n\n  // Append unresolved positionals to string as-is.\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(' ')}`\n  }\n\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, '%')\n\n  return formattedMessage\n}\n","import { format } from './format'\n\nconst STACK_FRAMES_TO_IGNORE = 2\n\n/**\n * Remove the \"outvariant\" package trace from the given error.\n * This scopes down the error stack to the relevant parts\n * when used in other applications.\n */\nfunction cleanErrorStack(error: Error): void {\n  if (!error.stack) {\n    return\n  }\n\n  const nextStack = error.stack.split('\\n')\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE)\n  error.stack = nextStack.join('\\n')\n}\n\nexport class InvariantError extends Error {\n  name = 'Invariant Violation'\n\n  constructor(public readonly message: string, ...positionals: any[]) {\n    super(message)\n    this.message = format(message, ...positionals)\n    cleanErrorStack(this)\n  }\n}\n\nexport interface CustomErrorConstructor {\n  new (message: string): Error\n}\n\nexport interface CustomErrorFactory {\n  (message: string): Error\n}\n\nexport type CustomError = CustomErrorConstructor | CustomErrorFactory\n\ntype Invariant = {\n  (\n    predicate: unknown,\n    message: string,\n    ...positionals: any[]\n  ): asserts predicate\n\n  as(\n    ErrorConstructor: CustomError,\n    predicate: unknown,\n    message: string,\n    ...positionals: unknown[]\n  ): asserts predicate\n}\n\nexport const invariant: Invariant = (\n  predicate,\n  message,\n  ...positionals\n): asserts predicate => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals)\n  }\n}\n\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage = positionals.length === 0 ? message : format(message, positionals);\n    let error: Error;\n\n    try {\n      error = Reflect.construct(ErrorConstructor as CustomErrorConstructor, [formatMessage]);\n    } catch(err) {\n      error = (ErrorConstructor as CustomErrorFactory)(formatMessage);\n    }\n\n    throw error\n  }\n}\n","/**\n * Determines if the current process is a Node.js process.\n */\nexport function isNodeProcess(): boolean {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return true\n  }\n\n  if (typeof process !== 'undefined') {\n    // Electron (https://www.electronjs.org/docs/latest/api/process#processtype-readonly)\n    const type = (process as any).type\n    if (type === 'renderer' || type === 'worker') {\n      return false\n    }\n\n\n    return !!(\n      process.versions &&\n      process.versions.node\n    )\n  }\n\n  return false\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport { getWorkerInstance } from './utils/getWorkerInstance'\nimport { enableMocking } from './utils/enableMocking'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { createRequestListener } from './createRequestListener'\nimport { checkWorkerIntegrity } from '../../utils/checkWorkerIntegrity'\nimport { createResponseListener } from './createResponseListener'\nimport { validateWorkerScope } from './utils/validateWorkerScope'\n\nexport const createStartHandler = (\n  context: SetupWorkerInternalContext,\n): StartHandler => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n      context.events.removeAllListeners()\n\n      // Handle requests signaled by the worker.\n      context.workerChannel.on(\n        'REQUEST',\n        createRequestListener(context, options),\n      )\n\n      // Handle responses signaled by the worker.\n      context.workerChannel.on('RESPONSE', createResponseListener(context))\n\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker,\n      )\n\n      const [worker, registration] = instance\n\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker\n          ? devUtils.formatMessage(\n              `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n              options.serviceWorker.url,\n            )\n          : devUtils.formatMessage(\n              `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n              options.serviceWorker.url,\n              location.host,\n            )\n\n        throw new Error(missingWorkerMessage)\n      }\n\n      context.worker = worker\n      context.registration = registration\n\n      context.events.addListener(window, 'beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          context.workerChannel.send('CLIENT_CLOSED')\n        }\n        // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n        window.clearInterval(context.keepAliveInterval)\n      })\n\n      // Check if the active Service Worker has been generated\n      // by the currently installed version of MSW.\n      await checkWorkerIntegrity(context).catch((error) => {\n        devUtils.error(\n          'Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues), including the original error below.',\n        )\n        console.error(error)\n      })\n\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.send('KEEPALIVE_REQUEST'),\n        5000,\n      )\n\n      // Warn the user when loading the page that lies outside\n      // of the worker's scope.\n      validateWorkerScope(registration, context.startOptions)\n\n      return registration\n    }\n\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting\n\n        // Wait until the worker is activated.\n        // Assume the worker is already activated if there's no pending registration\n        // (i.e. when reloading the page after a successful activation).\n        if (pendingInstance) {\n          await new Promise<void>((resolve) => {\n            pendingInstance.addEventListener('statechange', () => {\n              if (pendingInstance.state === 'activated') {\n                return resolve()\n              }\n            })\n          })\n        }\n\n        // Print the activation message only after the worker has been activated.\n        await enableMocking(context, options).catch((error) => {\n          throw new Error(`Failed to enable mocking: ${error?.message}`)\n        })\n\n        return registration\n      },\n    )\n\n    return workerRegistration\n  }\n}\n","export type AsyncTuple<\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n> =\n  | {\n      error: ErrorType\n      data: null\n    }\n  | { error: null; data: DataType }\n\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * const { error, data } = await until(() => asyncAction())\n */\nexport const until = async <\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n>(\n  promise: () => Promise<DataType>,\n): Promise<AsyncTuple<ErrorType, DataType>> => {\n  try {\n    const data = await promise().catch((error) => {\n      throw error\n    })\n    return { error: null, data }\n  } catch (error) {\n    return { error, data: null }\n  }\n}\n","import { until } from '@open-draft/until'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { getAbsoluteWorkerUrl } from '../../../utils/getAbsoluteWorkerUrl'\nimport { getWorkerByRegistration } from './getWorkerByRegistration'\nimport { ServiceWorkerInstanceTuple, FindWorker } from '../../glossary'\n\n/**\n * Returns an active Service Worker instance.\n * When not found, registers a new Service Worker.\n */\nexport const getWorkerInstance = async (\n  url: string,\n  options: RegistrationOptions = {},\n  findWorker: FindWorker,\n): Promise<ServiceWorkerInstanceTuple> => {\n  // Resolve the absolute Service Worker URL.\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url)\n\n  const mockRegistrations = await navigator.serviceWorker\n    .getRegistrations()\n    .then((registrations) =>\n      registrations.filter((registration) =>\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n      ),\n    )\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    // Reload the page when it has associated workers, but no active controller.\n    // The absence of a controller can mean either:\n    // - page has no Service Worker associated with it\n    // - page has been hard-reloaded and its workers won't be used until the next reload.\n    // Since we've checked that there are registrations associated with this page,\n    // at this point we are sure it's hard reload that falls into this clause.\n    location.reload()\n  }\n\n  const [existingRegistration] = mockRegistrations\n\n  if (existingRegistration) {\n    // When the Service Worker is registered, update it and return the reference.\n    return existingRegistration.update().then(() => {\n      return [\n        getWorkerByRegistration(\n          existingRegistration,\n          absoluteWorkerUrl,\n          findWorker,\n        ),\n        existingRegistration,\n      ]\n    })\n  }\n\n  // When the Service Worker wasn't found, register it anew and return the reference.\n  const registrationResult = await until<Error, ServiceWorkerInstanceTuple>(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options)\n      return [\n        // Compare existing worker registration by its worker URL,\n        // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration,\n      ]\n    },\n  )\n\n  // Handle Service Worker registration errors.\n  if (registrationResult.error) {\n    const isWorkerMissing = registrationResult.error.message.includes('(404)')\n\n    // Produce a custom error message when given a non-existing Service Worker url.\n    // Suggest developers to check their setup.\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || '/', location.href)\n\n      throw new Error(\n        devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`),\n      )\n    }\n\n    // Fallback error message for any other registration errors.\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to register the Service Worker:\\n\\n%s',\n        registrationResult.error.message,\n      ),\n    )\n  }\n\n  return registrationResult.data\n}\n","/**\n * Returns an absolute Service Worker URL based on the given\n * relative URL (known during the registration).\n */\nexport function getAbsoluteWorkerUrl(workerUrl: string): string {\n  return new URL(workerUrl, location.href).href\n}\n","import { FindWorker } from '../../glossary'\n\n/**\n * Attempts to resolve a Service Worker instance from a given registration,\n * regardless of its state (active, installing, waiting).\n */\nexport function getWorkerByRegistration(\n  registration: ServiceWorkerRegistration,\n  absoluteWorkerUrl: string,\n  findWorker: FindWorker,\n): ServiceWorker | null {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting,\n  ]\n  const relevantStates = allStates.filter((state): state is ServiceWorker => {\n    return state != null\n  })\n  const worker = relevantStates.find((worker) => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl)\n  })\n\n  return worker || null\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport { StartOptions, SetupWorkerInternalContext } from '../../glossary'\nimport { printStartMessage } from './printStartMessage'\n\n/**\n * Signals the worker to enable the interception of requests.\n */\nexport async function enableMocking(\n  context: SetupWorkerInternalContext,\n  options: StartOptions,\n) {\n  context.workerChannel.send('MOCK_ACTIVATE')\n  await context.events.once('MOCKING_ENABLED')\n\n  // Warn the developer on multiple \"worker.start()\" calls.\n  // While this will not affect the worker in any way,\n  // it likely indicates an issue with the developer's code.\n  if (context.isMockingEnabled) {\n    devUtils.warn(\n      `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`,\n    )\n    return\n  }\n\n  context.isMockingEnabled = true\n\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: context.registration?.scope,\n    workerUrl: context.worker?.scriptURL,\n  })\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\n\nexport interface PrintStartMessageArgs {\n  quiet?: boolean\n  message?: string\n  workerUrl?: string\n  workerScope?: string\n}\n\n/**\n * Prints a worker activation message in the browser's console.\n */\nexport function printStartMessage(args: PrintStartMessageArgs = {}) {\n  if (args.quiet) {\n    return\n  }\n\n  const message = args.message || 'Mocking enabled.'\n\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    'color:orangered;font-weight:bold;',\n  )\n  console.log(\n    '%cDocumentation: %chttps://mswjs.io/docs',\n    'font-weight:bold',\n    'font-weight:normal',\n  )\n  console.log('Found an issue? https://github.com/mswjs/msw/issues')\n\n  if (args.workerUrl) {\n    console.log('Worker script URL:', args.workerUrl)\n  }\n\n  if (args.workerScope) {\n    console.log('Worker scope:', args.workerScope)\n  }\n\n  console.groupEnd()\n}\n","import {\n  StringifiedResponse,\n  ServiceWorkerIncomingEventsMap,\n} from '../../glossary'\n\nexport interface ServiceWorkerMessage<\n  EventType extends keyof ServiceWorkerIncomingEventsMap,\n  EventPayload,\n> {\n  type: EventType\n  payload: EventPayload\n}\n\ninterface WorkerChannelEventsMap {\n  MOCK_RESPONSE: [\n    data: StringifiedResponse,\n    transfer?: [ReadableStream<Uint8Array>],\n  ]\n  PASSTHROUGH: []\n}\n\nexport class WorkerChannel {\n  constructor(private readonly port: MessagePort) {}\n\n  public postMessage<Event extends keyof WorkerChannelEventsMap>(\n    event: Event,\n    ...rest: WorkerChannelEventsMap[Event]\n  ): void {\n    const [data, transfer] = rest\n    this.port.postMessage({ type: event, data }, { transfer })\n  }\n}\n","import type { ServiceWorkerIncomingRequest } from '../setupWorker/glossary'\n\ntype Input = Pick<ServiceWorkerIncomingRequest, 'method' | 'body'>\n\n/**\n * Ensures that an empty GET request body is always represented as `undefined`.\n */\nexport function pruneGetRequestBody(\n  request: Input,\n): ServiceWorkerIncomingRequest['body'] {\n  // Force HEAD/GET request body to always be empty.\n  // The worker reads any request's body as ArrayBuffer,\n  // and you cannot re-construct a GET/HEAD Request\n  // with an ArrayBuffer, even if empty. Also note that\n  // \"request.body\" is always undefined in the worker.\n  if (['HEAD', 'GET'].includes(request.method)) {\n    return undefined\n  }\n\n  return request.body\n}\n","import { pruneGetRequestBody } from './pruneGetRequestBody'\nimport type { ServiceWorkerIncomingRequest } from '../setupWorker/glossary'\n\n/**\n * Converts a given request received from the Service Worker\n * into a Fetch `Request` instance.\n */\nexport function parseWorkerRequest(\n  incomingRequest: ServiceWorkerIncomingRequest,\n): Request {\n  return new Request(incomingRequest.url, {\n    ...incomingRequest,\n    body: pruneGetRequestBody(incomingRequest),\n  })\n}\n","import {\n  StartOptions,\n  SetupWorkerInternalContext,\n  ServiceWorkerIncomingEventsMap,\n} from '../glossary'\nimport {\n  ServiceWorkerMessage,\n  WorkerChannel,\n} from './utils/createMessageChannel'\nimport { parseWorkerRequest } from '../../utils/parseWorkerRequest'\nimport { RequestHandler } from '~/core/handlers/RequestHandler'\nimport { handleRequest } from '~/core/utils/handleRequest'\nimport { RequiredDeep } from '~/core/typeUtils'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { toResponseInit } from '~/core/utils/toResponseInit'\n\nexport const createRequestListener = (\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n) => {\n  return async (\n    event: MessageEvent,\n    message: ServiceWorkerMessage<\n      'REQUEST',\n      ServiceWorkerIncomingEventsMap['REQUEST']\n    >,\n  ) => {\n    const messageChannel = new WorkerChannel(event.ports[0])\n\n    const requestId = message.payload.id\n    const request = parseWorkerRequest(message.payload)\n    const requestCloneForLogs = request.clone()\n\n    // Make this the first requets clone before the\n    // request resolution pipeline even starts.\n    // Store the clone in cache so the first matching\n    // request handler would skip the cloning phase.\n    const requestClone = request.clone()\n    RequestHandler.cache.set(request, requestClone)\n    context.requests.set(requestId, requestClone)\n\n    try {\n      await handleRequest(\n        request,\n        requestId,\n        context.getRequestHandlers(),\n        options,\n        context.emitter,\n        {\n          onPassthroughResponse() {\n            messageChannel.postMessage('PASSTHROUGH')\n          },\n          async onMockedResponse(response, { handler, parsedResult }) {\n            // Clone the mocked response so its body could be read\n            // to buffer to be sent to the worker and also in the\n            // \".log()\" method of the request handler.\n            const responseClone = response.clone()\n            const responseCloneForLogs = response.clone()\n            const responseInit = toResponseInit(response)\n\n            /**\n             * @note Safari doesn't support transferring a \"ReadableStream\".\n             * Check that the browser supports that before sending it to the worker.\n             */\n            if (context.supports.readableStreamTransfer) {\n              const responseStreamOrNull = response.body\n\n              messageChannel.postMessage(\n                'MOCK_RESPONSE',\n                {\n                  ...responseInit,\n                  body: responseStreamOrNull,\n                },\n                responseStreamOrNull ? [responseStreamOrNull] : undefined,\n              )\n            } else {\n              /**\n               * @note If we are here, this means the current environment doesn't\n               * support \"ReadableStream\" as transferable. In that case,\n               * attempt to read the non-empty response body as ArrayBuffer, if it's not empty.\n               * @see https://github.com/mswjs/msw/issues/1827\n               */\n              const responseBufferOrNull =\n                response.body === null\n                  ? null\n                  : await responseClone.arrayBuffer()\n\n              messageChannel.postMessage('MOCK_RESPONSE', {\n                ...responseInit,\n                body: responseBufferOrNull,\n              })\n            }\n\n            if (!options.quiet) {\n              context.emitter.once('response:mocked', () => {\n                handler.log({\n                  request: requestCloneForLogs,\n                  response: responseCloneForLogs,\n                  parsedResult,\n                })\n              })\n            }\n          },\n        },\n      )\n    } catch (error) {\n      if (error instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,\n          request.method,\n          request.url,\n          error.stack ?? error,\n        )\n\n        // Treat all other exceptions in a request handler as unintended,\n        // alerting that there is a problem that needs fixing.\n        messageChannel.postMessage('MOCK_RESPONSE', {\n          status: 500,\n          statusText: 'Request Handler Error',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          }),\n        })\n      }\n    }\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport type { SetupWorkerInternalContext } from '../setupWorker/glossary'\n\n/**\n * Check whether the registered Service Worker has been\n * generated by the installed version of the library.\n * Prints a warning message if the worker scripts mismatch.\n */\nexport async function checkWorkerIntegrity(\n  context: SetupWorkerInternalContext,\n): Promise<void> {\n  // Request the integrity checksum from the registered worker.\n  context.workerChannel.send('INTEGRITY_CHECK_REQUEST')\n\n  const { payload } = await context.events.once('INTEGRITY_CHECK_RESPONSE')\n\n  // Compare the response from the Service Worker and the\n  // global variable set during the build.\n\n  // The integrity is validated based on the worker script's checksum\n  // that's derived from its minified content during the build.\n  // The \"SERVICE_WORKER_CHECKSUM\" global variable is injected by the build.\n  if (payload.checksum !== SERVICE_WORKER_CHECKSUM) {\n    devUtils.warn(\n      `The currently registered Service Worker has been generated by a different version of MSW (${payload.packageVersion}) and may not be fully compatible with the installed version.\n\nIt's recommended you update your worker script by running this command:\n\n  \\u2022 npx msw init <PUBLIC_DIR>\n\nYou can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`,\n    )\n  }\n}\n","const encoder = new TextEncoder()\n\nexport function encodeBuffer(text: string): Uint8Array {\n  return encoder.encode(text)\n}\n\nexport function decodeBuffer(buffer: ArrayBuffer, encoding?: string): string {\n  const decoder = new TextDecoder(encoding)\n  return decoder.decode(buffer)\n}\n\n/**\n * Create an `ArrayBuffer` from the given `Uint8Array`.\n * Takes the byte offset into account to produce the right buffer\n * in the case when the buffer is bigger than the data view.\n */\nexport function toArrayBuffer(array: Uint8Array): ArrayBuffer {\n  return array.buffer.slice(\n    array.byteOffset,\n    array.byteOffset + array.byteLength\n  )\n}\n","import type { InteractiveRequest } from './utils/toInteractiveRequest'\n\nexport const IS_PATCHED_MODULE: unique symbol = Symbol('isPatchedModule')\n\nexport type RequestCredentials = 'omit' | 'include' | 'same-origin'\n\nexport type HttpRequestEventMap = {\n  request: [\n    args: {\n      request: InteractiveRequest\n      requestId: string\n    }\n  ]\n  response: [\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ]\n  unhandledException: [\n    args: {\n      error: unknown\n      request: Request\n      requestId: string\n      controller: {\n        respondWith(response: Response): void\n        errorWith(error?: Error): void\n      }\n    }\n  ]\n}\n","/**\n * A function that validates if property access is possible on an object\n * without throwing. It returns `true` if the property access is possible\n * and `false` otherwise.\n *\n * Environments like miniflare will throw on property access on certain objects\n * like Request and Response, for unimplemented properties.\n */\nexport function isPropertyAccessible<Obj extends Record<string, any>>(\n  obj: Obj,\n  key: keyof Obj\n) {\n  try {\n    obj[key]\n    return true\n  } catch {\n    return false\n  }\n}\n","import { isPropertyAccessible } from './isPropertyAccessible'\n\n/**\n * Response status codes for responses that cannot have body.\n * @see https://fetch.spec.whatwg.org/#statuses\n */\nexport const RESPONSE_STATUS_CODES_WITHOUT_BODY = new Set([\n  101, 103, 204, 205, 304,\n])\n\n/**\n * Returns a boolean indicating whether the given response status\n * code represents a response that cannot have a body.\n */\nexport function isResponseWithoutBody(status: number): boolean {\n  return RESPONSE_STATUS_CODES_WITHOUT_BODY.has(status)\n}\n\n/**\n * Creates a generic 500 Unhandled Exception response.\n */\nexport function createServerErrorResponse(body: unknown): Response {\n  return new Response(\n    JSON.stringify(\n      body instanceof Error\n        ? {\n            name: body.name,\n            message: body.message,\n            stack: body.stack,\n          }\n        : body\n    ),\n    {\n      status: 500,\n      statusText: 'Unhandled Exception',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    }\n  )\n}\n\n/**\n * Checks if the given response is a `Response.error()`.\n *\n * @note Some environments, like Miniflare (Cloudflare) do not\n * implement the \"Response.type\" property and throw on its access.\n * Safely check if we can access \"type\" on \"Response\" before continuing.\n * @see https://github.com/mswjs/msw/issues/1834\n */\nexport function isResponseError(\n  response: Response\n): response is Response & { type: 'error' } {\n  return isPropertyAccessible(response, 'type') && response.type === 'error'\n}\n","var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/index.ts\nimport { isNodeProcess } from \"is-node-process\";\nimport { format } from \"outvariant\";\n\n// src/colors.ts\nvar colors_exports = {};\n__export(colors_exports, {\n  blue: () => blue,\n  gray: () => gray,\n  green: () => green,\n  red: () => red,\n  yellow: () => yellow\n});\nfunction yellow(text) {\n  return `\\x1B[33m${text}\\x1B[0m`;\n}\nfunction blue(text) {\n  return `\\x1B[34m${text}\\x1B[0m`;\n}\nfunction gray(text) {\n  return `\\x1B[90m${text}\\x1B[0m`;\n}\nfunction red(text) {\n  return `\\x1B[31m${text}\\x1B[0m`;\n}\nfunction green(text) {\n  return `\\x1B[32m${text}\\x1B[0m`;\n}\n\n// src/index.ts\nvar IS_NODE = isNodeProcess();\nvar Logger = class {\n  constructor(name) {\n    this.name = name;\n    this.prefix = `[${this.name}]`;\n    const LOGGER_NAME = getVariable(\"DEBUG\");\n    const LOGGER_LEVEL = getVariable(\"LOG_LEVEL\");\n    const isLoggingEnabled = LOGGER_NAME === \"1\" || LOGGER_NAME === \"true\" || typeof LOGGER_NAME !== \"undefined\" && this.name.startsWith(LOGGER_NAME);\n    if (isLoggingEnabled) {\n      this.debug = isDefinedAndNotEquals(LOGGER_LEVEL, \"debug\") ? noop : this.debug;\n      this.info = isDefinedAndNotEquals(LOGGER_LEVEL, \"info\") ? noop : this.info;\n      this.success = isDefinedAndNotEquals(LOGGER_LEVEL, \"success\") ? noop : this.success;\n      this.warning = isDefinedAndNotEquals(LOGGER_LEVEL, \"warning\") ? noop : this.warning;\n      this.error = isDefinedAndNotEquals(LOGGER_LEVEL, \"error\") ? noop : this.error;\n    } else {\n      this.info = noop;\n      this.success = noop;\n      this.warning = noop;\n      this.error = noop;\n      this.only = noop;\n    }\n  }\n  prefix;\n  extend(domain) {\n    return new Logger(`${this.name}:${domain}`);\n  }\n  /**\n   * Print a debug message.\n   * @example\n   * logger.debug('no duplicates found, creating a document...')\n   */\n  debug(message, ...positionals) {\n    this.logEntry({\n      level: \"debug\",\n      message: gray(message),\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"gray\"\n      }\n    });\n  }\n  /**\n   * Print an info message.\n   * @example\n   * logger.info('start parsing...')\n   */\n  info(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"blue\"\n      }\n    });\n    const performance2 = new PerformanceEntry();\n    return (message2, ...positionals2) => {\n      performance2.measure();\n      this.logEntry({\n        level: \"info\",\n        message: `${message2} ${gray(`${performance2.deltaTime}ms`)}`,\n        positionals: positionals2,\n        prefix: this.prefix,\n        colors: {\n          prefix: \"blue\"\n        }\n      });\n    };\n  }\n  /**\n   * Print a success message.\n   * @example\n   * logger.success('successfully created document')\n   */\n  success(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: `\\u2714 ${this.prefix}`,\n      colors: {\n        timestamp: \"green\",\n        prefix: \"green\"\n      }\n    });\n  }\n  /**\n   * Print a warning.\n   * @example\n   * logger.warning('found legacy document format')\n   */\n  warning(message, ...positionals) {\n    this.logEntry({\n      level: \"warning\",\n      message,\n      positionals,\n      prefix: `\\u26A0 ${this.prefix}`,\n      colors: {\n        timestamp: \"yellow\",\n        prefix: \"yellow\"\n      }\n    });\n  }\n  /**\n   * Print an error message.\n   * @example\n   * logger.error('something went wrong')\n   */\n  error(message, ...positionals) {\n    this.logEntry({\n      level: \"error\",\n      message,\n      positionals,\n      prefix: `\\u2716 ${this.prefix}`,\n      colors: {\n        timestamp: \"red\",\n        prefix: \"red\"\n      }\n    });\n  }\n  /**\n   * Execute the given callback only when the logging is enabled.\n   * This is skipped in its entirety and has no runtime cost otherwise.\n   * This executes regardless of the log level.\n   * @example\n   * logger.only(() => {\n   *   logger.info('additional info')\n   * })\n   */\n  only(callback) {\n    callback();\n  }\n  createEntry(level, message) {\n    return {\n      timestamp: /* @__PURE__ */ new Date(),\n      level,\n      message\n    };\n  }\n  logEntry(args) {\n    const {\n      level,\n      message,\n      prefix,\n      colors: customColors,\n      positionals = []\n    } = args;\n    const entry = this.createEntry(level, message);\n    const timestampColor = customColors?.timestamp || \"gray\";\n    const prefixColor = customColors?.prefix || \"gray\";\n    const colorize = {\n      timestamp: colors_exports[timestampColor],\n      prefix: colors_exports[prefixColor]\n    };\n    const write = this.getWriter(level);\n    write(\n      [colorize.timestamp(this.formatTimestamp(entry.timestamp))].concat(prefix != null ? colorize.prefix(prefix) : []).concat(serializeInput(message)).join(\" \"),\n      ...positionals.map(serializeInput)\n    );\n  }\n  formatTimestamp(timestamp) {\n    return `${timestamp.toLocaleTimeString(\n      \"en-GB\"\n    )}:${timestamp.getMilliseconds()}`;\n  }\n  getWriter(level) {\n    switch (level) {\n      case \"debug\":\n      case \"success\":\n      case \"info\": {\n        return log;\n      }\n      case \"warning\": {\n        return warn;\n      }\n      case \"error\": {\n        return error;\n      }\n    }\n  }\n};\nvar PerformanceEntry = class {\n  startTime;\n  endTime;\n  deltaTime;\n  constructor() {\n    this.startTime = performance.now();\n  }\n  measure() {\n    this.endTime = performance.now();\n    const deltaTime = this.endTime - this.startTime;\n    this.deltaTime = deltaTime.toFixed(2);\n  }\n};\nvar noop = () => void 0;\nfunction log(message, ...positionals) {\n  if (IS_NODE) {\n    process.stdout.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.log(message, ...positionals);\n}\nfunction warn(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.warn(message, ...positionals);\n}\nfunction error(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.error(message, ...positionals);\n}\nfunction getVariable(variableName) {\n  if (IS_NODE) {\n    return process.env[variableName];\n  }\n  return globalThis[variableName]?.toString();\n}\nfunction isDefinedAndNotEquals(value, expected) {\n  return value !== void 0 && value !== expected;\n}\nfunction serializeInput(message) {\n  if (typeof message === \"undefined\") {\n    return \"undefined\";\n  }\n  if (message === null) {\n    return \"null\";\n  }\n  if (typeof message === \"string\") {\n    return message;\n  }\n  if (typeof message === \"object\") {\n    return JSON.stringify(message);\n  }\n  return message.toString();\n}\nexport {\n  Logger\n};\n","import type { Emitter } from './Emitter'\n\nexport class MemoryLeakError extends Error {\n  constructor(\n    public readonly emitter: Emitter<any>,\n    public readonly type: string | number | symbol,\n    public readonly count: number\n  ) {\n    super(\n      `Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`\n    )\n    this.name = 'MaxListenersExceededWarning'\n  }\n}\n","import { MemoryLeakError } from './MemoryLeakError'\n\nexport type EventMap = {\n  [eventName: string]: Array<unknown>\n}\n\nexport type InternalEventNames = 'newListener' | 'removeListener'\n\nexport type InternalListener<Events extends EventMap> = Listener<\n  [eventName: keyof Events, listener: Listener<Array<unknown>>]\n>\n\nexport type Listener<Data extends Array<unknown>> = (...data: Data) => void\n\n/**\n * Node.js-compatible implementation of `EventEmitter`.\n *\n * @example\n * const emitter = new Emitter<{ hello: [string] }>()\n * emitter.on('hello', (name) => console.log(name))\n * emitter.emit('hello', 'John')\n */\nexport class Emitter<Events extends EventMap> {\n  private events: Map<keyof Events, Array<Listener<any>>>\n  private maxListeners: number\n  private hasWarnedAboutPotentialMemoryLeak: boolean\n\n  static defaultMaxListeners = 10\n\n  static listenerCount<Events extends EventMap>(\n    emitter: Emitter<EventMap>,\n    eventName: keyof Events\n  ): number {\n    return emitter.listenerCount<any>(eventName)\n  }\n\n  constructor() {\n    this.events = new Map()\n    this.maxListeners = Emitter.defaultMaxListeners\n    this.hasWarnedAboutPotentialMemoryLeak = false\n  }\n\n  private _emitInternalEvent(\n    internalEventName: InternalEventNames,\n    eventName: keyof Events,\n    listener: Listener<Array<unknown>>\n  ): void {\n    this.emit(\n      internalEventName,\n      // Anything to make TypeScript happy.\n      ...([eventName, listener] as Events['newListener'] &\n        Events['removeListener'])\n    )\n  }\n\n  private _getListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Array<unknown>>> {\n    // Always return a copy of the listeners array\n    // so they are fixed at the time of the \"_getListeners\" call.\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || []\n  }\n\n  private _removeListener<EventName extends keyof Events>(\n    listeners: Array<Listener<Events[EventName]>>,\n    listener: Listener<Events[EventName]>\n  ): Array<Listener<Events[EventName]>> {\n    const index = listeners.indexOf(listener)\n\n    if (index > -1) {\n      listeners.splice(index, 1)\n    }\n\n    return []\n  }\n\n  private _wrapOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): Listener<Events[EventName]> {\n    const onceListener = (...data: Events[keyof Events]) => {\n      this.removeListener(eventName, onceListener)\n\n      /**\n       * @note Return the result of the original listener.\n       * This way this wrapped preserves listeners that are async.\n       */\n      return listener.apply(this, data)\n    }\n\n    // Inherit the name of the original listener.\n    Object.defineProperty(onceListener, 'name', { value: listener.name })\n\n    return onceListener\n  }\n\n  public setMaxListeners(maxListeners: number): this {\n    this.maxListeners = maxListeners\n    return this\n  }\n\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  public getMaxListeners(): number {\n    return this.maxListeners\n  }\n\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  public eventNames(): Array<keyof Events> {\n    return Array.from(this.events.keys())\n  }\n\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  public emit<EventName extends keyof Events>(\n    eventName: EventName,\n    ...data: Events[EventName]\n  ): boolean {\n    const listeners = this._getListeners(eventName)\n    listeners.forEach((listener) => {\n      listener.apply(this, data)\n    })\n\n    return listeners.length > 0\n  }\n\n  public addListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public addListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public addListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: InternalListener<Events> | Listener<Events[any]>\n  ): this {\n    // Emit the `newListener` event before adding the listener.\n    this._emitInternalEvent('newListener', eventName, listener)\n\n    const nextListeners = this._getListeners(eventName).concat(listener)\n    this.events.set(eventName, nextListeners)\n\n    if (\n      this.maxListeners > 0 &&\n      this.listenerCount(eventName) > this.maxListeners &&\n      !this.hasWarnedAboutPotentialMemoryLeak\n    ) {\n      this.hasWarnedAboutPotentialMemoryLeak = true\n\n      const memoryLeakWarning = new MemoryLeakError(\n        this,\n        eventName,\n        this.listenerCount(eventName)\n      )\n      console.warn(memoryLeakWarning)\n    }\n\n    return this\n  }\n\n  public on(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: 'removeListener' | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(eventName, listener)\n  }\n\n  public once(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: InternalEventNames | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public prependListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners)\n      this.events.set(eventName, nextListeners)\n    } else {\n      this.events.set(eventName, listeners.concat(listener))\n    }\n\n    return this\n  }\n\n  public prependOnceListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependOnceListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.prependListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public removeListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public removeListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public removeListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener)\n      this.events.set(eventName, listeners)\n\n      // Emit the `removeListener` event after removing the listener.\n      this._emitInternalEvent('removeListener', eventName, listener)\n    }\n\n    return this\n  }\n\n  public off(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public off<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  public off(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.removeListener(eventName, listener)\n  }\n\n  public removeAllListeners(eventName?: InternalEventNames): this\n  public removeAllListeners<EventName extends keyof Events>(\n    eventName?: EventName\n  ): this\n  public removeAllListeners(\n    eventName?: InternalEventNames | keyof Events\n  ): this {\n    if (eventName) {\n      this.events.delete(eventName)\n    } else {\n      this.events.clear()\n    }\n\n    return this\n  }\n\n  public listeners(eventName: InternalEventNames): Array<Listener<any>>\n  public listeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>>\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  public listeners(eventName: InternalEventNames | keyof Events) {\n    return Array.from(this._getListeners(eventName))\n  }\n\n  public listenerCount(eventName: InternalEventNames): number\n  public listenerCount<EventName extends keyof Events>(\n    eventName: EventName\n  ): number\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  public listenerCount(eventName: InternalEventNames | keyof Events): number {\n    return this._getListeners(eventName).length\n  }\n\n  public rawListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>> {\n    return this.listeners(eventName)\n  }\n}\n","import { Logger } from '@open-draft/logger'\nimport { Emitter, Listener } from 'strict-event-emitter'\n\nexport type InterceptorEventMap = Record<string, any>\nexport type InterceptorSubscription = () => void\n\n/**\n * Request header name to detect when a single request\n * is being handled by nested interceptors (XHR -> ClientRequest).\n * Obscure by design to prevent collisions with user-defined headers.\n * Ideally, come up with the Interceptor-level mechanism for this.\n * @see https://github.com/mswjs/interceptors/issues/378\n */\nexport const INTERNAL_REQUEST_ID_HEADER_NAME =\n  'x-interceptors-internal-request-id'\n\nexport function getGlobalSymbol<V>(symbol: Symbol): V | undefined {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  )\n}\n\nfunction setGlobalSymbol(symbol: Symbol, value: any): void {\n  // @ts-ignore\n  globalThis[symbol] = value\n}\n\nexport function deleteGlobalSymbol(symbol: Symbol): void {\n  // @ts-ignore\n  delete globalThis[symbol]\n}\n\nexport enum InterceptorReadyState {\n  INACTIVE = 'INACTIVE',\n  APPLYING = 'APPLYING',\n  APPLIED = 'APPLIED',\n  DISPOSING = 'DISPOSING',\n  DISPOSED = 'DISPOSED',\n}\n\nexport type ExtractEventNames<Events extends Record<string, any>> =\n  Events extends Record<infer EventName, any> ? EventName : never\n\nexport class Interceptor<Events extends InterceptorEventMap> {\n  protected emitter: Emitter<Events>\n  protected subscriptions: Array<InterceptorSubscription>\n  protected logger: Logger\n\n  public readyState: InterceptorReadyState\n\n  constructor(private readonly symbol: symbol) {\n    this.readyState = InterceptorReadyState.INACTIVE\n\n    this.emitter = new Emitter()\n    this.subscriptions = []\n    this.logger = new Logger(symbol.description!)\n\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0)\n\n    this.logger.info('constructing the interceptor...')\n  }\n\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  protected checkEnvironment(): boolean {\n    return true\n  }\n\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  public apply(): void {\n    const logger = this.logger.extend('apply')\n    logger.info('applying the interceptor...')\n\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      logger.info('intercepted already applied!')\n      return\n    }\n\n    const shouldApply = this.checkEnvironment()\n\n    if (!shouldApply) {\n      logger.info('the interceptor cannot be applied in this environment!')\n      return\n    }\n\n    this.readyState = InterceptorReadyState.APPLYING\n\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    const runningInstance = this.getInstance()\n\n    if (runningInstance) {\n      logger.info('found a running instance, reusing...')\n\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event)\n\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener)\n\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener)\n          logger.info('removed proxied \"%s\" listener!', event)\n        })\n\n        return this\n      }\n\n      this.readyState = InterceptorReadyState.APPLIED\n\n      return\n    }\n\n    logger.info('no running instance found, setting up a new instance...')\n\n    // Setup the interceptor.\n    this.setup()\n\n    // Store the newly applied interceptor instance globally.\n    this.setInstance()\n\n    this.readyState = InterceptorReadyState.APPLIED\n  }\n\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  protected setup(): void {}\n\n  /**\n   * Listen to the interceptor's public events.\n   */\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    const logger = this.logger.extend('on')\n\n    if (\n      this.readyState === InterceptorReadyState.DISPOSING ||\n      this.readyState === InterceptorReadyState.DISPOSED\n    ) {\n      logger.info('cannot listen to events, already disposed!')\n      return this\n    }\n\n    logger.info('adding \"%s\" event listener:', event, listener)\n\n    this.emitter.on(event, listener)\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.once(event, listener)\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.off(event, listener)\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName\n  ): this {\n    this.emitter.removeAllListeners(event)\n    return this\n  }\n\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  public dispose(): void {\n    const logger = this.logger.extend('dispose')\n\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      logger.info('cannot dispose, already disposed!')\n      return\n    }\n\n    logger.info('disposing the interceptor...')\n    this.readyState = InterceptorReadyState.DISPOSING\n\n    if (!this.getInstance()) {\n      logger.info('no interceptors running, skipping dispose...')\n      return\n    }\n\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance()\n\n    logger.info('global symbol deleted:', getGlobalSymbol(this.symbol))\n\n    if (this.subscriptions.length > 0) {\n      logger.info('disposing of %d subscriptions...', this.subscriptions.length)\n\n      for (const dispose of this.subscriptions) {\n        dispose()\n      }\n\n      this.subscriptions = []\n\n      logger.info('disposed of all subscriptions!', this.subscriptions.length)\n    }\n\n    this.emitter.removeAllListeners()\n    logger.info('destroyed the listener!')\n\n    this.readyState = InterceptorReadyState.DISPOSED\n  }\n\n  private getInstance(): this | undefined {\n    const instance = getGlobalSymbol<this>(this.symbol)\n    this.logger.info('retrieved global instance:', instance?.constructor?.name)\n    return instance\n  }\n\n  private setInstance(): void {\n    setGlobalSymbol(this.symbol, this)\n    this.logger.info('set global instance!', this.symbol.description)\n  }\n\n  private clearInstance(): void {\n    deleteGlobalSymbol(this.symbol)\n    this.logger.info('cleared global instance!', this.symbol.description)\n  }\n}\n","/**\n * Generate a random ID string to represent a request.\n * @example\n * createRequestId()\n * // \"f774b6c9c600f\"\n */\nexport function createRequestId(): string {\n  return Math.random().toString(16).slice(2)\n}\n","import { EventMap, Listener } from 'strict-event-emitter'\nimport { Interceptor, ExtractEventNames } from './Interceptor'\n\nexport interface BatchInterceptorOptions<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> {\n  name: string\n  interceptors: InterceptorList\n}\n\nexport type ExtractEventMapType<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> = InterceptorList extends ReadonlyArray<infer InterceptorType>\n  ? InterceptorType extends Interceptor<infer EventMap>\n    ? EventMap\n    : never\n  : never\n\n/**\n * A batch interceptor that exposes a single interface\n * to apply and operate with multiple interceptors at once.\n */\nexport class BatchInterceptor<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>,\n  Events extends EventMap = ExtractEventMapType<InterceptorList>\n> extends Interceptor<Events> {\n  static symbol: symbol\n\n  private interceptors: InterceptorList\n\n  constructor(options: BatchInterceptorOptions<InterceptorList>) {\n    BatchInterceptor.symbol = Symbol(options.name)\n    super(BatchInterceptor.symbol)\n    this.interceptors = options.interceptors\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('applying all %d interceptors...', this.interceptors.length)\n\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name)\n      interceptor.apply()\n\n      logger.info('adding interceptor dispose subscription')\n      this.subscriptions.push(() => interceptor.dispose())\n    }\n  }\n\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    // Instead of adding a listener to the batch interceptor,\n    // propagate the listener to each of the individual interceptors.\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener)\n    }\n\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener)\n    }\n\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener)\n    }\n\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName | undefined\n  ): this {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event)\n    }\n\n    return this\n  }\n}\n","import type {\n  ServiceWorkerIncomingEventsMap,\n  SetupWorkerInternalContext,\n} from '../glossary'\nimport type { ServiceWorkerMessage } from './utils/createMessageChannel'\nimport { isResponseWithoutBody } from '@mswjs/interceptors'\n\nexport function createResponseListener(context: SetupWorkerInternalContext) {\n  return (\n    _: MessageEvent,\n    message: ServiceWorkerMessage<\n      'RESPONSE',\n      ServiceWorkerIncomingEventsMap['RESPONSE']\n    >,\n  ) => {\n    const { payload: responseJson } = message\n\n    // Get the Request instance reference stored in the\n    // request listener.\n    const { requestId } = responseJson\n    const request = context.requests.get(requestId)!\n    context.requests.delete(requestId)\n\n    /**\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\n     * That kind of responses cannot be manipulated in JavaScript due\n     * to the security considerations.\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\n     * @see https://github.com/mswjs/msw/issues/529\n     */\n    if (responseJson.type?.includes('opaque')) {\n      return\n    }\n\n    const response =\n      responseJson.status === 0\n        ? Response.error()\n        : new Response(\n            /**\n             * Responses may be streams here, but when we create a response object\n             * with null-body status codes, like 204, 205, 304 Response will\n             * throw when passed a non-null body, so ensure it's null here\n             * for those codes\n             */\n            isResponseWithoutBody(responseJson.status)\n              ? null\n              : responseJson.body,\n            responseJson,\n          )\n\n    /**\n     * Set response URL if it's not set already.\n     * @see https://github.com/mswjs/msw/issues/2030\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Response/url\n     */\n    if (!response.url) {\n      Object.defineProperty(response, 'url', {\n        value: request.url,\n        enumerable: true,\n        writable: false,\n      })\n    }\n\n    context.emitter.emit(\n      responseJson.isMockedResponse ? 'response:mocked' : 'response:bypass',\n      {\n        response,\n        request,\n        requestId: responseJson.requestId,\n      },\n    )\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport { StartOptions } from '../../glossary'\n\nexport function validateWorkerScope(\n  registration: ServiceWorkerRegistration,\n  options?: StartOptions,\n): void {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`,\n    )\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\nimport { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport const createStop = (\n  context: SetupWorkerInternalContext,\n): StopHandler => {\n  return function stop() {\n    // Warn developers calling \"worker.stop()\" more times than necessary.\n    // This likely indicates a mistake in their code.\n    if (!context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.',\n      )\n      return\n    }\n\n    /**\n     * Signal the Service Worker to disable mocking for this client.\n     * Use this an an explicit way to stop the mocking, while preserving\n     * the worker-client relation. Does not affect the worker's lifecycle.\n     */\n    context.workerChannel.send('MOCK_DEACTIVATE')\n    context.isMockingEnabled = false\n    window.clearInterval(context.keepAliveInterval)\n\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n","import { devUtils } from '~/core/utils/internal/devUtils'\n\nexport function printStopMessage(args: { quiet?: boolean } = {}): void {\n  if (args.quiet) {\n    return\n  }\n\n  console.log(\n    `%c${devUtils.formatMessage('Mocking disabled.')}`,\n    'color:orangered;font-weight:bold;',\n  )\n}\n","import { RequiredDeep } from '~/core/typeUtils'\nimport { mergeRight } from '~/core/utils/internal/mergeRight'\nimport {\n  SetupWorker,\n  SetupWorkerInternalContext,\n  StartHandler,\n  StartOptions,\n} from '../../glossary'\n\nexport const DEFAULT_START_OPTIONS: RequiredDeep<StartOptions> = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null as any,\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'warn',\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl\n  },\n}\n\n/**\n * Returns resolved worker start options, merging the default options\n * with the given custom options.\n */\nexport function resolveStartOptions(\n  initialOptions?: StartOptions,\n): RequiredDeep<StartOptions> {\n  return mergeRight(\n    DEFAULT_START_OPTIONS,\n    initialOptions || {},\n  ) as RequiredDeep<StartOptions>\n}\n\nexport function prepareStartHandler(\n  handler: StartHandler,\n  context: SetupWorkerInternalContext,\n): SetupWorker['start'] {\n  return (initialOptions) => {\n    context.startOptions = resolveStartOptions(initialOptions)\n    return handler(context.startOptions, initialOptions || {})\n  }\n}\n","export type PromiseState = 'pending' | 'fulfilled' | 'rejected'\n\nexport type Executor<Value> = ConstructorParameters<typeof Promise<Value>>[0]\nexport type ResolveFunction<Value> = Parameters<Executor<Value>>[0]\nexport type RejectFunction<Reason> = Parameters<Executor<Reason>>[1]\n\nexport type DeferredPromiseExecutor<Input = never, Output = Input> = {\n  (resolve?: ResolveFunction<Input>, reject?: RejectFunction<any>): void\n\n  resolve: ResolveFunction<Input>\n  reject: RejectFunction<any>\n  result?: Output\n  state: PromiseState\n  rejectionReason?: unknown\n}\nexport function createDeferredExecutor<\n  Input = never,\n  Output = Input\n>(): DeferredPromiseExecutor<Input, Output> {\n  const executor = <DeferredPromiseExecutor<Input, Output>>((\n    resolve,\n    reject\n  ) => {\n    executor.state = 'pending'\n\n    executor.resolve = (data) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      executor.result = data as Output\n\n      const onFulfilled = <Value>(value: Value) => {\n        executor.state = 'fulfilled'\n        return value\n      }\n\n      return resolve(\n        data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled)\n      )\n    }\n\n    executor.reject = (reason) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      queueMicrotask(() => {\n        executor.state = 'rejected'\n      })\n\n      return reject((executor.rejectionReason = reason))\n    }\n  })\n\n  return executor\n}\n","import {\n  type Executor,\n  type RejectFunction,\n  type ResolveFunction,\n  type DeferredPromiseExecutor,\n  createDeferredExecutor,\n} from './createDeferredExecutor'\n\nexport class DeferredPromise<Input, Output = Input> extends Promise<Input> {\n  #executor: DeferredPromiseExecutor\n\n  public resolve: ResolveFunction<Output>\n  public reject: RejectFunction<Output>\n\n  constructor(executor: Executor<Input> | null = null) {\n    const deferredExecutor = createDeferredExecutor()\n    super((originalResolve, originalReject) => {\n      deferredExecutor(originalResolve, originalReject)\n      executor?.(deferredExecutor.resolve, deferredExecutor.reject)\n    })\n\n    this.#executor = deferredExecutor\n    this.resolve = this.#executor.resolve\n    this.reject = this.#executor.reject\n  }\n\n  public get state() {\n    return this.#executor.state\n  }\n\n  public get rejectionReason() {\n    return this.#executor.rejectionReason\n  }\n\n  public then<ThenResult = Input, CatchResult = never>(\n    onFulfilled?: (value: Input) => ThenResult | PromiseLike<ThenResult>,\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.then(onFulfilled, onRejected))\n  }\n\n  public catch<CatchResult = never>(\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.catch(onRejected))\n  }\n\n  public finally(onfinally?: () => void | Promise<any>) {\n    return this.#decorate(super.finally(onfinally))\n  }\n\n  #decorate<ChildInput>(\n    promise: Promise<ChildInput>\n  ): DeferredPromise<ChildInput, Output> {\n    return Object.defineProperties(promise, {\n      resolve: { configurable: true, value: this.resolve },\n      reject: { configurable: true, value: this.reject },\n    }) as DeferredPromise<ChildInput, Output>\n  }\n}\n","import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\n\nexport class RequestController {\n  public responsePromise: DeferredPromise<Response | undefined>\n\n  constructor(protected request: Request) {\n    this.responsePromise = new DeferredPromise()\n  }\n\n  public respondWith(response?: Response): void {\n    invariant(\n      this.responsePromise.state === 'pending',\n      'Failed to respond to \"%s %s\" request: the \"request\" event has already been responded to.',\n      this.request.method,\n      this.request.url\n    )\n\n    this.responsePromise.resolve(response)\n  }\n}\n","import { RequestController } from './RequestController'\n\nexport type InteractiveRequest = globalThis.Request & {\n  respondWith: RequestController['respondWith']\n}\n\nexport function toInteractiveRequest(request: Request): {\n  interactiveRequest: InteractiveRequest\n  requestController: RequestController\n} {\n  const requestController = new RequestController(request)\n\n  Reflect.set(\n    request,\n    'respondWith',\n    requestController.respondWith.bind(requestController)\n  )\n\n  return {\n    interactiveRequest: request as InteractiveRequest,\n    requestController,\n  }\n}\n","import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Emits an event on the given emitter but executes\n * the listeners sequentially. This accounts for asynchronous\n * listeners (e.g. those having \"sleep\" and handling the request).\n */\nexport async function emitAsync<\n  Events extends EventMap,\n  EventName extends keyof Events\n>(\n  emitter: Emitter<Events>,\n  eventName: EventName,\n  ...data: Events[EventName]\n): Promise<void> {\n  const listners = emitter.listeners(eventName)\n\n  if (listners.length === 0) {\n    return\n  }\n\n  for (const listener of listners) {\n    await listener.apply(emitter, data)\n  }\n}\n","/**\n * Returns a boolean indicating whether the given URL string\n * can be parsed into a `URL` instance.\n * A substitute for `URL.canParse()` for Node.js 18.\n */\nexport function canParseUrl(url: string): boolean {\n  try {\n    new URL(url)\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n","import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { until } from '@open-draft/until'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { Interceptor } from '../../Interceptor'\nimport { toInteractiveRequest } from '../../utils/toInteractiveRequest'\nimport { emitAsync } from '../../utils/emitAsync'\nimport { canParseUrl } from '../../utils/canParseUrl'\nimport { createRequestId } from '../../createRequestId'\nimport {\n  createServerErrorResponse,\n  isResponseError,\n} from '../../utils/responseUtils'\n\nexport class FetchInterceptor extends Interceptor<HttpRequestEventMap> {\n  static symbol = Symbol('fetch')\n\n  constructor() {\n    super(FetchInterceptor.symbol)\n  }\n\n  protected checkEnvironment() {\n    return (\n      typeof globalThis !== 'undefined' &&\n      typeof globalThis.fetch !== 'undefined'\n    )\n  }\n\n  protected async setup() {\n    const pureFetch = globalThis.fetch\n\n    invariant(\n      !(pureFetch as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"fetch\" module: already patched.'\n    )\n\n    globalThis.fetch = async (input, init) => {\n      const requestId = createRequestId()\n\n      /**\n       * @note Resolve potentially relative request URL\n       * against the present `location`. This is mainly\n       * for native `fetch` in JSDOM.\n       * @see https://github.com/mswjs/msw/issues/1625\n       */\n      const resolvedInput =\n        typeof input === 'string' &&\n        typeof location !== 'undefined' &&\n        !canParseUrl(input)\n          ? new URL(input, location.origin)\n          : input\n\n      const request = new Request(resolvedInput, init)\n\n      this.logger.info('[%s] %s', request.method, request.url)\n\n      const { interactiveRequest, requestController } =\n        toInteractiveRequest(request)\n\n      this.logger.info(\n        'emitting the \"request\" event for %d listener(s)...',\n        this.emitter.listenerCount('request')\n      )\n\n      this.emitter.once('request', ({ requestId: pendingRequestId }) => {\n        if (pendingRequestId !== requestId) {\n          return\n        }\n\n        if (requestController.responsePromise.state === 'pending') {\n          requestController.responsePromise.resolve(undefined)\n        }\n      })\n\n      this.logger.info('awaiting for the mocked response...')\n\n      const signal = interactiveRequest.signal\n      const requestAborted = new DeferredPromise()\n\n      // Signal isn't always defined in react-native.\n      if (signal) {\n        signal.addEventListener(\n          'abort',\n          () => {\n            requestAborted.reject(signal.reason)\n          },\n          { once: true }\n        )\n      }\n\n      const responsePromise = new DeferredPromise<Response>()\n\n      const respondWith = (response: Response): void => {\n        this.logger.info('responding with a mock response:', response)\n\n        if (this.emitter.listenerCount('response') > 0) {\n          this.logger.info('emitting the \"response\" event...')\n\n          // Clone the mocked response for the \"response\" event listener.\n          // This way, the listener can read the response and not lock its body\n          // for the actual fetch consumer.\n          const responseClone = response.clone()\n\n          this.emitter.emit('response', {\n            response: responseClone,\n            isMockedResponse: true,\n            request: interactiveRequest,\n            requestId,\n          })\n        }\n\n        // Set the \"response.url\" property to equal the intercepted request URL.\n        Object.defineProperty(response, 'url', {\n          writable: false,\n          enumerable: true,\n          configurable: false,\n          value: request.url,\n        })\n\n        responsePromise.resolve(response)\n      }\n\n      const errorWith = (reason: unknown): void => {\n        responsePromise.reject(reason)\n      }\n\n      const resolverResult = await until<unknown, Response | undefined>(\n        async () => {\n          const listenersFinished = emitAsync(this.emitter, 'request', {\n            request: interactiveRequest,\n            requestId,\n          })\n\n          await Promise.race([\n            requestAborted,\n            // Put the listeners invocation Promise in the same race condition\n            // with the request abort Promise because otherwise awaiting the listeners\n            // would always yield some response (or undefined).\n            listenersFinished,\n            requestController.responsePromise,\n          ])\n\n          this.logger.info('all request listeners have been resolved!')\n\n          const mockedResponse = await requestController.responsePromise\n          this.logger.info('event.respondWith called with:', mockedResponse)\n\n          return mockedResponse\n        }\n      )\n\n      if (requestAborted.state === 'rejected') {\n        this.logger.info(\n          'request has been aborted:',\n          requestAborted.rejectionReason\n        )\n\n        responsePromise.reject(requestAborted.rejectionReason)\n        return responsePromise\n      }\n\n      if (resolverResult.error) {\n        this.logger.info(\n          'request listerner threw an error:',\n          resolverResult.error\n        )\n\n        // Treat thrown Responses as mocked responses.\n        if (resolverResult.error instanceof Response) {\n          // Treat thrown Response.error() as a request error.\n          if (isResponseError(resolverResult.error)) {\n            errorWith(createNetworkError(resolverResult.error))\n          } else {\n            // Treat the rest of thrown Responses as mocked responses.\n            respondWith(resolverResult.error)\n          }\n        }\n\n        // Emit the \"unhandledException\" interceptor event so the client\n        // can opt-out from exceptions translating to 500 error responses.\n\n        if (this.emitter.listenerCount('unhandledException') > 0) {\n          await emitAsync(this.emitter, 'unhandledException', {\n            error: resolverResult.error,\n            request,\n            requestId,\n            controller: {\n              respondWith,\n              errorWith,\n            },\n          })\n\n          if (responsePromise.state !== 'pending') {\n            return responsePromise\n          }\n        }\n\n        // Unhandled exceptions in the request listeners are\n        // synonymous to unhandled exceptions on the server.\n        // Those are represented as 500 error responses.\n        respondWith(createServerErrorResponse(resolverResult.error))\n        return responsePromise\n      }\n\n      const mockedResponse = resolverResult.data\n\n      if (mockedResponse && !request.signal?.aborted) {\n        this.logger.info('received mocked response:', mockedResponse)\n\n        // Reject the request Promise on mocked \"Response.error\" responses.\n        if (isResponseError(mockedResponse)) {\n          this.logger.info(\n            'received a network error response, rejecting the request promise...'\n          )\n\n          /**\n           * Set the cause of the request promise rejection to the\n           * network error Response instance. This differs from Undici.\n           * Undici will forward the \"response.error\" custom property\n           * as the rejection reason but for \"Response.error()\" static method\n           * \"response.error\" will equal to undefined, making \"cause\" an empty Error.\n           * @see https://github.com/nodejs/undici/blob/83cb522ae0157a19d149d72c7d03d46e34510d0a/lib/fetch/response.js#L344\n           */\n          errorWith(createNetworkError(mockedResponse))\n        } else {\n          respondWith(mockedResponse)\n        }\n\n        return responsePromise\n      }\n\n      this.logger.info('no mocked response received!')\n\n      return pureFetch(request).then((response) => {\n        this.logger.info('original fetch performed', response)\n\n        if (this.emitter.listenerCount('response') > 0) {\n          this.logger.info('emitting the \"response\" event...')\n\n          const responseClone = response.clone()\n\n          this.emitter.emit('response', {\n            response: responseClone,\n            isMockedResponse: false,\n            request: interactiveRequest,\n            requestId,\n          })\n        }\n\n        return response\n      })\n    }\n\n    Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.fetch = pureFetch\n\n      this.logger.info(\n        'restored native \"globalThis.fetch\"!',\n        globalThis.fetch.name\n      )\n    })\n  }\n}\n\nfunction createNetworkError(cause: unknown) {\n  return Object.assign(new TypeError('Failed to fetch'), {\n    cause,\n  })\n}\n","/**\n * Concatenate two `Uint8Array` buffers.\n */\nexport function concatArrayBuffer(\n  left: Uint8Array,\n  right: Uint8Array\n): Uint8Array {\n  const result = new Uint8Array(left.byteLength + right.byteLength)\n  result.set(left, 0)\n  result.set(right, left.byteLength)\n  return result\n}\n","export class EventPolyfill implements Event {\n  readonly AT_TARGET: number = 0\n  readonly BUBBLING_PHASE: number = 0\n  readonly CAPTURING_PHASE: number = 0\n  readonly NONE: number = 0\n\n  public type: string = ''\n  public srcElement: EventTarget | null = null\n  public target: EventTarget | null\n  public currentTarget: EventTarget | null = null\n  public eventPhase: number = 0\n  public timeStamp: number\n  public isTrusted: boolean = true\n  public composed: boolean = false\n  public cancelable: boolean = true\n  public defaultPrevented: boolean = false\n  public bubbles: boolean = true\n  public lengthComputable: boolean = true\n  public loaded: number = 0\n  public total: number = 0\n\n  cancelBubble: boolean = false\n  returnValue: boolean = true\n\n  constructor(\n    type: string,\n    options?: { target: EventTarget; currentTarget: EventTarget }\n  ) {\n    this.type = type\n    this.target = options?.target || null\n    this.currentTarget = options?.currentTarget || null\n    this.timeStamp = Date.now()\n  }\n\n  public composedPath(): EventTarget[] {\n    return []\n  }\n\n  public initEvent(type: string, bubbles?: boolean, cancelable?: boolean) {\n    this.type = type\n    this.bubbles = !!bubbles\n    this.cancelable = !!cancelable\n  }\n\n  public preventDefault() {\n    this.defaultPrevented = true\n  }\n\n  public stopPropagation() {}\n  public stopImmediatePropagation() {}\n}\n","import { EventPolyfill } from './EventPolyfill'\n\nexport class ProgressEventPolyfill extends EventPolyfill {\n  readonly lengthComputable: boolean\n  readonly composed: boolean\n  readonly loaded: number\n  readonly total: number\n\n  constructor(type: string, init?: ProgressEventInit) {\n    super(type)\n\n    this.lengthComputable = init?.lengthComputable || false\n    this.composed = init?.composed || false\n    this.loaded = init?.loaded || 0\n    this.total = init?.total || 0\n  }\n}\n","import { EventPolyfill } from '../polyfills/EventPolyfill'\nimport { ProgressEventPolyfill } from '../polyfills/ProgressEventPolyfill'\n\nconst SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== 'undefined'\n\nexport function createEvent(\n  target: XMLHttpRequest,\n  type: string,\n  init?: ProgressEventInit\n): EventPolyfill {\n  const progressEvents = [\n    'error',\n    'progress',\n    'loadstart',\n    'loadend',\n    'load',\n    'timeout',\n    'abort',\n  ]\n\n  /**\n   * `ProgressEvent` is not supported in React Native.\n   * @see https://github.com/mswjs/interceptors/issues/40\n   */\n  const ProgressEventClass = SUPPORTS_PROGRESS_EVENT\n    ? ProgressEvent\n    : ProgressEventPolyfill\n\n  const event = progressEvents.includes(type)\n    ? new ProgressEventClass(type, {\n        lengthComputable: true,\n        loaded: init?.loaded || 0,\n        total: init?.total || 0,\n      })\n    : new EventPolyfill(type, {\n        target,\n        currentTarget: target,\n      })\n\n  return event\n}\n","/**\n * Returns the source object of the given property on the target object\n * (the target itself, any parent in its prototype, or null).\n */\nexport function findPropertySource(\n  target: object,\n  propertyName: string | symbol\n): object | null {\n  if (!(propertyName in target)) {\n    return null\n  }\n\n  const hasProperty = Object.prototype.hasOwnProperty.call(target, propertyName)\n  if (hasProperty) {\n    return target\n  }\n\n  const prototype = Reflect.getPrototypeOf(target)\n  return prototype ? findPropertySource(prototype, propertyName) : null\n}\n","import { findPropertySource } from './findPropertySource'\n\nexport interface ProxyOptions<Target extends Record<string, any>> {\n  constructorCall?(args: Array<unknown>, next: NextFunction<Target>): Target\n\n  methodCall?<F extends keyof Target>(\n    this: Target,\n    data: [methodName: F, args: Array<unknown>],\n    next: NextFunction<void>\n  ): void\n\n  setProperty?(\n    data: [propertyName: string | symbol, nextValue: unknown],\n    next: NextFunction<boolean>\n  ): boolean\n\n  getProperty?(\n    data: [propertyName: string | symbol, receiver: Target],\n    next: NextFunction<void>\n  ): void\n}\n\nexport type NextFunction<ReturnType> = () => ReturnType\n\nexport function createProxy<Target extends object>(\n  target: Target,\n  options: ProxyOptions<Target>\n): Target {\n  const proxy = new Proxy(target, optionsToProxyHandler(options))\n\n  return proxy\n}\n\nfunction optionsToProxyHandler<T extends Record<string, any>>(\n  options: ProxyOptions<T>\n): ProxyHandler<T> {\n  const { constructorCall, methodCall, getProperty, setProperty } = options\n  const handler: ProxyHandler<T> = {}\n\n  if (typeof constructorCall !== 'undefined') {\n    handler.construct = function (target, args, newTarget) {\n      const next = Reflect.construct.bind(null, target as any, args, newTarget)\n      return constructorCall.call(newTarget, args, next)\n    }\n  }\n\n  handler.set = function (target, propertyName, nextValue) {\n    const next = () => {\n      const propertySource = findPropertySource(target, propertyName) || target\n      const ownDescriptors = Reflect.getOwnPropertyDescriptor(\n        propertySource,\n        propertyName\n      )\n\n      // Respect any custom setters present for this property.\n      if (typeof ownDescriptors?.set !== 'undefined') {\n        ownDescriptors.set.apply(target, [nextValue])\n        return true\n      }\n\n      // Otherwise, set the property on the source.\n      return Reflect.defineProperty(propertySource, propertyName, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: nextValue,\n      })\n    }\n\n    if (typeof setProperty !== 'undefined') {\n      return setProperty.call(target, [propertyName, nextValue], next)\n    }\n\n    return next()\n  }\n\n  handler.get = function (target, propertyName, receiver) {\n    /**\n     * @note Using `Reflect.get()` here causes \"TypeError: Illegal invocation\".\n     */\n    const next = () => target[propertyName as any]\n\n    const value =\n      typeof getProperty !== 'undefined'\n        ? getProperty.call(target, [propertyName, receiver], next)\n        : next()\n\n    if (typeof value === 'function') {\n      return (...args: Array<any>) => {\n        const next = value.bind(target, ...args)\n\n        if (typeof methodCall !== 'undefined') {\n          return methodCall.call(target, [propertyName as any, args], next)\n        }\n\n        return next()\n      }\n    }\n\n    return value\n  }\n\n  return handler\n}\n","export function isDomParserSupportedType(\n  type: string\n): type is DOMParserSupportedType {\n  const supportedTypes: Array<DOMParserSupportedType> = [\n    'application/xhtml+xml',\n    'application/xml',\n    'image/svg+xml',\n    'text/html',\n    'text/xml',\n  ]\n  return supportedTypes.some((supportedType) => {\n    return type.startsWith(supportedType)\n  })\n}\n","/**\n * Parses a given string into JSON.\n * Gracefully handles invalid JSON by returning `null`.\n */\nexport function parseJson(data: string): Record<string, unknown> | null {\n  try {\n    const json = JSON.parse(data)\n    return json\n  } catch (_) {\n    return null\n  }\n}\n","import { isResponseWithoutBody } from '../../../utils/responseUtils'\n\n/**\n * Creates a Fetch API `Response` instance from the given\n * `XMLHttpRequest` instance and a response body.\n */\nexport function createResponse(\n  request: XMLHttpRequest,\n  body: BodyInit | null\n): Response {\n  /**\n   * Handle XMLHttpRequest responses that must have null as the\n   * response body when represented using Fetch API Response.\n   * XMLHttpRequest response will always have an empty string\n   * as the \"request.response\" in those cases, resulting in an error\n   * when constructing a Response instance.\n   * @see https://github.com/mswjs/interceptors/issues/379\n   */\n  const responseBodyOrNull = isResponseWithoutBody(request.status) ? null : body\n\n  return new Response(responseBodyOrNull, {\n    status: request.status,\n    statusText: request.statusText,\n    headers: createHeadersFromXMLHttpReqestHeaders(\n      request.getAllResponseHeaders()\n    ),\n  })\n}\n\nfunction createHeadersFromXMLHttpReqestHeaders(headersString: string): Headers {\n  const headers = new Headers()\n\n  const lines = headersString.split(/[\\r\\n]+/)\n  for (const line of lines) {\n    if (line.trim() === '') {\n      continue\n    }\n\n    const [name, ...parts] = line.split(': ')\n    const value = parts.join(': ')\n\n    headers.append(name, value)\n  }\n\n  return headers\n}\n","import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport type { Logger } from '@open-draft/logger'\nimport { concatArrayBuffer } from './utils/concatArrayBuffer'\nimport { createEvent } from './utils/createEvent'\nimport {\n  decodeBuffer,\n  encodeBuffer,\n  toArrayBuffer,\n} from '../../utils/bufferUtils'\nimport { createProxy } from '../../utils/createProxy'\nimport { isDomParserSupportedType } from './utils/isDomParserSupportedType'\nimport { parseJson } from '../../utils/parseJson'\nimport { createResponse } from './utils/createResponse'\nimport { INTERNAL_REQUEST_ID_HEADER_NAME } from '../../Interceptor'\nimport { createRequestId } from '../../createRequestId'\n\nconst IS_MOCKED_RESPONSE = Symbol('isMockedResponse')\nconst IS_NODE = isNodeProcess()\n\n/**\n * An `XMLHttpRequest` instance controller that allows us\n * to handle any given request instance (e.g. responding to it).\n */\nexport class XMLHttpRequestController {\n  public request: XMLHttpRequest\n  public requestId: string\n  public onRequest?: (\n    this: XMLHttpRequestController,\n    args: {\n      request: Request\n      requestId: string\n    }\n  ) => Promise<void>\n  public onResponse?: (\n    this: XMLHttpRequestController,\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ) => void\n\n  private method: string = 'GET'\n  private url: URL = null as any\n  private requestHeaders: Headers\n  private requestBody?: XMLHttpRequestBodyInit | Document | null\n  private responseBuffer: Uint8Array\n  private events: Map<keyof XMLHttpRequestEventTargetEventMap, Array<Function>>\n\n  constructor(readonly initialRequest: XMLHttpRequest, public logger: Logger) {\n    this.events = new Map()\n    this.requestId = createRequestId()\n    this.requestHeaders = new Headers()\n    this.responseBuffer = new Uint8Array()\n\n    this.request = createProxy(initialRequest, {\n      setProperty: ([propertyName, nextValue], invoke) => {\n        switch (propertyName) {\n          case 'ontimeout': {\n            const eventName = propertyName.slice(\n              2\n            ) as keyof XMLHttpRequestEventTargetEventMap\n\n            /**\n             * @note Proxy callbacks to event listeners because JSDOM has trouble\n             * translating these properties to callbacks. It seemed to be operating\n             * on events exclusively.\n             */\n            this.request.addEventListener(eventName, nextValue as any)\n\n            return invoke()\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n      methodCall: ([methodName, args], invoke) => {\n        switch (methodName) {\n          case 'open': {\n            const [method, url] = args as [string, string | undefined]\n\n            if (typeof url === 'undefined') {\n              this.method = 'GET'\n              this.url = toAbsoluteUrl(method)\n            } else {\n              this.method = method\n              this.url = toAbsoluteUrl(url)\n            }\n\n            this.logger = this.logger.extend(`${this.method} ${this.url.href}`)\n            this.logger.info('open', this.method, this.url.href)\n\n            return invoke()\n          }\n\n          case 'addEventListener': {\n            const [eventName, listener] = args as [\n              keyof XMLHttpRequestEventTargetEventMap,\n              Function\n            ]\n\n            this.registerEvent(eventName, listener)\n            this.logger.info('addEventListener', eventName, listener)\n\n            return invoke()\n          }\n\n          case 'setRequestHeader': {\n            const [name, value] = args as [string, string]\n            this.requestHeaders.set(name, value)\n\n            this.logger.info('setRequestHeader', name, value)\n\n            return invoke()\n          }\n\n          case 'send': {\n            const [body] = args as [\n              body?: XMLHttpRequestBodyInit | Document | null\n            ]\n\n            if (body != null) {\n              this.requestBody =\n                typeof body === 'string' ? encodeBuffer(body) : body\n            }\n\n            this.request.addEventListener('load', () => {\n              if (typeof this.onResponse !== 'undefined') {\n                // Create a Fetch API Response representation of whichever\n                // response this XMLHttpRequest received. Note those may\n                // be either a mocked and the original response.\n                const fetchResponse = createResponse(\n                  this.request,\n                  /**\n                   * The `response` property is the right way to read\n                   * the ambiguous response body, as the request's \"responseType\" may differ.\n                   * @see https://xhr.spec.whatwg.org/#the-response-attribute\n                   */\n                  this.request.response\n                )\n\n                // Notify the consumer about the response.\n                this.onResponse.call(this, {\n                  response: fetchResponse,\n                  isMockedResponse: IS_MOCKED_RESPONSE in this.request,\n                  request: fetchRequest,\n                  requestId: this.requestId!,\n                })\n              }\n            })\n\n            // Delegate request handling to the consumer.\n            const fetchRequest = this.toFetchApiRequest()\n            const onceRequestSettled =\n              this.onRequest?.call(this, {\n                request: fetchRequest,\n                requestId: this.requestId!,\n              }) || Promise.resolve()\n\n            onceRequestSettled.finally(() => {\n              // If the consumer didn't handle the request perform it as-is.\n              // Note that the request may not yet be DONE and may, in fact,\n              // be LOADING while the \"respondWith\" method does its magic.\n              if (this.request.readyState < this.request.LOADING) {\n                this.logger.info(\n                  'request callback settled but request has not been handled (readystate %d), performing as-is...',\n                  this.request.readyState\n                )\n\n                /**\n                 * @note Set the intercepted request ID on the original request in Node.js\n                 * so that if it triggers any other interceptors, they don't attempt\n                 * to process it once again.\n                 *\n                 * For instance, XMLHttpRequest is often implemented via \"http.ClientRequest\"\n                 * and we don't want for both XHR and ClientRequest interceptors to\n                 * handle the same request at the same time (e.g. emit the \"response\" event twice).\n                 */\n                if (IS_NODE) {\n                  this.request.setRequestHeader(\n                    INTERNAL_REQUEST_ID_HEADER_NAME,\n                    this.requestId!\n                  )\n                }\n\n                return invoke()\n              }\n            })\n\n            break\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n    })\n  }\n\n  private registerEvent(\n    eventName: keyof XMLHttpRequestEventTargetEventMap,\n    listener: Function\n  ): void {\n    const prevEvents = this.events.get(eventName) || []\n    const nextEvents = prevEvents.concat(listener)\n    this.events.set(eventName, nextEvents)\n\n    this.logger.info('registered event \"%s\"', eventName, listener)\n  }\n\n  /**\n   * Responds to the current request with the given\n   * Fetch API `Response` instance.\n   */\n  public respondWith(response: Response): void {\n    this.logger.info(\n      'responding with a mocked response: %d %s',\n      response.status,\n      response.statusText\n    )\n\n    /**\n     * @note Since `XMLHttpRequestController` delegates the handling of the responses\n     * to the \"load\" event listener that doesn't distinguish between the mocked and original\n     * responses, mark the request that had a mocked response with a corresponding symbol.\n     */\n    define(this.request, IS_MOCKED_RESPONSE, true)\n\n    define(this.request, 'status', response.status)\n    define(this.request, 'statusText', response.statusText)\n    define(this.request, 'responseURL', this.url.href)\n\n    this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, {\n      apply: (_, __, args: [name: string]) => {\n        this.logger.info('getResponseHeader', args[0])\n\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info('headers not received yet, returning null')\n\n          // Headers not received yet, nothing to return.\n          return null\n        }\n\n        const headerValue = response.headers.get(args[0])\n        this.logger.info(\n          'resolved response header \"%s\" to',\n          args[0],\n          headerValue\n        )\n\n        return headerValue\n      },\n    })\n\n    this.request.getAllResponseHeaders = new Proxy(\n      this.request.getAllResponseHeaders,\n      {\n        apply: () => {\n          this.logger.info('getAllResponseHeaders')\n\n          if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n            this.logger.info('headers not received yet, returning empty string')\n\n            // Headers not received yet, nothing to return.\n            return ''\n          }\n\n          const headersList = Array.from(response.headers.entries())\n          const allHeaders = headersList\n            .map(([headerName, headerValue]) => {\n              return `${headerName}: ${headerValue}`\n            })\n            .join('\\r\\n')\n\n          this.logger.info('resolved all response headers to', allHeaders)\n\n          return allHeaders\n        },\n      }\n    )\n\n    // Update the response getters to resolve against the mocked response.\n    Object.defineProperties(this.request, {\n      response: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.response,\n      },\n      responseText: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseText,\n      },\n      responseXML: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseXML,\n      },\n    })\n\n    const totalResponseBodyLength = response.headers.has('Content-Length')\n      ? Number(response.headers.get('Content-Length'))\n      : /**\n         * @todo Infer the response body length from the response body.\n         */\n        undefined\n\n    this.logger.info('calculated response body length', totalResponseBodyLength)\n\n    this.trigger('loadstart', {\n      loaded: 0,\n      total: totalResponseBodyLength,\n    })\n\n    this.setReadyState(this.request.HEADERS_RECEIVED)\n    this.setReadyState(this.request.LOADING)\n\n    const finalizeResponse = () => {\n      this.logger.info('finalizing the mocked response...')\n\n      this.setReadyState(this.request.DONE)\n\n      this.trigger('load', {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n\n      this.trigger('loadend', {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n    }\n\n    if (response.body) {\n      this.logger.info('mocked response has body, streaming...')\n\n      const reader = response.body.getReader()\n\n      const readNextResponseBodyChunk = async () => {\n        const { value, done } = await reader.read()\n\n        if (done) {\n          this.logger.info('response body stream done!')\n          finalizeResponse()\n          return\n        }\n\n        if (value) {\n          this.logger.info('read response body chunk:', value)\n          this.responseBuffer = concatArrayBuffer(this.responseBuffer, value)\n\n          this.trigger('progress', {\n            loaded: this.responseBuffer.byteLength,\n            total: totalResponseBodyLength,\n          })\n        }\n\n        readNextResponseBodyChunk()\n      }\n\n      readNextResponseBodyChunk()\n    } else {\n      finalizeResponse()\n    }\n  }\n\n  private responseBufferToText(): string {\n    return decodeBuffer(this.responseBuffer)\n  }\n\n  get response(): unknown {\n    this.logger.info(\n      'getResponse (responseType: %s)',\n      this.request.responseType\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    switch (this.request.responseType) {\n      case 'json': {\n        const responseJson = parseJson(this.responseBufferToText())\n        this.logger.info('resolved response JSON', responseJson)\n\n        return responseJson\n      }\n\n      case 'arraybuffer': {\n        const arrayBuffer = toArrayBuffer(this.responseBuffer)\n        this.logger.info('resolved response ArrayBuffer', arrayBuffer)\n\n        return arrayBuffer\n      }\n\n      case 'blob': {\n        const mimeType =\n          this.request.getResponseHeader('Content-Type') || 'text/plain'\n        const responseBlob = new Blob([this.responseBufferToText()], {\n          type: mimeType,\n        })\n\n        this.logger.info(\n          'resolved response Blob (mime type: %s)',\n          responseBlob,\n          mimeType\n        )\n\n        return responseBlob\n      }\n\n      default: {\n        const responseText = this.responseBufferToText()\n        this.logger.info(\n          'resolving \"%s\" response type as text',\n          this.request.responseType,\n          responseText\n        )\n\n        return responseText\n      }\n    }\n  }\n\n  get responseText(): string {\n    /**\n     * Throw when trying to read the response body as text when the\n     * \"responseType\" doesn't expect text. This just respects the spec better.\n     * @see https://xhr.spec.whatwg.org/#the-responsetext-attribute\n     */\n    invariant(\n      this.request.responseType === '' || this.request.responseType === 'text',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (\n      this.request.readyState !== this.request.LOADING &&\n      this.request.readyState !== this.request.DONE\n    ) {\n      return ''\n    }\n\n    const responseText = this.responseBufferToText()\n    this.logger.info('getResponseText: \"%s\"', responseText)\n\n    return responseText\n  }\n\n  get responseXML(): Document | null {\n    invariant(\n      this.request.responseType === '' ||\n        this.request.responseType === 'document',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    const contentType = this.request.getResponseHeader('Content-Type') || ''\n\n    if (typeof DOMParser === 'undefined') {\n      console.warn(\n        'Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly.'\n      )\n      return null\n    }\n\n    if (isDomParserSupportedType(contentType)) {\n      return new DOMParser().parseFromString(\n        this.responseBufferToText(),\n        contentType\n      )\n    }\n\n    return null\n  }\n\n  public errorWith(error: Error): void {\n    this.logger.info('responding with an error')\n\n    this.setReadyState(this.request.DONE)\n    this.trigger('error')\n    this.trigger('loadend')\n  }\n\n  /**\n   * Transitions this request's `readyState` to the given one.\n   */\n  private setReadyState(nextReadyState: number): void {\n    this.logger.info(\n      'setReadyState: %d -> %d',\n      this.request.readyState,\n      nextReadyState\n    )\n\n    if (this.request.readyState === nextReadyState) {\n      this.logger.info('ready state identical, skipping transition...')\n      return\n    }\n\n    define(this.request, 'readyState', nextReadyState)\n\n    this.logger.info('set readyState to: %d', nextReadyState)\n\n    if (nextReadyState !== this.request.UNSENT) {\n      this.logger.info('triggerring \"readystatechange\" event...')\n\n      this.trigger('readystatechange')\n    }\n  }\n\n  /**\n   * Triggers given event on the `XMLHttpRequest` instance.\n   */\n  private trigger<\n    EventName extends keyof (XMLHttpRequestEventTargetEventMap & {\n      readystatechange: ProgressEvent<XMLHttpRequestEventTarget>\n    })\n  >(eventName: EventName, options?: ProgressEventInit): void {\n    const callback = this.request[`on${eventName}`]\n    const event = createEvent(this.request, eventName, options)\n\n    this.logger.info('trigger \"%s\"', eventName, options || '')\n\n    // Invoke direct callbacks.\n    if (typeof callback === 'function') {\n      this.logger.info('found a direct \"%s\" callback, calling...', eventName)\n      callback.call(this.request, event)\n    }\n\n    // Invoke event listeners.\n    for (const [registeredEventName, listeners] of this.events) {\n      if (registeredEventName === eventName) {\n        this.logger.info(\n          'found %d listener(s) for \"%s\" event, calling...',\n          listeners.length,\n          eventName\n        )\n\n        listeners.forEach((listener) => listener.call(this.request, event))\n      }\n    }\n  }\n\n  /**\n   * Converts this `XMLHttpRequest` instance into a Fetch API `Request` instance.\n   */\n  public toFetchApiRequest(): Request {\n    this.logger.info('converting request to a Fetch API Request...')\n\n    const fetchRequest = new Request(this.url.href, {\n      method: this.method,\n      headers: this.requestHeaders,\n      /**\n       * @see https://xhr.spec.whatwg.org/#cross-origin-credentials\n       */\n      credentials: this.request.withCredentials ? 'include' : 'same-origin',\n      body: ['GET', 'HEAD'].includes(this.method)\n        ? null\n        : (this.requestBody as BodyInit),\n    })\n\n    const proxyHeaders = createProxy(fetchRequest.headers, {\n      methodCall: ([methodName, args], invoke) => {\n        // Forward the latest state of the internal request headers\n        // because the interceptor might have modified them\n        // without responding to the request.\n        switch (methodName) {\n          case 'append':\n          case 'set': {\n            const [headerName, headerValue] = args as [string, string]\n            this.request.setRequestHeader(headerName, headerValue)\n            break\n          }\n\n          case 'delete': {\n            const [headerName] = args as [string]\n            console.warn(\n              `XMLHttpRequest: Cannot remove a \"${headerName}\" header from the Fetch API representation of the \"${fetchRequest.method} ${fetchRequest.url}\" request. XMLHttpRequest headers cannot be removed.`\n            )\n            break\n          }\n        }\n\n        return invoke()\n      },\n    })\n    define(fetchRequest, 'headers', proxyHeaders)\n\n    this.logger.info('converted request to a Fetch API Request!', fetchRequest)\n\n    return fetchRequest\n  }\n}\n\nfunction toAbsoluteUrl(url: string | URL): URL {\n  /**\n   * @note XMLHttpRequest interceptor may run in environments\n   * that implement XMLHttpRequest but don't implement \"location\"\n   * (for example, React Native). If that's the case, return the\n   * input URL as-is (nothing to be relative to).\n   * @see https://github.com/mswjs/msw/issues/1777\n   */\n  if (typeof location === 'undefined') {\n    return new URL(url)\n  }\n\n  return new URL(url.toString(), location.href)\n}\n\nfunction define(\n  target: object,\n  property: string | symbol,\n  value: unknown\n): void {\n  Reflect.defineProperty(target, property, {\n    // Ensure writable properties to allow redefining readonly properties.\n    writable: true,\n    enumerable: true,\n    value,\n  })\n}\n","import { until } from '@open-draft/until'\nimport type { Logger } from '@open-draft/logger'\nimport { XMLHttpRequestEmitter } from '.'\nimport { toInteractiveRequest } from '../../utils/toInteractiveRequest'\nimport { emitAsync } from '../../utils/emitAsync'\nimport { XMLHttpRequestController } from './XMLHttpRequestController'\nimport {\n  createServerErrorResponse,\n  isResponseError,\n} from '../../utils/responseUtils'\n\nexport interface XMLHttpRequestProxyOptions {\n  emitter: XMLHttpRequestEmitter\n  logger: Logger\n}\n\n/**\n * Create a proxied `XMLHttpRequest` class.\n * The proxied class establishes spies on certain methods,\n * allowing us to intercept requests and respond to them.\n */\nexport function createXMLHttpRequestProxy({\n  emitter,\n  logger,\n}: XMLHttpRequestProxyOptions) {\n  const XMLHttpRequestProxy = new Proxy(globalThis.XMLHttpRequest, {\n    construct(target, args, newTarget) {\n      logger.info('constructed new XMLHttpRequest')\n\n      const originalRequest = Reflect.construct(\n        target,\n        args,\n        newTarget\n      ) as XMLHttpRequest\n\n      /**\n       * @note Forward prototype descriptors onto the proxied object.\n       * XMLHttpRequest is implemented in JSDOM in a way that assigns\n       * a bunch of descriptors, like \"set responseType()\" on the prototype.\n       * With this propagation, we make sure that those descriptors trigger\n       * when the user operates with the proxied request instance.\n       */\n      const prototypeDescriptors = Object.getOwnPropertyDescriptors(\n        target.prototype\n      )\n      for (const propertyName in prototypeDescriptors) {\n        Reflect.defineProperty(\n          originalRequest,\n          propertyName,\n          prototypeDescriptors[propertyName]\n        )\n      }\n\n      const xhrRequestController = new XMLHttpRequestController(\n        originalRequest,\n        logger\n      )\n\n      xhrRequestController.onRequest = async function ({ request, requestId }) {\n        const { interactiveRequest, requestController } =\n          toInteractiveRequest(request)\n\n        this.logger.info('awaiting mocked response...')\n\n        emitter.once('request', ({ requestId: pendingRequestId }) => {\n          if (pendingRequestId !== requestId) {\n            return\n          }\n\n          if (requestController.responsePromise.state === 'pending') {\n            requestController.respondWith(undefined)\n          }\n        })\n\n        const resolverResult = await until(async () => {\n          this.logger.info(\n            'emitting the \"request\" event for %s listener(s)...',\n            emitter.listenerCount('request')\n          )\n\n          await emitAsync(emitter, 'request', {\n            request: interactiveRequest,\n            requestId,\n          })\n\n          this.logger.info('all \"request\" listeners settled!')\n\n          const mockedResponse = await requestController.responsePromise\n\n          this.logger.info('event.respondWith called with:', mockedResponse)\n\n          return mockedResponse\n        })\n\n        if (resolverResult.error) {\n          this.logger.info(\n            'request listener threw an exception, aborting request...',\n            resolverResult.error\n          )\n\n          // Treat thrown Responses as mocked responses.\n          if (resolverResult.error instanceof Response) {\n            if (isResponseError(resolverResult.error)) {\n              xhrRequestController.errorWith(new TypeError('Network error'))\n            } else {\n              this.respondWith(resolverResult.error)\n            }\n\n            return\n          }\n\n          if (emitter.listenerCount('unhandledException') > 0) {\n            // Emit the \"unhandledException\" event so the client can opt-out\n            // from the default exception handling (producing 500 error responses).\n            await emitAsync(emitter, 'unhandledException', {\n              error: resolverResult.error,\n              request,\n              requestId,\n              controller: {\n                respondWith:\n                  xhrRequestController.respondWith.bind(xhrRequestController),\n                errorWith:\n                  xhrRequestController.errorWith.bind(xhrRequestController),\n              },\n            })\n\n            // If any of the \"unhandledException\" listeners handled the request,\n            // do nothing. Note that mocked responses will dispatch\n            // HEADERS_RECEIVED (2), then LOADING (3), and DONE (4) can take\n            // time as the mocked response body finishes streaming.\n            if (originalRequest.readyState > XMLHttpRequest.OPENED) {\n              return\n            }\n          }\n\n          // Unhandled exceptions in the request listeners are\n          // synonymous to unhandled exceptions on the server.\n          // Those are represented as 500 error responses.\n          xhrRequestController.respondWith(\n            createServerErrorResponse(resolverResult.error)\n          )\n\n          return\n        }\n\n        const mockedResponse = resolverResult.data\n\n        if (typeof mockedResponse !== 'undefined') {\n          this.logger.info(\n            'received mocked response: %d %s',\n            mockedResponse.status,\n            mockedResponse.statusText\n          )\n\n          if (isResponseError(mockedResponse)) {\n            this.logger.info(\n              'received a network error response, rejecting the request promise...'\n            )\n\n            xhrRequestController.errorWith(new TypeError('Network error'))\n            return\n          }\n\n          return xhrRequestController.respondWith(mockedResponse)\n        }\n\n        this.logger.info(\n          'no mocked response received, performing request as-is...'\n        )\n      }\n\n      xhrRequestController.onResponse = async function ({\n        response,\n        isMockedResponse,\n        request,\n        requestId,\n      }) {\n        this.logger.info(\n          'emitting the \"response\" event for %s listener(s)...',\n          emitter.listenerCount('response')\n        )\n\n        emitter.emit('response', {\n          response,\n          isMockedResponse,\n          request,\n          requestId,\n        })\n      }\n\n      // Return the proxied request from the controller\n      // so that the controller can react to the consumer's interactions\n      // with this request (opening/sending/etc).\n      return xhrRequestController.request\n    },\n  })\n\n  return XMLHttpRequestProxy\n}\n","import { invariant } from 'outvariant'\nimport { Emitter } from 'strict-event-emitter'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { InteractiveRequest } from '../../utils/toInteractiveRequest'\nimport { Interceptor } from '../../Interceptor'\nimport { createXMLHttpRequestProxy } from './XMLHttpRequestProxy'\n\nexport type XMLHttpRequestEventListener = (args: {\n  request: InteractiveRequest\n  requestId: string\n}) => Promise<void> | void\n\nexport type XMLHttpRequestEmitter = Emitter<HttpRequestEventMap>\n\nexport class XMLHttpRequestInterceptor extends Interceptor<HttpRequestEventMap> {\n  static interceptorSymbol = Symbol('xhr')\n\n  constructor() {\n    super(XMLHttpRequestInterceptor.interceptorSymbol)\n  }\n\n  protected checkEnvironment() {\n    return typeof globalThis.XMLHttpRequest !== 'undefined'\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('patching \"XMLHttpRequest\" module...')\n\n    const PureXMLHttpRequest = globalThis.XMLHttpRequest\n\n    invariant(\n      !(PureXMLHttpRequest as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"XMLHttpRequest\" module: already patched.'\n    )\n\n    globalThis.XMLHttpRequest = createXMLHttpRequestProxy({\n      emitter: this.emitter,\n      logger: this.logger,\n    })\n\n    logger.info(\n      'native \"XMLHttpRequest\" module patched!',\n      globalThis.XMLHttpRequest.name\n    )\n\n    Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.XMLHttpRequest = PureXMLHttpRequest\n      logger.info(\n        'native \"XMLHttpRequest\" module restored!',\n        globalThis.XMLHttpRequest.name\n      )\n    })\n  }\n}\n","import {\n  Interceptor,\n  BatchInterceptor,\n  HttpRequestEventMap,\n} from '@mswjs/interceptors'\nimport { FetchInterceptor } from '@mswjs/interceptors/fetch'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/XMLHttpRequest'\nimport { SetupWorkerInternalContext, StartOptions } from '../glossary'\nimport type { RequiredDeep } from '~/core/typeUtils'\nimport { handleRequest } from '~/core/utils/handleRequest'\n\nexport function createFallbackRequestListener(\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Interceptor<HttpRequestEventMap> {\n  const interceptor = new BatchInterceptor({\n    name: 'fallback',\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()],\n  })\n\n  interceptor.on('request', async ({ request, requestId }) => {\n    const requestCloneForLogs = request.clone()\n\n    const response = await handleRequest(\n      request,\n      requestId,\n      context.getRequestHandlers(),\n      options,\n      context.emitter,\n      {\n        onMockedResponse(_, { handler, parsedResult }) {\n          if (!options.quiet) {\n            context.emitter.once('response:mocked', ({ response }) => {\n              handler.log({\n                request: requestCloneForLogs,\n                response,\n                parsedResult,\n              })\n            })\n          }\n        },\n      },\n    )\n\n    if (response) {\n      request.respondWith(response)\n    }\n  })\n\n  interceptor.on(\n    'response',\n    ({ response, isMockedResponse, request, requestId }) => {\n      context.emitter.emit(\n        isMockedResponse ? 'response:mocked' : 'response:bypass',\n        {\n          response,\n          request,\n          requestId,\n        },\n      )\n    },\n  )\n\n  interceptor.apply()\n\n  return interceptor\n}\n","import { createFallbackRequestListener } from './createFallbackRequestListener'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { printStartMessage } from './utils/printStartMessage'\n\nexport function createFallbackStart(\n  context: SetupWorkerInternalContext,\n): StartHandler {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(\n      context,\n      options,\n    )\n\n    printStartMessage({\n      message: 'Mocking enabled (fallback mode).',\n      quiet: options.quiet,\n    })\n\n    return undefined\n  }\n}\n","import { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport function createFallbackStop(\n  context: SetupWorkerInternalContext,\n): StopHandler {\n  return function stop() {\n    context.fallbackInterceptor?.dispose()\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n","import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport {\n  SetupWorkerInternalContext,\n  ServiceWorkerIncomingEventsMap,\n  StartReturnType,\n  StopHandler,\n  StartHandler,\n  StartOptions,\n} from './glossary'\nimport { createStartHandler } from './start/createStartHandler'\nimport { createStop } from './stop/createStop'\nimport { ServiceWorkerMessage } from './start/utils/createMessageChannel'\nimport { RequestHandler } from '~/core/handlers/RequestHandler'\nimport { DEFAULT_START_OPTIONS } from './start/utils/prepareStartHandler'\nimport { createFallbackStart } from './start/createFallbackStart'\nimport { createFallbackStop } from './stop/createFallbackStop'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { SetupApi } from '~/core/SetupApi'\nimport { mergeRight } from '~/core/utils/internal/mergeRight'\nimport { LifeCycleEventsMap } from '~/core/sharedOptions'\nimport { SetupWorker } from './glossary'\nimport { supportsReadableStreamTransfer } from '../utils/supportsReadableStreamTransfer'\n\ninterface Listener {\n  target: EventTarget\n  eventType: string\n  callback: EventListenerOrEventListenerObject\n}\n\nexport class SetupWorkerApi\n  extends SetupApi<LifeCycleEventsMap>\n  implements SetupWorker\n{\n  private context: SetupWorkerInternalContext\n  private startHandler: StartHandler = null as any\n  private stopHandler: StopHandler = null as any\n  private listeners: Array<Listener>\n\n  constructor(...handlers: Array<RequestHandler>) {\n    super(...handlers)\n\n    invariant(\n      !isNodeProcess(),\n      devUtils.formatMessage(\n        'Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.',\n      ),\n    )\n\n    this.listeners = []\n    this.context = this.createWorkerContext()\n  }\n\n  private createWorkerContext(): SetupWorkerInternalContext {\n    const context: SetupWorkerInternalContext = {\n      // Mocking is not considered enabled until the worker\n      // signals back the successful activation event.\n      isMockingEnabled: false,\n      startOptions: null as any,\n      worker: null,\n      getRequestHandlers: () => {\n        return this.handlersController.currentHandlers()\n      },\n      registration: null,\n      requests: new Map(),\n      emitter: this.emitter,\n      workerChannel: {\n        on: (eventType, callback) => {\n          this.context.events.addListener<\n            MessageEvent<ServiceWorkerMessage<typeof eventType, any>>\n          >(navigator.serviceWorker, 'message', (event) => {\n            // Avoid messages broadcasted from unrelated workers.\n            if (event.source !== this.context.worker) {\n              return\n            }\n\n            const message = event.data\n\n            if (!message) {\n              return\n            }\n\n            if (message.type === eventType) {\n              callback(event, message)\n            }\n          })\n        },\n        send: (type) => {\n          this.context.worker?.postMessage(type)\n        },\n      },\n      events: {\n        addListener: (target, eventType, callback) => {\n          target.addEventListener(eventType, callback as EventListener)\n          this.listeners.push({\n            eventType,\n            target,\n            callback: callback as EventListener,\n          })\n\n          return () => {\n            target.removeEventListener(eventType, callback as EventListener)\n          }\n        },\n        removeAllListeners: () => {\n          for (const { target, eventType, callback } of this.listeners) {\n            target.removeEventListener(eventType, callback)\n          }\n          this.listeners = []\n        },\n        once: (eventType) => {\n          const bindings: Array<() => void> = []\n\n          return new Promise<\n            ServiceWorkerMessage<\n              typeof eventType,\n              ServiceWorkerIncomingEventsMap[typeof eventType]\n            >\n          >((resolve, reject) => {\n            const handleIncomingMessage = (event: MessageEvent) => {\n              try {\n                const message = event.data\n\n                if (message.type === eventType) {\n                  resolve(message)\n                }\n              } catch (error) {\n                reject(error)\n              }\n            }\n\n            bindings.push(\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                'message',\n                handleIncomingMessage,\n              ),\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                'messageerror',\n                reject,\n              ),\n            )\n          }).finally(() => {\n            bindings.forEach((unbind) => unbind())\n          })\n        },\n      },\n      supports: {\n        serviceWorkerApi:\n          !('serviceWorker' in navigator) || location.protocol === 'file:',\n        readableStreamTransfer: supportsReadableStreamTransfer(),\n      },\n    }\n\n    this.startHandler = context.supports.serviceWorkerApi\n      ? createFallbackStart(context)\n      : createStartHandler(context)\n\n    this.stopHandler = context.supports.serviceWorkerApi\n      ? createFallbackStop(context)\n      : createStop(context)\n\n    return context\n  }\n\n  public async start(options: StartOptions = {}): StartReturnType {\n    if (options.waitUntilReady === true) {\n      devUtils.warn(\n        'The \"waitUntilReady\" option has been deprecated. Please remove it from this \"worker.start()\" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.',\n      )\n    }\n\n    this.context.startOptions = mergeRight(\n      DEFAULT_START_OPTIONS,\n      options,\n    ) as SetupWorkerInternalContext['startOptions']\n\n    return await this.startHandler(this.context.startOptions, options)\n  }\n\n  public stop(): void {\n    super.dispose()\n    this.context.events.removeAllListeners()\n    this.context.emitter.removeAllListeners()\n    this.stopHandler()\n  }\n}\n\n/**\n * Sets up a requests interception in the browser with the given request handlers.\n * @param {RequestHandler[]} handlers List of request handlers.\n *\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker()` API reference}\n */\nexport function setupWorker(...handlers: Array<RequestHandler>): SetupWorker {\n  return new SetupWorkerApi(...handlers)\n}\n","/**\n * Returns a boolean indicating whether the current browser\n * supports `ReadableStream` as a `Transferable` when posting\n * messages.\n */\nexport function supportsReadableStreamTransfer() {\n  try {\n    const stream = new ReadableStream({\n      start: (controller) => controller.close(),\n    })\n    const message = new MessageChannel()\n    message.port1.postMessage(stream, [stream])\n    return true\n  } catch (error) {\n    return false\n  }\n}\n"]},"metadata":{},"sourceType":"module"}