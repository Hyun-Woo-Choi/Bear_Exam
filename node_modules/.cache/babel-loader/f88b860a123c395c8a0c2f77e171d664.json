{"ast":null,"code":"import { invariant } from \"outvariant\";\nimport { isNodeProcess } from \"is-node-process\";\nimport toughCookie from \"@bundled-es-modules/tough-cookie\";\nconst {\n  Cookie,\n  CookieJar,\n  Store,\n  MemoryCookieStore,\n  domainMatch,\n  pathMatch\n} = toughCookie;\n\nclass WebStorageCookieStore extends Store {\n  storage;\n  storageKey;\n\n  constructor() {\n    super();\n    invariant(typeof localStorage !== \"undefined\", \"Failed to create a WebStorageCookieStore: `localStorage` is not available in this environment. This is likely an issue with MSW. Please report it on GitHub: https://github.com/mswjs/msw/issues\");\n    this.synchronous = true;\n    this.storage = localStorage;\n    this.storageKey = \"__msw-cookie-store__\";\n  }\n\n  findCookie(domain, path, key, callback) {\n    try {\n      const store2 = this.getStore();\n      const cookies = this.filterCookiesFromList(store2, {\n        domain,\n        path,\n        key\n      });\n      callback(null, cookies[0] || null);\n    } catch (error) {\n      if (error instanceof Error) {\n        callback(error, null);\n      }\n    }\n  }\n\n  findCookies(domain, path, allowSpecialUseDomain, callback) {\n    if (!domain) {\n      callback(null, []);\n      return;\n    }\n\n    try {\n      const store2 = this.getStore();\n      const results = this.filterCookiesFromList(store2, {\n        domain,\n        path\n      });\n      callback(null, results);\n    } catch (error) {\n      if (error instanceof Error) {\n        callback(error, []);\n      }\n    }\n  }\n\n  putCookie(cookie, callback) {\n    try {\n      const store2 = this.getStore();\n      store2.push(cookie);\n      this.updateStore(store2);\n    } catch (error) {\n      if (error instanceof Error) {\n        callback(error);\n      }\n    }\n  }\n\n  updateCookie(oldCookie, newCookie, callback) {\n    this.putCookie(newCookie, callback);\n  }\n\n  removeCookie(domain, path, key, callback) {\n    try {\n      const store2 = this.getStore();\n      const nextStore = this.deleteCookiesFromList(store2, {\n        domain,\n        path,\n        key\n      });\n      this.updateStore(nextStore);\n      callback(null);\n    } catch (error) {\n      if (error instanceof Error) {\n        callback(error);\n      }\n    }\n  }\n\n  removeCookies(domain, path, callback) {\n    try {\n      const store2 = this.getStore();\n      const nextStore = this.deleteCookiesFromList(store2, {\n        domain,\n        path\n      });\n      this.updateStore(nextStore);\n      callback(null);\n    } catch (error) {\n      if (error instanceof Error) {\n        callback(error);\n      }\n    }\n  }\n\n  getAllCookies(callback) {\n    try {\n      callback(null, this.getStore());\n    } catch (error) {\n      if (error instanceof Error) {\n        callback(error, []);\n      }\n    }\n  }\n\n  getStore() {\n    try {\n      const json = this.storage.getItem(this.storageKey);\n\n      if (json == null) {\n        return [];\n      }\n\n      const rawCookies = JSON.parse(json);\n      const cookies = [];\n\n      for (const rawCookie of rawCookies) {\n        const cookie = Cookie.fromJSON(rawCookie);\n\n        if (cookie != null) {\n          cookies.push(cookie);\n        }\n      }\n\n      return cookies;\n    } catch {\n      return [];\n    }\n  }\n\n  updateStore(nextStore) {\n    this.storage.setItem(this.storageKey, JSON.stringify(nextStore.map(cookie => cookie.toJSON())));\n  }\n\n  filterCookiesFromList(cookies, matches) {\n    const result = [];\n\n    for (const cookie of cookies) {\n      if (matches.domain && !domainMatch(matches.domain, cookie.domain || \"\")) {\n        continue;\n      }\n\n      if (matches.path && !pathMatch(matches.path, cookie.path || \"\")) {\n        continue;\n      }\n\n      if (matches.key && cookie.key !== matches.key) {\n        continue;\n      }\n\n      result.push(cookie);\n    }\n\n    return result;\n  }\n\n  deleteCookiesFromList(cookies, matches) {\n    const matchingCookies = this.filterCookiesFromList(cookies, matches);\n    return cookies.filter(cookie => !matchingCookies.includes(cookie));\n  }\n\n}\n\nconst store = isNodeProcess() ? new MemoryCookieStore() : new WebStorageCookieStore();\nconst cookieStore = new CookieJar(store);\nexport { cookieStore };","map":{"version":3,"mappings":"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","names":["invariant","isNodeProcess","toughCookie","Cookie","CookieJar","Store","MemoryCookieStore","domainMatch","pathMatch","WebStorageCookieStore","storage","storageKey","constructor","localStorage","synchronous","findCookie","domain","path","key","callback","store","getStore","cookies","filterCookiesFromList","error","Error","findCookies","allowSpecialUseDomain","results","putCookie","cookie","push","updateStore","updateCookie","oldCookie","newCookie","removeCookie","nextStore","deleteCookiesFromList","removeCookies","getAllCookies","json","getItem","rawCookies","JSON","parse","rawCookie","fromJSON","setItem","stringify","map","toJSON","matches","result","matchingCookies","filter","includes","cookieStore"],"sources":["/Users/hyunwoochoi/Downloads/fe-homework-main-0.1.2/node_modules/msw/src/core/utils/cookieStore.ts"],"sourcesContent":["import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport toughCookie, {\n  type Cookie as CookieInstance,\n} from '@bundled-es-modules/tough-cookie'\n\nconst { Cookie, CookieJar, Store, MemoryCookieStore, domainMatch, pathMatch } =\n  toughCookie\n\n/**\n * Custom cookie store that uses the Web Storage API.\n * @see https://github.com/expo/tough-cookie-web-storage-store\n */\nclass WebStorageCookieStore extends Store {\n  private storage: Storage\n  private storageKey: string\n\n  constructor() {\n    super()\n\n    invariant(\n      typeof localStorage !== 'undefined',\n      'Failed to create a WebStorageCookieStore: `localStorage` is not available in this environment. This is likely an issue with MSW. Please report it on GitHub: https://github.com/mswjs/msw/issues',\n    )\n\n    this.synchronous = true\n    this.storage = localStorage\n    this.storageKey = '__msw-cookie-store__'\n  }\n\n  findCookie(\n    domain: string,\n    path: string,\n    key: string,\n    callback: (error: Error | null, cookie: CookieInstance | null) => void,\n  ): void {\n    try {\n      const store = this.getStore()\n      const cookies = this.filterCookiesFromList(store, { domain, path, key })\n      callback(null, cookies[0] || null)\n    } catch (error) {\n      if (error instanceof Error) {\n        callback(error, null)\n      }\n    }\n  }\n\n  findCookies(\n    domain: string,\n    path: string,\n    allowSpecialUseDomain: boolean,\n    callback: (error: Error | null, cookie: Array<CookieInstance>) => void,\n  ): void {\n    if (!domain) {\n      callback(null, [])\n      return\n    }\n\n    try {\n      const store = this.getStore()\n      const results = this.filterCookiesFromList(store, {\n        domain,\n        path,\n      })\n      callback(null, results)\n    } catch (error) {\n      if (error instanceof Error) {\n        callback(error, [])\n      }\n    }\n  }\n\n  putCookie(\n    cookie: CookieInstance,\n    callback: (error: Error | null) => void,\n  ): void {\n    try {\n      const store = this.getStore()\n      store.push(cookie)\n      this.updateStore(store)\n    } catch (error) {\n      if (error instanceof Error) {\n        callback(error)\n      }\n    }\n  }\n\n  updateCookie(\n    oldCookie: CookieInstance,\n    newCookie: CookieInstance,\n    callback: (error: Error | null) => void,\n  ): void {\n    this.putCookie(newCookie, callback)\n  }\n\n  removeCookie(\n    domain: string,\n    path: string,\n    key: string,\n    callback: (error: Error | null) => void,\n  ): void {\n    try {\n      const store = this.getStore()\n      const nextStore = this.deleteCookiesFromList(store, { domain, path, key })\n      this.updateStore(nextStore)\n      callback(null)\n    } catch (error) {\n      if (error instanceof Error) {\n        callback(error)\n      }\n    }\n  }\n\n  removeCookies(\n    domain: string,\n    path: string,\n    callback: (error: Error | null) => void,\n  ): void {\n    try {\n      const store = this.getStore()\n      const nextStore = this.deleteCookiesFromList(store, { domain, path })\n      this.updateStore(nextStore)\n      callback(null)\n    } catch (error) {\n      if (error instanceof Error) {\n        callback(error)\n      }\n    }\n  }\n\n  getAllCookies(\n    callback: (error: Error | null, cookie: Array<CookieInstance>) => void,\n  ): void {\n    try {\n      callback(null, this.getStore())\n    } catch (error) {\n      if (error instanceof Error) {\n        callback(error, [])\n      }\n    }\n  }\n\n  private getStore(): Array<CookieInstance> {\n    try {\n      const json = this.storage.getItem(this.storageKey)\n\n      if (json == null) {\n        return []\n      }\n\n      const rawCookies = JSON.parse(json) as Array<Record<string, any>>\n      const cookies: Array<CookieInstance> = []\n      for (const rawCookie of rawCookies) {\n        const cookie = Cookie.fromJSON(rawCookie)\n        if (cookie != null) {\n          cookies.push(cookie)\n        }\n      }\n      return cookies\n    } catch {\n      return []\n    }\n  }\n\n  private updateStore(nextStore: Array<CookieInstance>) {\n    this.storage.setItem(\n      this.storageKey,\n      JSON.stringify(nextStore.map((cookie) => cookie.toJSON())),\n    )\n  }\n\n  private filterCookiesFromList(\n    cookies: Array<CookieInstance>,\n    matches: { domain?: string; path?: string; key?: string },\n  ): Array<CookieInstance> {\n    const result: Array<CookieInstance> = []\n\n    for (const cookie of cookies) {\n      if (matches.domain && !domainMatch(matches.domain, cookie.domain || '')) {\n        continue\n      }\n\n      if (matches.path && !pathMatch(matches.path, cookie.path || '')) {\n        continue\n      }\n\n      if (matches.key && cookie.key !== matches.key) {\n        continue\n      }\n\n      result.push(cookie)\n    }\n\n    return result\n  }\n\n  private deleteCookiesFromList(\n    cookies: Array<CookieInstance>,\n    matches: { domain?: string; path?: string; key?: string },\n  ) {\n    const matchingCookies = this.filterCookiesFromList(cookies, matches)\n    return cookies.filter((cookie) => !matchingCookies.includes(cookie))\n  }\n}\n\nconst store = isNodeProcess()\n  ? new MemoryCookieStore()\n  : new WebStorageCookieStore()\n\nexport const cookieStore = new CookieJar(store)\n"]},"metadata":{},"sourceType":"module"}